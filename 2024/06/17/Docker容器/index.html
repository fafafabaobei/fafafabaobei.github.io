<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Docker容器 | fafafabaobei</title><meta name="author" content="fafafa"><meta name="copyright" content="fafafa"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Docker概念Docker 是一种用于开发、交付和运行应用程序的开放平台。它允许您在容器中打包应用程序及其依赖关系，并提供了一种轻量级、可移植和自包含的环境。以下是 Docker 的一些核心概念和特点：  容器化：Docker 利用 Linux 容器技术，将应用程序及其所有依赖项打包到一个容器中，这使得应用程序可以在任何环境中以相同的方式运行。 轻量级：与传统虚拟机相比，Docker 容器更加轻">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker容器">
<meta property="og:url" content="https://fafafabaobei.github.io/2024/06/17/Docker%E5%AE%B9%E5%99%A8/index.html">
<meta property="og:site_name" content="fafafabaobei">
<meta property="og:description" content="Docker概念Docker 是一种用于开发、交付和运行应用程序的开放平台。它允许您在容器中打包应用程序及其依赖关系，并提供了一种轻量级、可移植和自包含的环境。以下是 Docker 的一些核心概念和特点：  容器化：Docker 利用 Linux 容器技术，将应用程序及其所有依赖项打包到一个容器中，这使得应用程序可以在任何环境中以相同的方式运行。 轻量级：与传统虚拟机相比，Docker 容器更加轻">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tse1-mm.cn.bing.net/th/id/OIP-C.dEgEQ0JBlwn323Q_i0spsgHaEK?w=294&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7">
<meta property="article:published_time" content="2024-06-16T16:41:55.000Z">
<meta property="article:modified_time" content="2024-06-16T16:41:55.000Z">
<meta property="article:author" content="fafafa">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tse1-mm.cn.bing.net/th/id/OIP-C.dEgEQ0JBlwn323Q_i0spsgHaEK?w=294&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7"><link rel="shortcut icon" href="/img/blog.png"><link rel="canonical" href="https://fafafabaobei.github.io/2024/06/17/Docker%E5%AE%B9%E5%99%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker容器',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-17 00:41:55'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    btf.addGlobalFn('pjaxSend', () => { preloader.initLoading() }, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', () => { preloader.endLoading() }, 'preloader_end')
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/fafafa.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">50</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://tse1-mm.cn.bing.net/th/id/OIP-C.dEgEQ0JBlwn323Q_i0spsgHaEK?w=294&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7')"><nav id="nav"><span id="blog-info"><a href="/" title="fafafabaobei"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/blog.png" alt="Logo"/><span class="site-name">fafafabaobei</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Docker容器<a class="post-edit-link" href="null_posts/Docker容器.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-16T16:41:55.000Z" title="发表于 2024-06-17 00:41:55">2024-06-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-16T16:41:55.000Z" title="更新于 2024-06-17 00:41:55">2024-06-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Docker/">Docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Docker容器"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Docker 是一种用于开发、交付和运行应用程序的开放平台。它允许您在容器中打包应用程序及其依赖关系，并提供了一种轻量级、可移植和自包含的环境。以下是 Docker 的一些核心概念和特点：</p>
<ol>
<li>容器化：Docker 利用 Linux 容器技术，将应用程序及其所有依赖项打包到一个容器中，这使得应用程序可以在任何环境中以相同的方式运行。</li>
<li>轻量级：与传统虚拟机相比，Docker 容器更加轻量级，在性能和资源消耗上都有优势。</li>
<li>可移植性：由于 Docker 容器封装了应用程序及其依赖项，因此可以轻松地在不同的主机上进行部署和运行。</li>
<li>自动化：Docker 提供了丰富而强大的 API 和工具集，帮助用户自动化构建、部署和扩展应用服务。</li>
<li>镜像与容器：Docker 使用镜像来打包应用程序及其环境，并使用容器来实际运行这些镜像。</li>
</ol>
<p>Docker 通过提供一种简单且易于管理的方式来进行软件交付与部署，使得开发人员、系统管理员以及整个组织可以更高效地构建、交付和管理应用。</p>
<blockquote>
<p> <strong>Docker</strong> 包括三个基本概念</p>
<ul>
<li><strong>镜像</strong>（<code>Image</code>）</li>
<li><strong>容器</strong>（<code>Container</code>）</li>
<li><strong>仓库</strong>（<code>Repository</code>）</li>
</ul>
</blockquote>
<h4 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h4><p>Docker 镜像采用分层存储机制，在构建过程中每一步操作都会在当前基础上创建新一层，并将其中间结果保存为新层。这种分层存储机制使得 Docker 镜像具备了以下特点：</p>
<ul>
<li>重用性：多个不同的容器可以共享相同底层图层（Layer），减少磁盘空间占用。</li>
<li>可复制性：如果需要修改某个图层，则只需修改对应图层数字即可，而无需重新复制整个文件系统。</li>
<li>分发性：由于每个图层都可以单独存在并被推送到注册表中，因此也更易于分发和分享。</li>
</ul>
<h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><p>镜像是 Docker 中的核心概念，它是用于打包应用程序及其依赖项的轻量级、可移植的部署单元。镜像实际上是一个只读的模板，它包含了运行应用程序所需的所有文件系统内容、运行时配置和环境变量。</p>
<p>使用方法：</p>
<ol>
<li>拉取镜像：要使用某个镜像，首先需要从 Docker Hub 或其他注册表中拉取该镜像。可以使用 <code>docker pull</code> 命令来拉取指定版本或标签的镜像。</li>
<li>运行容器：一旦有了所需的镜像，可以使用 <code>docker run</code> 命令基于该镜像创建并运行一个容器实例。</li>
<li>定制与构建：如果现有的公共镜像不满足需求，可以通过编写 Dockerfile 来定义自己的定制化镜像，并通过 <code>docker build</code> 命令来构建这个新版本的自定义镜像。</li>
</ol>
<p>- </p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>。</p>
<h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a target="_blank" rel="noopener" href="https://docker-practice.github.io/zh-cn/repository/registry.html">Docker Registry</a> 就是这样的服务。</p>
<p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>
<p><strong>Docker Registry 公开服务</strong></p>
<p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。</p>
<p><strong>私有 Docker Registry</strong></p>
<p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/registry/">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Docker确实分为三个更新频道：stable、test和nightly。以下是这三个更新频道的详细说明：</p>
<ol>
<li><strong>Stable（稳定版）</strong>：<ul>
<li>这是Docker的正式发布版本，经过充分测试，适合生产环境使用。</li>
<li>用户可以依赖于此版本的稳定性和安全性，通常包含经过验证的功能和修复。</li>
</ul>
</li>
<li><strong>Test（测试版）</strong>：<ul>
<li>这个频道包含最新的功能和修复，但尚未经过全面的生产环境测试。</li>
<li>适合开发者和测试人员使用，以便在新功能正式发布之前进行试用和反馈。</li>
</ul>
</li>
<li><strong>Nightly（夜间版）</strong>：<ul>
<li>这是每日构建的版本，包含最新的代码更改和功能。</li>
<li>由于是最新构建，可能会包含未经过测试的功能，因此不建议在生产环境中使用。</li>
<li>适合开发者希望测试最新功能或参与Docker开发的用户。</li>
</ul>
</li>
</ol>
<h4 id="Ubuntu-安装-Docker"><a href="#Ubuntu-安装-Docker" class="headerlink" title="Ubuntu 安装 Docker"></a>Ubuntu 安装 Docker</h4><ol>
<li>更新现有的包索引</li>
</ol>
<p>首先，打开终端并更新现有的包索引：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 APT 安装</li>
</ol>
<p>由于 <code>apt</code> 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加Docker的官方GPG密钥</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>添加Docker的稳定版仓库</li>
</ol>
<p>向 <code>sources.list</code> 中添加 Docker 软件源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>安装 Docker</li>
</ol>
<p>更新 apt 软件包缓存，并安装 <code>docker-ce</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>启动Docker并设置为开机自启</li>
</ol>
<p>安装完成后，启动Docker服务并设置为开机自启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker  </span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker  </span><br></pre></td></tr></table></figure>

<ol start="7">
<li>验证Docker安装</li>
</ol>
<p>可以通过运行以下命令来验证Docker是否安装成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker --version  </span><br></pre></td></tr></table></figure>

<ol start="8">
<li>可选）将当前用户添加到Docker组</li>
</ol>
<p>默认情况下，<code>docker</code> 命令会使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span>  </span><br></pre></td></tr></table></figure>

<ol start="9">
<li>测试 Docker 是否安装正确</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --<span class="built_in">rm</span> hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image <span class="string">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">b8dfde127a29: Pull complete</span><br><span class="line">Digest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker 国内镜像加速</p>
<p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，例如：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">阿里云加速器(点击管理控制台 -&gt; 登录账号(淘宝账号) -&gt; 右侧镜像工具 -&gt; 镜像加速器 -&gt; 复制加速器地址)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.163yun.com/help/documents/56918246390157312">网易云加速器 <code>https://hub-mirror.c.163.com</code></a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.baidu.com/doc/CCE/s/Yjxppt74z#%E4%BD%BF%E7%94%A8dockerhub%E5%8A%A0%E9%80%9F%E5%99%A8">百度云加速器 <code>https://mirror.baidubce.com</code></a></li>
</ul>
<p><strong>由于镜像服务可能出现宕机，建议同时配置多个镜像。</strong></p>
</blockquote>
<h4 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-mac/">Docker Desktop for Mac</a> 要求系统最低为 macOS Mojave 10.14。</p>
</blockquote>
<ol>
<li><p>安装</p>
<ul>
<li>使用 Homebrew 安装</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://brew.sh/">Homebrew</a> 的 <a target="_blank" rel="noopener" href="https://github.com/Homebrew/homebrew-cask">Cask</a> 已经支持 Docker Desktop for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install --cask docker</span><br></pre></td></tr></table></figure>

<ul>
<li>手动下载安装</li>
</ul>
<p>如果需要手动下载，请点击以下 <a target="_blank" rel="noopener" href="https://desktop.docker.com/mac/main/amd64/Docker.dmg">链接</a> 下载 Docker Desktop for Mac。</p>
<blockquote>
<p>你可以在 <a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-mac/apple-silicon/">官方文档</a> 查阅已知的问题。</p>
</blockquote>
<p>双击下载的 <code>.dmg</code> 文件，然后将那只叫 <a target="_blank" rel="noopener" href="https://www.docker.com/blog/call-me-moby-dock/">Moby</a> 的鲸鱼图标拖拽到 <code>Application</code> 文件夹即可（其间需要输入用户密码）。</p>
</li>
<li><p>运行</p>
<p>从应用中找到 Docker 图标并点击运行</p>
<p>你可以在终端通过命令检查安装后的 Docker 版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker --version</span><br><span class="line">Docker version 20.10.0, build 7287ab3</span><br></pre></td></tr></table></figure>

<p>如果 <code>docker version</code>、<code>docker info</code> 都正常的话，可以尝试运行一个 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/nginx/">Nginx 服务器</a>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 80:80 --name webserver nginx</span><br></pre></td></tr></table></figure>

<p>要停止 Nginx 服务器并删除执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop webserver</span><br><span class="line">$ docker <span class="built_in">rm</span> webserver</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Windows-10-11"><a href="#Windows-10-11" class="headerlink" title="Windows 10&#x2F;11"></a>Windows 10&#x2F;11</h4><blockquote>
<ul>
<li><strong>Windows 10 64-bit</strong>：需要使用Windows 10 Professional、Enterprise或Education版本。</li>
<li><strong>Windows 10 Home</strong>：从Docker Desktop 2.3.0.2版本开始，Docker Desktop也支持Windows 10 Home，但需要启用WSL 2（Windows Subsystem for Linux 2）。</li>
</ul>
</blockquote>
<ol>
<li><p>安装</p>
<ul>
<li><p><strong>手动下载安装</strong></p>
<p>点击以下 [链接](<a target="_blank" rel="noopener" href="https://desktop.docker.com/win/main/amd64/Docker">https://desktop.docker.com/win/main/amd64/Docker</a> Desktop Installer.exe) 下载 Docker Desktop for Windows。</p>
<p>下载好之后双击 <code>Docker Desktop Installer.exe</code> 开始安装。</p>
</li>
<li><p><strong>使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/package-manager/">winget</a> 安装</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> winget install Docker.DockerDesktop</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>运行</p>
<p>在 Windows 搜索栏输入 <strong>Docker</strong> 点击 <strong>Docker Desktop</strong> 开始运行</p>
</li>
</ol>
<h3 id="镜像使用"><a href="#镜像使用" class="headerlink" title="镜像使用"></a>镜像使用</h3><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>

<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub(<code>docker.io</code>)。</li>
<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li>
</ul>
<p>比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">92dc2a97ff99: Pull complete</span><br><span class="line">be13a9d27eb8: Pull complete</span><br><span class="line">c8299583700a: Pull complete</span><br><span class="line">Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span><br><span class="line">docker.io/library/ubuntu:18.04</span><br></pre></td></tr></table></figure>

<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （<code>docker.io</code>）获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。<code>docker pull</code> 命令的输出结果最后一行给出了镜像的完整名称，即： <code>docker.io/library/ubuntu:18.04</code>。</p>
<h4 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> ubuntu:18.04 bash</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
</ul>
<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令</p>
<h4 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h4><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis                latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx                latest              05a60462f8ba        5 days ago          181 MB</span><br><span class="line">mongo                3.2                 fe9198c04d62        5 days ago          342 MB</span><br><span class="line">ubuntu               18.04               329ed837d508        3 days ago          63.3MB</span><br><span class="line">ubuntu               bionic              329ed837d508        3 days ago          63.3MB</span><br><span class="line"><span class="comment"># 列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。</span></span><br></pre></td></tr></table></figure>

<p>如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。<br>把所有的虚悬镜像的 ID 列出来,<code>-q</code> 参数。</p>
<p><strong>自定义输出格式</strong></p>
<p>使用 <code>--format</code> 选项可以根据需要输出特定的字段。例如，下面的命令只会显示容器的ID和名称：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps --format <span class="string">&quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Names&#125;&#125;&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出正在运行的容器ID和状态：</span></span><br><span class="line">$ docker ps --format <span class="string">&quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Status&#125;&#125;&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有镜像的名称和大小：</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> --format <span class="string">&quot;&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125; - &#123;&#123;.Size&#125;&#125;&quot;</span>  </span><br></pre></td></tr></table></figure>

<p>在 <code>docker ps</code> 的 <code>--format</code> 选项中，可以使用以下字段：</p>
<ul>
<li><code>ID</code>：容器ID</li>
<li><code>Image</code>：使用的镜像</li>
<li><code>Command</code>：运行的命令</li>
<li><code>Created</code>：创建日期</li>
<li><code>RunningFor</code>：运行时间</li>
<li><code>Ports</code>：端口映射</li>
<li><code>Status</code>：容器状态</li>
<li><code>Size</code>：容器大小</li>
<li><code>Names</code>：容器名称</li>
<li><code>Labels</code>：容器标签</li>
<li><code>Mounts</code>：挂载的卷</li>
</ul>
<p>在 <code>docker image ls</code> 的 <code>--format</code> 选项中，可以使用以下字段：</p>
<ul>
<li><code>ID</code>：镜像ID</li>
<li><code>Repository</code>：镜像仓库名称</li>
<li><code>Tag</code>：镜像标签</li>
<li><code>Created</code>：创建日期</li>
<li><code>Size</code>：镜像大小</li>
</ul>
<h3 id="Docker容器操作"><a href="#Docker容器操作" class="headerlink" title="Docker容器操作"></a>Docker容器操作</h3><h4 id="docker-run-Hello-word"><a href="#docker-run-Hello-word" class="headerlink" title="docker run Hello-word"></a>docker run Hello-word</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/06/17/Docker%E5%AE%B9%E5%99%A8/Users\发发发宝贝\AppData\Roaming\Typora\typora-user-images\image-20250420202121029.png" alt="image-20250420202121029"></p>
<h4 id="docker-run-执行流程-工作流程"><a href="#docker-run-执行流程-工作流程" class="headerlink" title="docker run 执行流程(工作流程)"></a>docker run 执行流程(工作流程)</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/06/17/Docker%E5%AE%B9%E5%99%A8/Users\发发发宝贝\AppData\Roaming\Typora\typora-user-images\image-20250420203112226.png" alt="image-20250420203112226"></p>
<p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问<br>DockerServer接收到Docker-Client的指令，就会执行这个命令</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/06/17/Docker%E5%AE%B9%E5%99%A8/Users\发发发宝贝\AppData\Roaming\Typora\typora-user-images\image-20250423004136352.png" alt="image-20250423004136352"></p>
<p><strong>docker相比传统的VM</strong></p>
<p>Docker 相比传统虚拟机（VM）快<br>主要有以下几点：</p>
<ol>
<li><strong>轻量级架构</strong>：<ul>
<li>Docker 使用容器技术，而虚拟机则运行完整的操作系统。容器共享宿主机的操作系统内核，而虚拟机需要完整的操作系统及其所需的资源（如内存、CPU等），因此启动和运行速度更快。</li>
</ul>
</li>
<li><strong>资源利用率</strong>：<ul>
<li>容器在宿主操作系统之上运行，它们直接共享宿主机的资源而无需进行额外的虚拟化层。这使得 Docker 能够实现更高效的资源利用，减少了资源的开销。</li>
</ul>
</li>
<li><strong>快速启动</strong>：<ul>
<li>Docker 容器能够在几秒钟内启动，因为它们不需要加载完整的操作系统，而是直接运行应用程序。因此，与虚拟机相比，容器的启动和停止时间显著缩短。</li>
</ul>
</li>
<li><strong>更少的开销</strong>：<ul>
<li>Docker 使用的资源较少，因为它只包含了运行应用所需的最小文件系统。容器可以快速复制和部署，减少了磁盘和内存的使用。</li>
</ul>
</li>
<li><strong>便捷的管理和部署</strong>：<ul>
<li>Docker 的图像和容器管理工具（如 Docker Hub、Docker Compose 等）使得开发、分发和部署变得更加简单和高效，可以快速创建新的环境。</li>
</ul>
</li>
</ol>
<h3 id="Docker-命令"><a href="#Docker-命令" class="headerlink" title="Docker 命令"></a>Docker 命令</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><strong>帮助命令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker version # 显示docker版本信息</span><br><span class="line"></span><br><span class="line">docker info	# 显示docker系统信息，包括镜像和容器</span><br><span class="line"></span><br><span class="line">docker 命令 --help  # 帮助命令</span><br></pre></td></tr></table></figure>

<p><strong>镜像命令</strong></p>
<ul>
<li><p>查看镜像  - <code>docker images </code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker images # 查看所有镜像</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-a 显示所有镜像</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f 过滤</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-q 只显示<span class="built_in">id</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/06/17/Docker%E5%AE%B9%E5%99%A8/Users\发发发宝贝\AppData\Roaming\Typora\typora-user-images\image-20250423005847103.png" alt="image-20250423005847103"></p>
<ul>
<li><p>查询镜像 - <code>docker search</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql # 查询mysql镜像</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载镜像 - <code>docker pull</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql # 下载镜像</span><br><span class="line">docker pull mysql:8.0.20</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除镜像 - <code>docker rmi</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f e73346bdf465 # id 为 docker images 下的IMAGE ID</span><br><span class="line">docker rmi -f id1, id2, id3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>容器命令</strong></p>
<blockquote>
<p>容器基于镜像，创建容器首先要有镜像<br>用于学习容器命令，可以准备一个centos容器：docker pull centos</p>
</blockquote>
<ul>
<li><p>新建&#x2F;启动容器 - <code>docker run image</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name 命名容器名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 后台运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-it 使用交互方式运行，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-P 指定容器的端口</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">-P 主机端口:容器端口(-P 65505:3306)  指定主机的端口跟容器端口之间的联系</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">-P ip:主机端口:容器端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 随机指定端口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>退出容器并停止容器 - <code>exit</code></p>
</li>
<li><p>不停止容器退出 - <code>Ctrl+P+Q</code></p>
</li>
<li><p>查看当前运行的环境 - <code>docker ps</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker ps # 查看后台运行的容器</span><br><span class="line">docker ps -a # 查看所有运行过的容器，包括已退出的</span><br><span class="line">docker ps -n=x # 查看最近使用的容器，n为展示数量</span><br><span class="line">docker -q # 只展示 CONTAINER ID</span><br><span class="line">docker -aq # 只展示所有容器 CONTAINER ID</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除容器 - <code>docker rm</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id # 注:运行中不能删除</span><br><span class="line">docker rm -f 容器id # 强制删除所有容器，包括运行中</span><br><span class="line">docker rm -f $(docker ps -aq) # 删除所有容器</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止运行的容器 - <code>docker stop </code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器id</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制停止</span></span><br><span class="line">docker kill 容器id</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动容器 - <code>docker start</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动容器 - <code>docker restart </code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器id</span><br></pre></td></tr></table></figure>
</li>
<li><p>后台启动容器 - <code>docker run -d</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d 容器id </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 docker run -d 启动容器，会导致容器停止；docker容器在后台运行，就必须要有一个前台进程，docker发现没有应用进程，就会自动停止</span></span><br><span class="line">docker run -d 容器id /bin/sh -c &quot;while true; do echo &#x27;123asd&#x27;; sleep 2;done&quot; # 后台打开容器，并执行shell脚本命令</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看日志 - <code>docker logs</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker logs [可选参数] 容器id</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数使用</span></span><br><span class="line">docker logs -tf 容器id # 查看全部日志 -t为带上时间戳</span><br><span class="line">docker logs -t --tail 20 容器id # 查看最后20行日志</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看容器进程 - <code>docker top</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器id # 查看容器内部的进程</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看容器cpu状态 - <code>docker stats</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></figure>


</li>
<li><p>查看镜像源数据&#x2F; 查看当前容器启动信息 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入当前正在进行的容器 </p>
<ul>
<li>方式一：<code>docker exec</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器id bashShell # 进入的是一个新的终端</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二： <code>docker attach</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器id # 进入当前容器正在运行的终端</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件传输 - <code>docker cp</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从容器内拷贝文件到主机：</span></span><br><span class="line">docker cp 容器id:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p><strong>部署Nginx</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索nginx版本  - docker管网 https://hub.docker.com</span></span><br><span class="line">docker search nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载镜像 - 可省略(docker run 会下载并启动镜像)</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动镜像 --name 起别名</span> </span><br><span class="line">docker run -d --name NginxServer -p 3344:80 nginx </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用本机访问容器内的nginx (端口映射)</span></span><br><span class="line">curl localhost:3344</span><br></pre></td></tr></table></figure>

<p><strong>部署Tomcat</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">额外使用方式：下载并启动Tomcat docker ; --<span class="built_in">rm</span> : 即一次性，用完即删。可用来测试</span></span><br><span class="line">docker run -it --rm tomcat:9.0 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载并启动</span></span><br><span class="line">docker pull tomcat:9.0 </span><br><span class="line">docker run -d -p 3355:8080 --name TomcatServer tomcat</span><br></pre></td></tr></table></figure>

<p><strong>部署ES+Kibana</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ES 特点：暴露端口多；十分耗内存；数据需要放置到安全目录(挂载)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--net somenetwork 网络配置</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">十分耗内存解决方法：-e 进行设置环境配置: -e ES_JAVA_OPTS=<span class="string">&quot;-Xms64m, -Xmx512m&quot;</span>（设置ES_JAVA_OPTS最大512M，最小64M）</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m, -Xmx512m&quot; elasticsearch:7.6.2</span><br></pre></td></tr></table></figure>

<h4 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h4><p><strong>Rancher</strong></p>
<p><strong>portainer</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure>

<h3 id="Docker-镜像原理"><a href="#Docker-镜像原理" class="headerlink" title="Docker 镜像原理"></a>Docker 镜像原理</h3><h4 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h4><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，包含某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件</p>
<ul>
<li><strong>结构</strong>：Docker 镜像是由多层文件系统组成的，每一层都是只读的，代表了 Dockerfile 中的指令。下层通常是基础镜像，随后是应用层和配置层。</li>
<li><strong>分层文件系统</strong>：每一层都会在文件系统中产生变化，可以看作是对上层的一次增量更新。</li>
</ul>
<p><strong>UnionFS 联合文件系统</strong></p>
<p>UnionFS 联合文件系统：Union文件系统是一种分层、轻量级并且高性能的文件系统，它允许用户将多个文件系统的内容合并在一起，形成一个统一的视图。这种技术常用于Linux和Unix系统中，能够提高灵活性和效率，特别是在容器化和虚拟化的环境中。</p>
<h4 id="UnionFS的工作原理"><a href="#UnionFS的工作原理" class="headerlink" title="UnionFS的工作原理"></a>UnionFS的工作原理</h4><p>UnionFS通过以下方式工作：</p>
<ol>
<li><strong>层叠结构</strong>：UnionFS能够将多个文件系统（层）叠加在一起。用户看到的文件和目录实际上是这些层的组合。</li>
<li><strong>读写分离</strong>：在这种结构中，通常会有一个只读的底层文件系统和一个可读写的上层文件系统。对文件的修改会发生在上层文件系统中，而底层文件系统保持不变。</li>
<li><strong>文件合并</strong>：当用户访问文件时，UnionFS会检查上层，如果上层没有这个文件，才会去底层查找。这样，用户可以同时使用多个文件系统中的文件，而不需要复杂的管理</li>
</ol>
<h4 id="Docker-镜像的加载原理"><a href="#Docker-镜像的加载原理" class="headerlink" title="Docker 镜像的加载原理"></a>Docker 镜像的加载原理</h4><blockquote>
<p>Docker 镜像的加载原理主要涉及到 Docker 的分层文件系统和镜像存储机制。</p>
</blockquote>
<p>Docker 镜像的加载与 <code>rootfs</code> 的形成过程如下：</p>
<ol>
<li><strong>归档与解压</strong>：<ul>
<li>当你使用 <code>docker load</code> 命令加载镜像时，实际上是从一个 <code>.tar</code> 文件中解压出镜像的分层。</li>
<li>每一层都会被展开，存储在 Docker 的存储驱动管理的区域中。</li>
</ul>
</li>
<li>**构建 <code>rootfs</code>**：<ul>
<li>Docker 从镜像的最底层开始，逐层堆叠，最终形成完整的 <code>rootfs</code>。这时，所有的只读层结合在一起，形成一个可供容器使用的文件系统。</li>
</ul>
</li>
<li><strong>挂载文件系统</strong>：<ul>
<li>在容器启动时，这个 <code>rootfs</code> 被挂载为容器的文件系统。Docker 的存储驱动负责将这些只读层与写层组合在一起。</li>
<li>写层通常是可写的，所有对文件的修改都会体现在这一层，而不会影响前面的只读层。</li>
</ul>
</li>
<li><strong>执行容器</strong>：<ul>
<li>一旦容器启动，<code>rootfs</code> 成为其运行时的基础文件系统，允许容器执行命令和读写文件。</li>
</ul>
</li>
</ol>
<h4 id="Docker-分层原理"><a href="#Docker-分层原理" class="headerlink" title="Docker 分层原理"></a>Docker 分层原理</h4><blockquote>
<p>Docker 的分层原理是其设计中非常重要的特性，允许镜像和容器以高效和可复用的方式管理文件系统。</p>
</blockquote>
<p><strong>分层文件系统简介</strong></p>
<p>Docker 镜像是由多个只读层（read-only layers）组成的，每个层都代表了文件系统的一个快照。这种结构使得 Docker 能够实现镜像的快速构建、共享和存储。</p>
<p><strong>分层的基本概念</strong></p>
<p>在 Docker 中，分层的基本概念包括以下几个方面：</p>
<ul>
<li><strong>基础镜像</strong>：每个镜像都可以基于其他镜像，以此来构建新的镜像。例如，<code>FROM ubuntu</code> 表明这个镜像是建立在 Ubuntu 基础镜像之上。</li>
<li><strong>镜像层</strong>：在 Dockerfile 中的每一条指令创建一个新的镜像层。例如，<code>RUN</code>, <code>COPY</code>, <code>ADD</code> 等指令都会生成一个新的层。</li>
<li><strong>只读特性</strong>：每个镜像层是只读的，只能被访问而不能被修改。当修改文件时，Docker 会在文件系统的最上层创建一个可写层（writeable layer）。</li>
</ul>
<p><strong>分层的工作机制</strong></p>
<ul>
<li><strong>创建与下载</strong>：当你构建或下载镜像时，Docker 将检查该镜像的每一层。如果某一层已经存在于本地，Docker 将不会重复下载或创建这层，而是直接复用。这一特性显著提高了镜像的构建和分发效率。</li>
<li><strong>层的合并</strong>：当容器启动时，Docker 将所有的只读层与一个可写层合并形成一个完整的文件系统（<code>rootfs</code>）。在该过程中，所有的文件操作（如创建、修改、删除）都会在可写层中进行，而不会影响到已经存在的只读层。</li>
<li><strong>写时复制</strong>（Copy-on-Write, CoW）：当容器对文件进行修改时，Docker 会在可写层中复制这个文件的只读版本，然后对其进行修改。这意味着任何对文件的改动只在可写层中存在，而原有的只读层保持不变。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/06/17/Docker%E5%AE%B9%E5%99%A8/Users\发发发宝贝\AppData\Roaming\Typora\typora-user-images\image-20250429005506382.png" alt="image-20250429005506382"></p>
<p>可以使用 <code>docker image inspect redis:latest</code> 来查看层级</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/06/17/Docker%E5%AE%B9%E5%99%A8/Users\发发发宝贝\AppData\Roaming\Typora\typora-user-images\image-20250429005633934.png" alt="image-20250429005633934"></p>
<h4 id="如何提交一个自己的镜像-commit-镜像"><a href="#如何提交一个自己的镜像-commit-镜像" class="headerlink" title="如何提交一个自己的镜像 - commit 镜像"></a>如何提交一个自己的镜像 - <code>commit</code> 镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a=&quot;作者&quot; -m=&quot;提交记录&quot; 容器id 别名:版本</span><br></pre></td></tr></table></figure>



<h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><blockquote>
<p>理念：数据都在容器中，如果删除了容器，数据就会丢失<br>怎么实现数据持久化？容器数据之间如何共享？</p>
</blockquote>
<h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>容器数据卷（Volume）是容器化技术（如Docker）中的一个重要概念，用于持久化和管理容器内的数据。数据卷可以解决一些重要的问题，诸如容器重启、更新或者卸载时如何保留数据、实现容器间的数据共享等。<br>原理：容器数据卷技术：即将容器内的目录，<strong>挂载</strong>到Linux上面；<br>容器内可以访问容器外数据，容器内处理保存的数据，在Linux主机上</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/06/17/Docker%E5%AE%B9%E5%99%A8/Users\发发发宝贝\AppData\Roaming\Typora\typora-user-images\image-20250430184853898.png" alt="image-20250430184853898"><br>当两个容器共用同一个数据卷，则这两个容器数据共享</p>
<h4 id="数据卷的特点"><a href="#数据卷的特点" class="headerlink" title="数据卷的特点"></a>数据卷的特点</h4><ol>
<li><strong>持久性</strong>：数据卷的生命周期独立于使用它的容器。即使容器被删除，数据卷中的数据仍然存在。</li>
<li><strong>共享和重用</strong>：多个容器可以共享同一个数据卷。这使得数据能够在容器间进行共享和重用。</li>
<li><strong>性能</strong>：数据卷通常比在容器文件系统中存储数据要快。对数据卷的读写操作可以获得更好的性能。</li>
<li><strong>方便备份和恢复</strong>：数据卷使得备份和恢复操作变得简单方便。只需对数据卷进行备份，而不需要关心哪个容器在使用它。</li>
</ol>
<h4 id="数据卷的种类"><a href="#数据卷的种类" class="headerlink" title="数据卷的种类"></a>数据卷的种类</h4><ol>
<li><strong>管理卷（Named Volumes）</strong>：由Docker管理，存储在主机上的特定位置。适合用于持久化数据。</li>
<li><strong>匿名卷（Anonymous Volumes）</strong>：没有名称，临时使用后可以被删除。</li>
<li><strong>绑定挂载（Bind Mounts）</strong>：直接将主机的目录或文件挂载到容器内，可以实现对主机文件的直接访问和修改。适用于开发环境。</li>
</ol>
<h4 id="数据卷的使用"><a href="#数据卷的使用" class="headerlink" title="数据卷的使用"></a>数据卷的使用</h4><h5 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h5><p>使用 <code>-v</code> 参数来挂载数据卷</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run -it -v 主机目录:容器内目录</span></span><br><span class="line">docker run -it -v /home/ceshi:/home</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看镜像详细</span></span><br><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/06/17/Docker%E5%AE%B9%E5%99%A8/Users\发发发宝贝\AppData\Roaming\Typora\typora-user-images\image-20250505143253488.png" alt="image-20250505143253488"></p>
<h5 id="具名挂载-匿名挂载-指定路径挂载"><a href="#具名挂载-匿名挂载-指定路径挂载" class="headerlink" title="具名挂载&amp;匿名挂载&amp;指定路径挂载"></a>具名挂载&amp;匿名挂载&amp;指定路径挂载</h5><blockquote>
<p>-v 容器内路径   匿名挂载<br>-v 卷名: 容器内路径   具名挂载<br>-v &#x2F;宿主主机路径: 容器内路径   指定路径挂载</p>
</blockquote>
<p><strong>匿名挂载</strong><br>匿名挂载，在创建容器的时候 <code>-v</code> 只写了容器内的路径，没有写容器外的路径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name Nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有 volume</span> </span><br><span class="line">docker volume ls</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/06/17/Docker%E5%AE%B9%E5%99%A8/Users\发发发宝贝\AppData\Roaming\Typora\typora-user-images\image-20250508002919759.png" alt="image-20250508002919759"></p>
<p><strong>具名挂载</strong><br>即通过 <code>-v </code>传入 卷名：容器内路径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name Nginx01 -v Nginx_mount:/etc/nginx nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chakan suoyou volume</span></span><br><span class="line">docker volume ls</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/06/17/Docker%E5%AE%B9%E5%99%A8/Users\发发发宝贝\AppData\Roaming\Typora\typora-user-images\image-20250508003219173.png" alt="image-20250508003219173"></p>
<ul>
<li><p>查看具体容器内的制定目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect [VOLUME NAME]</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/06/17/Docker%E5%AE%B9%E5%99%A8/Users\发发发宝贝\AppData\Roaming\Typora\typora-user-images\image-20250508003331284.png" alt="image-20250508003331284"></p>
</li>
</ul>
<h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><p>-v 参数还可以在容器内路径后加 :<code>ro</code> 或 :<code>rw </code>；来控制读写权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name Nginx01 -v Nginx_mount:/etc/nginx:ro nginx</span><br><span class="line">docker run -d --name Nginx01 -v Nginx_mount:/etc/nginx:rw nginx</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ro</code></p>
<p>即：<code>readonly </code> 只读权限 ；这个路径职能通过宿主主机来操作，容器内部无法操作</p>
</li>
<li><p><code>rw</code> (默认)</p>
<p>即：<code>readwrite </code> 可读可写</p>
</li>
</ul>
<h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>多个容器共享使用一个数据挂载目录，实现容器数据共享</p>
<p><strong>–volumes-from</strong></p>
<p><code>--volumes-from</code> 是 Docker 中一个用于挂载其他容器数据卷的选项。它允许你将一个容器的卷（Volumes）挂载到另一个容器中，使得这两个容器之间能够共享数据。</p>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>服务分离</strong>：假设你的应用程序由多个服务组成，每个服务都运行在不同的容器中，但它们需要访问同一个数据存储。</li>
<li><strong>简化容器管理</strong>：当你需要多个容器使用相同的数据卷时，使用 <code>--volumes-from</code> 可以避免重复设置相同的卷挂载</li>
</ul>
<p><strong>注意事项和拓展</strong></p>
<ol>
<li><p><strong>数据卷的生命周期</strong>：使用 <code>--volumes-from</code> 挂载的卷，他们的生命周期与源容器的生命周期相关。当源容器删除时，挂载的卷仍然存在，但它们的使用受到限制。</p>
</li>
<li><p><strong>只读和读写</strong>：可以使用 <code>:ro</code> 选项来使挂载的卷为只读，例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name app_container --volumes-from db_data:ro ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>限制</strong>：<code>--volumes-from</code> 只能用于已经存在的容器，不能用于直接挂载新的卷。</p>
</li>
</ol>
<p><strong>示例</strong></p>
<ol>
<li><p><strong>启动一个存储数据的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建了一个名为 db_data 的容器，并在其中创建了一个名为 /data/db 的数据卷</span></span><br><span class="line">docker run -d --name db_data -v /data/db busybox</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行另一个容器并挂载第一个容器的卷</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令启用了一个名为 app_container 的新容器，并将 db_data 容器的所有数据卷挂载到此容器中</span></span><br><span class="line">docker run -it --name app_container --volumes-from db_data ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>进入 <code>app_container</code> 容器后，你可以看到 <code>db_data</code> 容器中 <code>/data/db</code> 路径下的数据</p>
</li>
</ol>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Dockerfile 是一种文本文件，包含了一系列指令，用于自动化 Docker 镜像的构建。通过 Dockerfile，开发者可以定义应用程序的环境、所需的依赖、运行特性等，从而简化软件的部署和分发流程。</p>
<h4 id="Docker-镜像的层次结构"><a href="#Docker-镜像的层次结构" class="headerlink" title="Docker 镜像的层次结构"></a>Docker 镜像的层次结构</h4><p>Docker 镜像的构建是基于分层文件系统（Layered Filesystem）概念的，每个镜像都是由多个层（Layers）堆叠而成的。每个层代表了镜像的一部分，并且这些层是不可变的。当你基于一个已有镜像创建新的镜像时，Docker 会在现有镜像的基础上添加新的层。</p>
<ol>
<li><strong>基础镜像</strong>：每个 Docker 镜像都以一个基础镜像为起点，比如 <code>ubuntu</code>、<code>alpine</code> 或 <code>python</code> 等。基础镜像本身也可以是由其他镜像构建而成的。</li>
<li><strong>中间层</strong>：在 Dockerfile 中，每执行一条命令（如 <code>RUN</code>、<code>COPY</code>、<code>ADD</code> 等）时，Docker 创建一个新的层。这个层包含了该命令执行后文件系统的变化。例如，安装软件包或复制文件时会产生新的层。</li>
<li><strong>顶层</strong>：构建完成的镜像的最上层是你在 Dockerfile 中最后指定的内容，比如 <code>CMD</code> 或 <code>ENTRYPOINT</code>。这个层定义了容器启动时的行为。</li>
</ol>
<h4 id="Dockerfile构建过程"><a href="#Dockerfile构建过程" class="headerlink" title="Dockerfile构建过程"></a>Dockerfile构建过程</h4><p>Dockerfile 的构建过程是 Docker 为了创建镜像而执行的一系列步骤。这个过程是由 <code>docker build</code> 命令启动的，Docker 根据 Dockerfile 中定义的指令逐步创建镜像。</p>
<ol>
<li><h3 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a><strong>编写 Dockerfile</strong></h3><p>创建一个名为 Dockerfile 的文件，文件中包含你要执行的指令，例如安装软件、复制文件等。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 ubuntu:20.04 作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新包索引并安装 Python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建应用目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制应用代码到镜像中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装应用所需依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip3 install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器启动时运行的命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构建镜像</strong></p>
<p>使用 <code>docker build</code> 命令构建镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my_docker_image .</span><br><span class="line"><span class="comment"># -t my_docker_image 指定镜像的标签为 my_docker_image</span></span><br><span class="line"><span class="comment"># . 指定上下文为当前目录。</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="构建过程的详细步骤"><a href="#构建过程的详细步骤" class="headerlink" title="构建过程的详细步骤"></a>构建过程的详细步骤</h3><p>在构建过程中，Docker 按照指令执行，并将每一步的结果保存为一个镜像层（Layer）。这些步骤包括：</p>
<h4 id="3-1-解析-Dockerfile"><a href="#3-1-解析-Dockerfile" class="headerlink" title="3.1 解析 Dockerfile"></a>3.1 解析 Dockerfile</h4><p>Docker 开始解析 Dockerfile，从上到下依次处理指令。</p>
<h4 id="3-2-构建基础镜像"><a href="#3-2-构建基础镜像" class="headerlink" title="3.2 构建基础镜像"></a>3.2 构建基础镜像</h4><ul>
<li><strong>FROM</strong>：使用指定的基础镜像。在这个例子中，Docker 从 <code>ubuntu:20.04</code> 开始。</li>
<li>如果该镜像不存在于本地，Docker 会从 Docker Hub 拉取该镜像。</li>
</ul>
<h4 id="3-3-执行运行指令"><a href="#3-3-执行运行指令" class="headerlink" title="3.3 执行运行指令"></a>3.3 执行运行指令</h4><ul>
<li><strong>RUN</strong>：每次执行 RUN 指令时，Docker 会在现有镜像的基础上执行该指令，并为其创建新层。例如，执行更新仓库与安装 Python。</li>
</ul>
<p>每个 RUN 指令都会启动一个新的容器，执行该指令，并将更改保存为新镜像层。</p>
<h4 id="3-4-设置工作目录"><a href="#3-4-设置工作目录" class="headerlink" title="3.4 设置工作目录"></a>3.4 设置工作目录</h4><ul>
<li><strong>WORKDIR</strong>：设置容器内的工作目录，所有后续的指令都将在这个目录下执行。如果目录不存在，Docker 会自动创建它。</li>
</ul>
<h4 id="3-5-复制文件"><a href="#3-5-复制文件" class="headerlink" title="3.5 复制文件"></a>3.5 复制文件</h4><ul>
<li><strong>COPY</strong>：将主机文件系统中的文件复制到镜像中的工作目录中。复制过程会将源路径中的所有文件和目录复制到目标路径中。</li>
</ul>
<h4 id="3-6-安装依赖"><a href="#3-6-安装依赖" class="headerlink" title="3.6 安装依赖"></a>3.6 安装依赖</h4><p>在这个例子中，使用 <strong>RUN</strong> 指令再次安装应用程序所需的 Python 包。</p>
<h4 id="3-7-设置默认命令"><a href="#3-7-设置默认命令" class="headerlink" title="3.7 设置默认命令"></a>3.7 设置默认命令</h4><ul>
<li><strong>CMD</strong>：配置容器启动时的默认命令。当容器运行时，会执行这个命令。</li>
</ul>
</li>
<li><h3 id="镜像层的结构"><a href="#镜像层的结构" class="headerlink" title="镜像层的结构"></a>镜像层的结构</h3><p>Docker 每执行一次指令，都会生成一个新的镜像层。这些镜像层是分层文件系统的一部分，因此可以利用层的重用性来加快构建过程。每一层都只保存了自上一个层以来的数据更改。</p>
<p>例如，如果你更改了 Dockerfile 中某一步，Docker 只会重新构建那个步骤及其之后的所有步骤，而不会重建整个镜像。</p>
</li>
<li><p><strong>查看镜像</strong></p>
<p>使用 <code>docker images</code> 命令查看已构建的镜像</p>
</li>
<li><p><strong>运行容器</strong></p>
<p>使用 <code>docker run</code> 命令从生成的镜像启动一个容器。</p>
</li>
</ol>
<h4 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h4><ol>
<li><p>FROM：指定基础镜像</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>MAINTAINER: 用于指定镜像的维护者信息</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MAINTAINER</span> yourName@example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>LABEL: 为镜像添加元数据</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> version=<span class="string">&quot;1.0&quot;</span> description=<span class="string">&quot;My Sample Image&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>RUN: 为镜像构建期间执行命令。通常用来安装依赖软件包</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y python3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CMD: 指定容器启动时执行的命令。 可以被docker run 传递命令覆盖</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ENTRYPOINT: 配置容器启动时的主命令，可以与CMD配合使用</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD与 ENTRYPOINT 区别</span></span><br><span class="line">	<span class="comment"># CMD 容器启动时要运行的命令，只有最后一个会生效，可以被docker run 传递命令覆盖，可被替代</span></span><br><span class="line">	<span class="comment"># ENTRYPOINT 容器启动时要运行的命令，可以追加命令 </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>COPY: 将本地文件或目录复制到镜像中</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ADD: 类似于COPY，但支持从URL下载文件和解压归档文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> myapp.tar.gz /app</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>WORKDIR: 设置工作目录，后续的RUN，CMD，ECTRYPOINT等命令都会在这个目录下运行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>EXPOSE: 声明容器要监听的端口。该指令不实际执行任何操作，仅用于文档化</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ENV: 设置环境变量</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> APP_ENV=production</span><br></pre></td></tr></table></figure>
</li>
<li><p>VOLUME: 创建一个可供容器使用的挂载点，可以挂载数据卷</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/data&quot;</span>]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>USER: 指定在容器内运行命令时使用的用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER appuser</span><br></pre></td></tr></table></figure>
</li>
<li><p>ARG: 定义在构建时传递的变量</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> VERSION=<span class="number">1.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SHELL: 改变RUN指令所使用的默认<code> shell</code></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ONBUILD: 当构件一个被继承<code>DockerFile</code> 这个时候就会运行ONBUILE指令</p>
</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>假设，我要构建一个简单的 Python Flask 应用。这个应用将在一个 Ubuntu 基础镜像中运行，并允许用户通过访问 Flask Web 服务器来获取信息。</p>
<p><strong>项目目录</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span>-flask-app/</span><br><span class="line">│</span><br><span class="line">├── app.py</span><br><span class="line">├── requirements.txt</span><br><span class="line">└── Dockerfile</span><br></pre></td></tr></table></figure>

<p><strong>Dockerfile</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Ubuntu 作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置维护者信息</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;your_name@example.com&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统并安装 Python 和 pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y python3 python3-pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get clean &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 requirements.txt 到容器中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Python 依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip3 install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 Flask 应用的代码到容器中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.py .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开放 Flask 服务器的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> FLASK_APP=app.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器启动时运行的命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;flask&quot;</span>, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;--host=0.0.0.0&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在终端中进入到 my-flask-app 目录，然后运行以下命令来构建 Docker 镜像</span></span><br><span class="line">docker build -t my-flask-app .</span><br><span class="line"><span class="comment"># 运行容器并映射主机的 5000 端口到容器的 5000 端口</span></span><br><span class="line">docker run -d -p 5000:5000 my-flask-app</span><br></pre></td></tr></table></figure>

<p><strong>访问应用</strong></p>
<p>打开浏览器并访问 <code>http://localhost:5000/</code></p>
<h3 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h3><h4 id="网络驱动程序"><a href="#网络驱动程序" class="headerlink" title="网络驱动程序"></a>网络驱动程序</h4><p>Docker 支持多种网络驱动程序</p>
<ol>
<li><p><strong>bridge（桥接网络） - 默认</strong></p>
<ul>
<li>默认情况下，Docker 会创建一个名为 <code>bridge</code> 的网络，所有新创建的容器都会连接到这个网络。</li>
<li>每个容器都有一个虚拟的 IP 地址，通过 NAT（网络地址转换）与主机通信。</li>
<li>适用于大多数容器间通信的场景</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个默认的 bridge 网络并启动一个容器</span></span><br><span class="line">docker run -d --name my-container nginx</span><br><span class="line">docker run -d --name my-container --network bridge nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>host（主机网络）</strong></p>
<ul>
<li>容器与宿主机共享网络栈，容器内的服务将直接使用宿主机的 IP 地址及接口。</li>
<li>不适合需要隔离的场景，因为容器的网络与宿主机是完全相同的。</li>
<li>适合高性能需求的网络应用。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用主机网络模式运行一个容器</span></span><br><span class="line">docker run -d --name my-container --network host nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>overlay（叠加网络）</strong></p>
<ul>
<li>允许在多台 Docker 主机之间进行跨主机的网络通信，通常用于 Docker Swarm 集群。</li>
<li>可以将多个 Docker 主机上的容器连接到同一个虚拟网络。</li>
<li>适合微服务架构和需要跨主机通信的应用。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 overlay 网络</span></span><br><span class="line">docker network create -d overlay my-overlay-network</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>macvlan（MAC 虚拟网络）</strong></p>
<ul>
<li>为每个容器分配一个独立的 MAC 地址，容器可以直接在物理网络上通信。</li>
<li>可以将容器直接暴露到物理网络中，适合一些特殊场景。</li>
<li>需要网络管理员的支持来配置。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 macvlan 网络</span></span><br><span class="line">docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 my-macvlan</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>none（无网络）</strong></p>
<ul>
<li>容器没有网络接口，适合一些需要完全隔离的特定场景。</li>
<li>只允许容器通过内部 IPC 通信。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 none 网络模式运行一个容器</span></span><br><span class="line">docker run -d --name my-container --network none nginx</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="常用网络命令"><a href="#常用网络命令" class="headerlink" title="常用网络命令"></a>常用网络命令</h4><ol>
<li><p><strong>查看所有网络(网卡)</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看网络详细信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect &lt;network_name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建网络</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create &lt;network_name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除网络</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">rm</span> &lt;network_name&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="网络连接和通信"><a href="#网络连接和通信" class="headerlink" title="网络连接和通信"></a>网络连接和通信</h4><ul>
<li><p><strong>容器可以通过名称相互访问</strong>：在同一网络下，容器可以通过名称直接访问彼此。例如，在 Docker Compose 中，服务可以通过服务名称互相访问。</p>
</li>
<li><p><strong>端口映射</strong>：使用 <code>-p</code> 选项将主机的端口映射到容器的端口，允许外部流量访问容器服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>环境变量和 DNS</strong>：Docker 提供了内置的 DNS 服务，可以通过容器名称解析到相应的 IP 地址。</p>
</li>
<li></li>
</ul>
<h4 id="Docker-Compose-中的网络"><a href="#Docker-Compose-中的网络" class="headerlink" title="Docker Compose 中的网络"></a>Docker Compose 中的网络</h4><p>在 Docker Compose 中，可以定义服务使用的网络</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># web 和 app 服务都连接到名为 my-network 的桥接网络。这样，它们可以通过服务名称互相访问。</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-app-image</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>



<h4 id="容器互通-–link"><a href="#容器互通-–link" class="headerlink" title="容器互通 (–link)"></a>容器互通 (–link)</h4><p><code>--link</code> 是 Docker 早期版本中用于实现容器之间互通的一个参数。它提供了一个简单的方式，使一个容器能够通过指定的别名与另一个容器进行通信。尽管在某些场景中它是有用的，但由于其局限性和不够灵活，Docker 官方已经不推荐使用 <code>--link</code>，并建议使用用户自定义的网络来实现容器之间的通信。</p>
<p><strong>基本方法</strong></p>
<ol>
<li><p><strong>创建容器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis-server redis</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建另一个容器并链接到第一个容器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在创建第二个容器时，使用 --link 选项将其与 Redis 容器链接</span></span><br><span class="line">docker run -it --name redis-client --<span class="built_in">link</span> redis-server:redis redis sh</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>连接效果</strong></p>
<p>一旦容器通过 <code>--link</code> 选项连接，Docker 会在 <code>redis-client</code> 容器中自动设置相应的环境变量，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器 redis-client 可以通过环境变量直接访问 Redis 服务</span></span><br><span class="line">REDIS_PORT=tcp://172.17.0.2:6379</span><br><span class="line">REDIS_PORT_6379_TCP=tcp://172.17.0.2:6379</span><br><span class="line">REDIS_PORT_6379_TCP_PROTO=tcp</span><br><span class="line">REDIS_PORT_6379_TCP_PORT=6379</span><br><span class="line">REDIS_NAME=redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实例</strong></p>
<p>进入 <code>redis-client</code> 容器并使用 <code>redis-cli</code> 连接到 <code>redis</code> 容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h redis-server -p 6379</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><p>Docker允许用户自定义网络来连接容器，以便它们可以相互通信或连接到外部网络。通过自定义网络，用户可以在容器之间创建私有网络，以增强安全性和隔离性。</p>
<h5 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h5><p><code>docker network create</code>命令允许您在Docker中创建一个自定义网络。下面是<code>docker network create</code>命令的详细使用方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network create [OPTIONS] NETWORK</span><br><span class="line"><span class="comment"># OPTIONS是可选的参数</span></span><br><span class="line"><span class="comment"># NETWORK是您要创建的自定义网络的名称。</span></span><br></pre></td></tr></table></figure>

<p>常用的选项：</p>
<ul>
<li><code>--driver </code>：指定网络的驱动程序。默认驱动程序为<code>bridge</code>。</li>
<li><code>--subnet </code>：指定网络的子网。</li>
<li><code>--gateway </code>：指定网络的网关。</li>
<li><code>--ip-range </code>：指定可用于网络中的IP地址范围。</li>
<li><code>--internal</code>：创建一个内部网络，该网络只能被本地容器访问。</li>
<li><code>--attachable</code>：允许其他容器连接到此网络，即使未被指定为其默认网络。</li>
</ul>
<p>例如，要创建一个名为<code>my_network</code>的网络，子网为<code>172.18.0.0/16</code>，网关为<code>172.18.0.1</code>，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver=bridge --subnet=172.18.0.0/16 --gateway=172.18.0.1 my_network</span><br></pre></td></tr></table></figure>

<h5 id="运行容器并连接到自定义网络"><a href="#运行容器并连接到自定义网络" class="headerlink" title="运行容器并连接到自定义网络"></a>运行容器并连接到自定义网络</h5><p>在启动容器时，可以使用<code>--network</code>选项将容器连接到自定义网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --network &lt;network_name&gt; -d &lt;image&gt;</span><br><span class="line"><span class="comment"># &lt;network_name&gt; 是您要连接的自定义网络的名称。</span></span><br><span class="line"><span class="comment"># &lt;image&gt; 是您要运行的镜像名称。</span></span><br></pre></td></tr></table></figure>

<h5 id="断开容器与自定义网络的连接"><a href="#断开容器与自定义网络的连接" class="headerlink" title="断开容器与自定义网络的连接"></a>断开容器与自定义网络的连接</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect &lt;network_name&gt; &lt;container_name&gt;</span><br><span class="line"><span class="comment"># &lt;network_name&gt; 是要断开连接的自定义网络的名称。</span></span><br><span class="line"><span class="comment"># &lt;container_name&gt; 是要断开连接的容器的名称或容器ID。</span></span><br></pre></td></tr></table></figure>

<h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><p>只要容器连接到同一个自定义网络中，即使不使用<code>--link</code>参数，也可以通过容器名称进行通信。在自定义网络中，Docker会自动管理容器之间的DNS解析，使得容器名称可以直接用于通信。</p>
<h4 id="网络联通"><a href="#网络联通" class="headerlink" title="网络联通"></a>网络联通</h4><p>当两组不同的自定义网络或默认网络(docker0)与自定义网络下的docker容器进行连接</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/06/17/Docker%E5%AE%B9%E5%99%A8/Users\发发发宝贝\AppData\Roaming\Typora\typora-user-images\image-20250512011726932.png" alt="image-20250512011726932"></p>
<p><code>docker network connect</code>命令用于将现有容器连接到指定的网络。通过这个命令，可以实现容器在不同网络之间的快速切换和移动，便于网络配置的灵活性</p>
<ol>
<li><p><strong>将容器连接到新创建的自定义网络</strong></p>
<p>*问题**： 假设您已经创建了一个名为<code>my_network</code>的自定义网络，并且有一个正在运行的容器<code>my_container_1</code>，您想将其连接到<code>my_network</code>网络中，可以使用以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my_network my_container_1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>为连接的容器指定IP地址</strong></p>
<p>为连接的容器分配特定的IP地址，可以使用<code>--ip</code>选项。例如，将容器<code>my_container_1</code>连接到<code>my_network</code>网络并分配IP地址<code>172.18.0.20</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect --ip 172.18.0.20 my_network my_container_1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>为连接的容器指定别名</strong></p>
<p>使用<code>--alias</code>选项为容器指定别名。例如，将容器<code>my_container_1</code>连接到<code>my_network</code>网络并为其指定别名<code>webserver</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect --<span class="built_in">alias</span> webserver my_network my_container_1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看容器连接的网络</strong></p>
<p>要查看容器连接到了哪些网络，以及容器在网络中的IP地址等信息，可以使用<code>docker network inspect</code>命令。例如，查看<code>my_container_1</code>连接到的网络信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect my_network</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>原理</strong></p>
<p>在Linux系统上，Docker利用Linux的网络命名空间来实现容器的网络隔离。每个容器都运行在一个独立的网络命名空间中，这样可以保证容器之间的网络互相隔离，避免网络冲突。当容器连接到一个网络时，实际上是将容器加入到该网络命名空间，使得容器网络能够直接与该网络中的其他容器或主机进行通信。</p>
<h4 id="案例：-部署redis集群"><a href="#案例：-部署redis集群" class="headerlink" title="案例： 部署redis集群"></a>案例： 部署redis集群</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/06/17/Docker%E5%AE%B9%E5%99%A8/Users\发发发宝贝\AppData\Roaming\Typora\typora-user-images\image-20250512012739775.png" alt="image-20250512012739775"></p>
<p>部署Redis集群通常采用分片（sharding）、高可用（high availability）和负载均衡（load balancing）的方式来提供性能和可靠性。在Docker中，可以通过使用多个Redis容器和一些额外的组件来实现这些功能。下面是一个简单的示例，演示如何在Docker中部署Redis集群，包括分片、高可用和负载均衡：</p>
<ol>
<li><p>设置网络服务</p>
<ul>
<li>创建redis 网卡</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create redis --subnet 172.38.0.0/16</span><br></pre></td></tr></table></figure>

<ul>
<li>查看网卡信息&amp;网络详细信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line">docker network inspect redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Redis集群：</p>
<ul>
<li>创建6个redis.conf ，根据redis.conf 创建6个不同redis容器</li>
<li></li>
</ul>
<ul>
<li>使用Docker Compose创建一个包含多个Redis容器（例如6个容器）的集群。</li>
<li>配置每个Redis容器的端口映射，确保它们之间可以互相通信。</li>
<li>配置Redis复制和集群插件，以实现数据的复制和分片。</li>
</ul>
</li>
<li><p>使用Sentinel进行高可用性管理：</p>
<ul>
<li>在集群中添加Redis Sentinel容器，用于监控Redis主从节点的健康状态，并在主节点故障时自动切换。</li>
<li>配置Sentinel监控的Redis节点，并设置故障转移和故障恢复的策略。</li>
</ul>
</li>
<li><p>使用Nginx进行负载均衡：</p>
<ul>
<li>部署一个Nginx容器作为负载均衡器，用于将客户端请求分发给多个Redis节点。</li>
<li>配置Nginx的负载均衡策略，如轮询、IP哈希等。</li>
</ul>
</li>
</ol>
<h4 id="SprintBoot-微服务打包jar包发布docker镜像"><a href="#SprintBoot-微服务打包jar包发布docker镜像" class="headerlink" title="SprintBoot 微服务打包jar包发布docker镜像"></a>SprintBoot 微服务打包jar包发布docker镜像</h4><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>Docker Compose 是一个用于定义和运行多个 Docker 容器的工具。通过一个简单的 YAML 文件来配置应用程序的服务，然后可以使用一个命令来启动、停止和重建这些服务</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web_app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./web_app:/var/www/html</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:latest</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">example</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">web_app</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./db_data:/var/lib/mysql</span></span><br></pre></td></tr></table></figure>

<p>在这个 YAML 配置文件中，我们定义了两个服务：web_app 和 db。每个服务都包含一些配置信息，例如使用的 Docker 镜像、端口映射、环境变量、数据卷等。</p>
<p><strong>详细说明：</strong></p>
<ul>
<li><code>version: &#39;3&#39;</code>：指定 Docker Compose 配置文件的版本。</li>
<li><code>services</code>：定义应用程序的服务列表，每个服务都可以包含一些配置选项。</li>
<li><code>web_app</code>：定义了一个名为 web_app 的服务。<ul>
<li><code>image: nginx:latest</code>：指定使用的 Docker 镜像为最新版的 nginx。</li>
<li><code>ports: &quot;80:80&quot;</code>：将容器内部的 80 端口映射到宿主机的 80 端口。</li>
<li><code>volumes: &quot;./web_app:/var/www/html&quot;</code>：将宿主机当前目录下的 web_app 文件夹挂载到容器内的 &#x2F;var&#x2F;www&#x2F;html 目录。</li>
<li><code>depends_on: db</code>：指定该服务依赖于 db 服务，即在启动 web_app 之前需要先启动 db。</li>
</ul>
</li>
<li><code>db</code>：定义了一个名为 db 的服务。<ul>
<li><code>image: mysql:latest</code>：指定使用的 Docker 镜像为最新版的 mysql。</li>
<li><code>environment</code>：设置环境变量，例如 root 用户的密码和数据库名称。</li>
<li><code>volumes: &quot;./db_data:/var/lib/mysql&quot;</code>：将宿主机当前目录下的 db_data 文件夹挂载到容器内的 &#x2F;var&#x2F;lib&#x2F;mysql 目录，用于持久化数据库数据。</li>
</ul>
</li>
</ul>
<h3 id="Docker-Swarm-docker-集群管理"><a href="#Docker-Swarm-docker-集群管理" class="headerlink" title="Docker Swarm (docker 集群管理)"></a>Docker Swarm (docker 集群管理)</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>Docker Swarm 是 Docker 的集群管理工具。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机。</p>
<p>在 Docker Swarm 中，主要有三个重要的概念：</p>
<ol>
<li>Node：节点，即参与容器编排的主机，可以是物理机也可以是虚拟机。每个节点上都有一个 Docker 引擎，用于运行容器。</li>
<li>Service：服务，用于定义容器应该如何运行。一个服务可以包含多个容器实例，可以指定所需的镜像、环境变量、网络等配置。</li>
<li>Task：任务，是 Docker Swarm 中最小的工作单元，用于表示在节点上运行的一个容器实例。</li>
</ol>
<p>Docker Swarm 提供了一些核心功能，如高可用性、负载均衡、滚动更新等。用户可以通过简单的命令创建集群，部署服务，并对服务进行扩展和更新</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>swarm 集群由管理节点（manager）和工作节点（work node）构成</p>
<ul>
<li><strong>swarm mananger</strong>：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。</li>
<li><strong>work node</strong>：即图中的 available node，主要负责运行相应的服务来执行任务（task）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/06/17/Docker%E5%AE%B9%E5%99%A8/Users\发发发宝贝\AppData\Roaming\Typora\typora-user-images\image-20250513222658474.png" alt="image-20250513222658474"></p>
<h4 id="Docker-Swarm指令"><a href="#Docker-Swarm指令" class="headerlink" title="Docker Swarm指令"></a>Docker Swarm指令</h4><p>常用的 Docker Swarm 命令：</p>
<ol>
<li><p>初始化 Docker Swarm</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init</span><br><span class="line"><span class="comment"># 可以获得一个token。后续将节点加入到这个集群中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后续可以使用以下命令得到该令牌token，</span></span><br><span class="line">docker swarm join-token manager  <span class="comment"># 生成主节点令牌</span></span><br><span class="line">docker swarm join-token worker	<span class="comment"># 生成工作节点令牌</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当前docker机器加入到某个集群</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm <span class="built_in">join</span> --token &lt;token&gt; &lt;manager-ip&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 Swarm 节点列表(开启swarm的docker机器)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --replicas &lt;num-replicas&gt; --name &lt;service-name&gt; &lt;image&gt; &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出所有服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>缩放服务的实力数量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service scale &lt;service-name&gt;=&lt;num-replicas&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看某个服务的详细信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service inspect &lt;service-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看服务日志</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service logs &lt;service-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service update --image &lt;new-image&gt; &lt;service-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service <span class="built_in">rm</span> &lt;service-name&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="拓展：Raft-一致性算法"><a href="#拓展：Raft-一致性算法" class="headerlink" title="拓展：Raft 一致性算法"></a>拓展：Raft 一致性算法</h4><p>在Docker Swarm中，Raft一致性算法用于实现集群管理的决策一致性和问题解决。在一个Docker Swarm集群中，每个主节点都有一个Raft组件，用来实现领导者选举、日志复制等功能。Raft算法能够确保集群中的所有主节点都拥有相同的状态和数据，保证了集群的一致性。</p>
<p>Docker Swarm中Raft一致性算法的应用包括以下几个方面：</p>
<ol>
<li>领导者选举：当一个主节点需要进行某项操作时（比如启动一个服务），Raft算法会通过领导者选举机制选出一个领导者节点来负责进行这个操作，其他主节点则成为追随者节点。</li>
<li>日志复制：领导者节点会将自己的操作日志发送给追随者节点，一旦大多数节点都复制了相同的日志，就能够保证操作的一致性，避免数据丢失。</li>
<li>容错性：Raft一致性算法能够容忍主节点的故障或者网络分区等问题，通过选举机制重新选举领导者节点，保证集群的正常运行。</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/28/python-%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E3%80%81%E5%AD%97%E5%85%B8%E6%8E%A8%E5%AF%BC%E4%B8%8E%E9%9B%86%E5%90%88%E6%8E%A8%E5%AF%BC/" title="Python-列表推导、字典推导与集合推导"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tse2-mm.cn.bing.net/th/id/OIP-C.dSMliGMR1gP-nfkwknp26QHaDt?w=314&amp;h=175&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python-列表推导、字典推导与集合推导</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/28/python3.8-python%E6%B5%B7%E8%B1%A1%E8%BF%90%E7%AE%97%E7%AC%A6/" title="python3.8-Python海象运算符"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tse2-mm.cn.bing.net/th/id/OIP-C.dSMliGMR1gP-nfkwknp26QHaDt?w=314&amp;h=175&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">python3.8-Python海象运算符</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/fafafa.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">fafafa</div><div class="author-info__description">记录笔记日志</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">50</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/fafafabaobei@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker"><span class="toc-number">1.</span> <span class="toc-text">Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">分层存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%93%E5%BA%93"><span class="toc-number">1.1.4.</span> <span class="toc-text">仓库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ubuntu-%E5%AE%89%E8%A3%85-Docker"><span class="toc-number">1.2.1.</span> <span class="toc-text">Ubuntu 安装 Docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MacOS"><span class="toc-number">1.2.2.</span> <span class="toc-text">MacOS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows-10-11"><span class="toc-number">1.2.3.</span> <span class="toc-text">Windows 10&#x2F;11</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">镜像使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">获取镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">使用镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E9%95%9C%E5%83%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">列出镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.</span> <span class="toc-text">Docker容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-run-Hello-word"><span class="toc-number">1.4.1.</span> <span class="toc-text">docker run Hello-word</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-run-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">docker run 执行流程(工作流程)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.</span> <span class="toc-text">Docker 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">1.5.3.</span> <span class="toc-text">可视化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E9%95%9C%E5%83%8F%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">Docker 镜像原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.6.1.</span> <span class="toc-text">镜像是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UnionFS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.2.</span> <span class="toc-text">UnionFS的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E9%95%9C%E5%83%8F%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.3.</span> <span class="toc-text">Docker 镜像的加载原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E5%88%86%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.4.</span> <span class="toc-text">Docker 分层原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%95%9C%E5%83%8F-commit-%E9%95%9C%E5%83%8F"><span class="toc-number">1.6.5.</span> <span class="toc-text">如何提交一个自己的镜像 - commit 镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">1.7.</span> <span class="toc-text">容器数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">1.7.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.7.2.</span> <span class="toc-text">数据卷的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.7.3.</span> <span class="toc-text">数据卷的种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.7.4.</span> <span class="toc-text">数据卷的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">挂载数据卷</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E6%8C%82%E8%BD%BD-%E5%8C%BF%E5%90%8D%E6%8C%82%E8%BD%BD-%E6%8C%87%E5%AE%9A%E8%B7%AF%E5%BE%84%E6%8C%82%E8%BD%BD"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">具名挂载&amp;匿名挂载&amp;指定路径挂载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">拓展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-number">1.8.</span> <span class="toc-text">数据卷容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile"><span class="toc-number">1.9.</span> <span class="toc-text">Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.9.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E9%95%9C%E5%83%8F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.2.</span> <span class="toc-text">Docker 镜像的层次结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.9.3.</span> <span class="toc-text">Dockerfile构建过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99-Dockerfile"><span class="toc-number">1.10.</span> <span class="toc-text">编写 Dockerfile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.11.</span> <span class="toc-text">构建过程的详细步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E8%A7%A3%E6%9E%90-Dockerfile"><span class="toc-number">1.11.1.</span> <span class="toc-text">3.1 解析 Dockerfile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F"><span class="toc-number">1.11.2.</span> <span class="toc-text">3.2 构建基础镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%89%A7%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A4"><span class="toc-number">1.11.3.</span> <span class="toc-text">3.3 执行运行指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="toc-number">1.11.4.</span> <span class="toc-text">3.4 设置工作目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">1.11.5.</span> <span class="toc-text">3.5 复制文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96"><span class="toc-number">1.11.6.</span> <span class="toc-text">3.6 安装依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%91%BD%E4%BB%A4"><span class="toc-number">1.11.7.</span> <span class="toc-text">3.7 设置默认命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%B1%82%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.12.</span> <span class="toc-text">镜像层的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.12.1.</span> <span class="toc-text">Dockerfile 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.12.2.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E7%BD%91%E7%BB%9C"><span class="toc-number">1.13.</span> <span class="toc-text">Docker 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.13.1.</span> <span class="toc-text">网络驱动程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">1.13.2.</span> <span class="toc-text">常用网络命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%92%8C%E9%80%9A%E4%BF%A1"><span class="toc-number">1.13.3.</span> <span class="toc-text">网络连接和通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Compose-%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C"><span class="toc-number">1.13.4.</span> <span class="toc-text">Docker Compose 中的网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%BA%92%E9%80%9A-%E2%80%93link"><span class="toc-number">1.13.5.</span> <span class="toc-text">容器互通 (–link)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-number">1.13.6.</span> <span class="toc-text">自定义网络</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.13.6.1.</span> <span class="toc-text">创建网络</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E5%B9%B6%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-number">1.13.6.2.</span> <span class="toc-text">运行容器并连接到自定义网络</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%AD%E5%BC%80%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.13.6.3.</span> <span class="toc-text">断开容器与自定义网络的连接</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.13.6.3.1.</span> <span class="toc-text">其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%81%94%E9%80%9A"><span class="toc-number">1.13.7.</span> <span class="toc-text">网络联通</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A-%E9%83%A8%E7%BD%B2redis%E9%9B%86%E7%BE%A4"><span class="toc-number">1.13.8.</span> <span class="toc-text">案例： 部署redis集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SprintBoot-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%93%E5%8C%85jar%E5%8C%85%E5%8F%91%E5%B8%83docker%E9%95%9C%E5%83%8F"><span class="toc-number">1.13.9.</span> <span class="toc-text">SprintBoot 微服务打包jar包发布docker镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Compose"><span class="toc-number">1.14.</span> <span class="toc-text">Docker Compose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Swarm-docker-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86"><span class="toc-number">1.15.</span> <span class="toc-text">Docker Swarm (docker 集群管理)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">1.15.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.15.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Swarm%E6%8C%87%E4%BB%A4"><span class="toc-number">1.15.3.</span> <span class="toc-text">Docker Swarm指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%EF%BC%9ARaft-%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95"><span class="toc-number">1.15.4.</span> <span class="toc-text">拓展：Raft 一致性算法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/17/yaml%E9%AB%98%E9%98%B6%E8%AF%AD%E6%B3%95/" title="Yaml高阶语法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Yaml高阶语法"/></a><div class="content"><a class="title" href="/2025/04/17/yaml%E9%AB%98%E9%98%B6%E8%AF%AD%E6%B3%95/" title="Yaml高阶语法">Yaml高阶语法</a><time datetime="2025-04-16T17:04:52.000Z" title="发表于 2025-04-17 01:04:52">2025-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/14/SQLite/" title="SQLite"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SQLite"/></a><div class="content"><a class="title" href="/2025/01/14/SQLite/" title="SQLite">SQLite</a><time datetime="2025-01-13T16:52:36.000Z" title="发表于 2025-01-14 00:52:36">2025-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/29/xpath%E8%AF%AD%E6%B3%95/" title="Xpath语法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Xpath语法"/></a><div class="content"><a class="title" href="/2024/09/29/xpath%E8%AF%AD%E6%B3%95/" title="Xpath语法">Xpath语法</a><time datetime="2024-09-29T15:57:28.000Z" title="发表于 2024-09-29 23:57:28">2024-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/playwright%E6%A1%86%E6%9E%B6/" title="Playwright框架"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Playwright框架"/></a><div class="content"><a class="title" href="/2024/09/26/playwright%E6%A1%86%E6%9E%B6/" title="Playwright框架">Playwright框架</a><time datetime="2024-09-26T14:29:59.000Z" title="发表于 2024-09-26 22:29:59">2024-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/24/Django/" title="Django"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Django"/></a><div class="content"><a class="title" href="/2024/09/24/Django/" title="Django">Django</a><time datetime="2024-09-23T16:49:13.000Z" title="发表于 2024-09-24 00:49:13">2024-09-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://tse1-mm.cn.bing.net/th/id/OIP-C.dEgEQ0JBlwn323Q_i0spsgHaEK?w=294&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By fafafa</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.0.5/dist/lazyload.iife.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.innerHTML = `<pre class="mermaid-src" hidden>${ele.textContent}</pre>`
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.14.0-b3"></script></div></div></body></html>