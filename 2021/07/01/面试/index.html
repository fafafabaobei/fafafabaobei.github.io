<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试 | fafafabaobei</title><meta name="author" content="fafafa"><meta name="copyright" content="fafafa"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="有关小程序中uni-app框架常见面试题uniapp进行条件编译的两种方法12&#x2F;&#x2F; 通过 #ifdef、#ifndef 的方式H5：    uniapp 上传文件API12345678uni.uploadFile(&#123;    url: &#x27;https:&#x2F;&#x2F;&#x27;,    fileType:&#x27;image&#x27;,    filePath:&#x27;路径&amp;#x27">
<meta property="og:type" content="article">
<meta property="og:title" content="面试">
<meta property="og:url" content="https://fafafabaobei.github.io/2021/07/01/%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="fafafabaobei">
<meta property="og:description" content="有关小程序中uni-app框架常见面试题uniapp进行条件编译的两种方法12&#x2F;&#x2F; 通过 #ifdef、#ifndef 的方式H5：    uniapp 上传文件API12345678uni.uploadFile(&#123;    url: &#x27;https:&#x2F;&#x2F;&#x27;,    fileType:&#x27;image&#x27;,    filePath:&#x27;路径&amp;#x27">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2021-07-01T11:47:04.000Z">
<meta property="article:modified_time" content="2021-07-01T11:47:04.000Z">
<meta property="article:author" content="fafafa">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/blog.png"><link rel="canonical" href="https://fafafabaobei.github.io/2021/07/01/%E9%9D%A2%E8%AF%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-01 19:47:04'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    btf.addGlobalFn('pjaxSend', () => { preloader.initLoading() }, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', () => { preloader.endLoading() }, 'preloader_end')
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/fafafa.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="fafafabaobei"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/blog.png" alt="Logo"/><span class="site-name">fafafabaobei</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">面试<a class="post-edit-link" href="null_posts/面试.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-01T11:47:04.000Z" title="发表于 2021-07-01 19:47:04">2021-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-01T11:47:04.000Z" title="更新于 2021-07-01 19:47:04">2021-07-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">44.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>152分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="有关小程序中uni-app框架常见面试题"><a href="#有关小程序中uni-app框架常见面试题" class="headerlink" title="有关小程序中uni-app框架常见面试题"></a>有关小程序中uni-app框架常见面试题</h3><h4 id="uniapp进行条件编译的两种方法"><a href="#uniapp进行条件编译的两种方法" class="headerlink" title="uniapp进行条件编译的两种方法"></a>uniapp进行条件编译的两种方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过 #ifdef、#ifndef 的方式</span><br><span class="line">H5：</span><br></pre></td></tr></table></figure>



<h4 id="uniapp-上传文件API"><a href="#uniapp-上传文件API" class="headerlink" title="uniapp 上传文件API"></a>uniapp 上传文件API</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uni.<span class="title function_">uploadFile</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;https://&#x27;</span>,</span><br><span class="line">    <span class="attr">fileType</span>:<span class="string">&#x27;image&#x27;</span>,</span><br><span class="line">    <span class="attr">filePath</span>:<span class="string">&#x27;路径&#x27;</span></span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="监听页面滚动"><a href="#监听页面滚动" class="headerlink" title="监听页面滚动"></a>监听页面滚动</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uni.<span class="title function_">onPageScroll</span>()</span><br></pre></td></tr></table></figure>



<h4 id="如何让图片宽度不变，高度自动变化，保持原图宽高不变"><a href="#如何让图片宽度不变，高度自动变化，保持原图宽高不变" class="headerlink" title="如何让图片宽度不变，高度自动变化，保持原图宽高不变"></a>如何让图片宽度不变，高度自动变化，保持原图宽高不变</h4><p>给image 标签添加 mode&#x3D;‘widthFix’</p>
<h4 id="jquery，vue，小程序，uniapp本地数据存储"><a href="#jquery，vue，小程序，uniapp本地数据存储" class="headerlink" title="jquery，vue，小程序，uniapp本地数据存储"></a>jquery，vue，小程序，uniapp本地数据存储</h4><p><strong>jquery</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存： $.cookie(&#x27;key&#x27;, &#x27;value&#x27;)</span><br><span class="line">取： $.cookie(&#x27;key&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>vue</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存：localStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;)</span><br><span class="line">取：localStorage.getItem(&#x27;key&#x27;)</span><br></pre></td></tr></table></figure>

<p>wx小程序</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存：wx.setStorage / wx.setStorageSync</span><br><span class="line">取：wx.getStorage / wx.getStorageSync</span><br></pre></td></tr></table></figure>

<p>uniapp</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存：uni.setStorage(&#123;key:&quot;属性名&quot;, data:&quot;值&quot;&#125;)</span><br><span class="line">取：uni.getStorage(&#123;key:&quot;属性名&quot;&#125;)</span><br></pre></td></tr></table></figure>





<h4 id="uniApp中如何进行页面跳转？"><a href="#uniApp中如何进行页面跳转？" class="headerlink" title="uniApp中如何进行页面跳转？"></a>uniApp中如何进行页面跳转？</h4><ul>
<li>使用 <code>uni.navigateTo</code> 进行普通页面跳转：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uni.navigateTo(&#123;  </span><br><span class="line">  url: &#x27;pages/newPage/newPage&#x27;  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>uni.redirectTo</code> 进行页面重定向（替换当前页面）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uni.redirectTo(&#123;  </span><br><span class="line">  url: &#x27;pages/newPage/newPage&#x27;  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>uni.switchTab</code> 进行 Tab 切换：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uni.switchTab(&#123;  </span><br><span class="line">  url: &#x27;pages/tabBar/tabBar&#x27;  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>uni.reLaunch</code> 关闭所有页面并打开到应用内的某个页面：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uni.reLaunch(&#123;  </span><br><span class="line">  url: &#x27;pages/index/index&#x27;  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何进行数据缓存？"><a href="#uniApp中如何进行数据缓存？" class="headerlink" title="uniApp中如何进行数据缓存？"></a>uniApp中如何进行数据缓存？</h4><blockquote>
<p>小程序没有cookie</p>
</blockquote>
<ul>
<li>使用 <code>uni.setStorageSync</code> 将数据存储到本地缓存中：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 存储数据  </span><br><span class="line">uni.setStorageSync(&#x27;key&#x27;, &#x27;value&#x27;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>uni.getStorageSync</code> 从本地缓存中获取数据：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取数据  </span><br><span class="line">let data = uni.getStorageSync(&#x27;key&#x27;);  </span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何实现下拉刷新和上拉加载更多？"><a href="#uniApp中如何实现下拉刷新和上拉加载更多？" class="headerlink" title="uniApp中如何实现下拉刷新和上拉加载更多？"></a>uniApp中如何实现下拉刷新和上拉加载更多？</h4><ul>
<li>实现下拉刷新功能：</li>
</ul>
<p>在需要实现下拉刷新的页面中，添加 <code>onPullDownRefresh</code> 方法，并在该方法中编写下拉刷新的逻辑代码。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;  </span><br><span class="line">  onPullDownRefresh() &#123;  </span><br><span class="line">    // 下拉刷新逻辑代码  </span><br><span class="line">    console.log(&#x27;下拉刷新&#x27;);  </span><br><span class="line">    // 停止下拉刷新动画  </span><br><span class="line">    uni.stopPullDownRefresh();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们在 <code>onPullDownRefresh</code> 方法中编写了下拉刷新的逻辑代码，并使用 <code>uni.stopPullDownRefresh()</code> 方法停止下拉刷新动画。</p>
<ul>
<li>实现上拉加载更多功能：</li>
</ul>
<p>在需要实现上拉加载更多的页面中，添加 <code>onReachBottom</code> 方法，并在该方法中编写上拉加载更多的逻辑代码。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;  </span><br><span class="line">  onReachBottom() &#123;  </span><br><span class="line">    // 上拉加载更多逻辑代码  </span><br><span class="line">    console.log(&#x27;上拉加载更多&#x27;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>需要注意的是，为了实现上拉加载更多功能，你需要在页面中添加一个 <code>scroll-view</code> 组件，并在该组件上绑定 <code>scrolltolower</code> 事件。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;scroll-view scroll-y=&quot;true&quot; style=&quot;height: 100%;&quot; @scrolltolower=&quot;onReachBottom&quot;&gt;  </span><br><span class="line">  &lt;!-- 页面内容 --&gt;  </span><br><span class="line">&lt;/scroll-view&gt;  </span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何获取用户地理位置信息？"><a href="#uniApp中如何获取用户地理位置信息？" class="headerlink" title="uniApp中如何获取用户地理位置信息？"></a>uniApp中如何获取用户地理位置信息？</h4><ul>
<li>使用uni.getLocation</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uni.getLocation(&#123;  </span><br><span class="line">  type: &#x27;gcj02&#x27;, // 返回坐标类型  </span><br><span class="line">  altitude: true, // 是否返回高度信息  </span><br><span class="line">  success: function (res) &#123;  </span><br><span class="line">    console.log(&#x27;当前位置的经度：&#x27; + res.longitude);  </span><br><span class="line">    console.log(&#x27;当前位置的纬度：&#x27; + res.latitude);  </span><br><span class="line">    console.log(&#x27;当前位置的海拔：&#x27; + res.altitude);  </span><br><span class="line">  &#125;,  </span><br><span class="line">  fail: function (error) &#123;  </span><br><span class="line">    console.log(&#x27;获取地理位置失败：&#x27; + error.message);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何获取设备信息？"><a href="#uniApp中如何获取设备信息？" class="headerlink" title="uniApp中如何获取设备信息？"></a>uniApp中如何获取设备信息？</h4><ul>
<li>使用uni.getSystemInfo</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uni.getSystemInfo(&#123;  </span><br><span class="line"> success: function (res) &#123;  </span><br><span class="line"> console.log(&#x27;设备型号：&#x27; + res.model);  </span><br><span class="line"> console.log(&#x27;设备像素比：&#x27; + res.pixelRatio);  </span><br><span class="line"> console.log(&#x27;屏幕宽度：&#x27; + res.windowWidth);  </span><br><span class="line"> console.log(&#x27;屏幕高度：&#x27; + res.windowHeight);  </span><br><span class="line"> // 其他设备信息...  </span><br><span class="line"> &#125;,  </span><br><span class="line"> fail: function (error) &#123;  </span><br><span class="line"> console.log(&#x27;获取设备信息失败：&#x27; + error.message);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何实现表单的提交和验证？"><a href="#uniApp中如何实现表单的提交和验证？" class="headerlink" title="uniApp中如何实现表单的提交和验证？"></a>uniApp中如何实现表单的提交和验证？</h4><ul>
<li>可以通过<code>&lt;form&gt;</code>表单标签和<code>&lt;input&gt;</code>标签来实现表单的提交和验证</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;view&gt;  </span><br><span class="line">    &lt;form @submit=&quot;submitForm&quot;&gt;  </span><br><span class="line">      &lt;input v-model=&quot;formData.username&quot; type=&quot;text&quot; placeholder=&quot;用户名&quot; /&gt;  </span><br><span class="line">      &lt;input v-model=&quot;formData.password&quot; type=&quot;password&quot; placeholder=&quot;密码&quot; /&gt;  </span><br><span class="line">      &lt;button formType=&quot;submit&quot;&gt;提交&lt;/button&gt;  </span><br><span class="line">    &lt;/form&gt;  </span><br><span class="line">  &lt;/view&gt;  </span><br><span class="line">&lt;/template&gt;  </span><br><span class="line"></span><br><span class="line">&lt;script&gt;  </span><br><span class="line">export default &#123;  </span><br><span class="line">  data() &#123;  </span><br><span class="line">    return &#123;  </span><br><span class="line">      formData: &#123;  </span><br><span class="line">        username: &#x27;&#x27;,  </span><br><span class="line">        password: &#x27;&#x27;  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  methods &#123;  </span><br><span class="line">    submitForm(e) &#123;  </span><br><span class="line">      e.mp.preventDefault(); // 阻止默认行为  </span><br><span class="line">      // 进行表单验证逻辑，并处理提交操作  </span><br><span class="line">      // 可以在这里编写验证逻辑，例如检查用户名和密码是否符合规则等  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何实现页面的登录授权？"><a href="#uniApp中如何实现页面的登录授权？" class="headerlink" title="uniApp中如何实现页面的登录授权？"></a>uniApp中如何实现页面的登录授权？</h4><ul>
<li><strong>用户登录页面设计</strong>：首先需要设计一个用户登录页面，包括输入用户名、密码等登录信息的表单元素。</li>
<li><strong>登录逻辑处理</strong>：在uniApp中，你可以通过调用后端接口来进行用户登录验证。一般情况下，用户在登录页面输入用户名和密码后，通过点击登录按钮触发相应的登录方法。</li>
<li><strong>登录状态管理</strong>：一旦用户成功登录，通常会将用户的登录状态保存在本地，比如使用 <code>uni.setStorageSync</code> 方法将用户信息存储在本地缓存中。</li>
<li><strong>权限控制</strong>：在需要授权的页面或操作中，可以通过判断用户的登录状态来确定是否具有权限进行相关操作。如果用户未登录或登录状态过期，则可以跳转至登录页面进行重新登录。</li>
</ul>
<h4 id="uniApp中如何实现页面的分享到朋友圈功能？"><a href="#uniApp中如何实现页面的分享到朋友圈功能？" class="headerlink" title="uniApp中如何实现页面的分享到朋友圈功能？"></a>uniApp中如何实现页面的分享到朋友圈功能？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">shareToTimeline</span>(<span class="params"></span>) &#123;  </span><br><span class="line"> uni.<span class="title function_">share</span>(&#123;  </span><br><span class="line">  <span class="attr">provider</span>: <span class="string">&#x27;weixin&#x27;</span>,  </span><br><span class="line">  <span class="attr">scene</span>: <span class="string">&#x27;WXSenceTimeline&#x27;</span>, <span class="comment">// 表示分享到朋友圈  </span></span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;image&#x27;</span>,  </span><br><span class="line">  <span class="attr">imageUrl</span>: <span class="string">&#x27;/static/share-image.jpg&#x27;</span>, <span class="comment">// 分享的图片地址，需替换为真实图片地址  </span></span><br><span class="line">  <span class="title function_">success</span>(<span class="params">res</span>) &#123;  </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;分享成功&#x27;</span>);  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="title function_">fail</span>(<span class="params">err</span>) &#123;  </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;分享失败&#x27;</span>, err);  </span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;);  </span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何实现图片预览功能？"><a href="#uniApp中如何实现图片预览功能？" class="headerlink" title="uniApp中如何实现图片预览功能？"></a>uniApp中如何实现图片预览功能？</h4><ul>
<li>可以使用 <code>uni.previewImage</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;image src=&quot;/static/image.jpg&quot; @click=&quot;previewImage&quot; /&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;  </span><br><span class="line">export default &#123;  </span><br><span class="line">  methods: &#123;  </span><br><span class="line">    previewImage() &#123;  </span><br><span class="line">      uni.previewImage(&#123;  </span><br><span class="line">        urls: [&#x27;/static/image.jpg&#x27;], // 需要预览的图片链接列表，可以是本地路径或网络路径  </span><br><span class="line">        current: &#x27;/static/image.jpg&#x27;, // 当前显示的图片链接，可选  </span><br><span class="line">        success() &#123;  </span><br><span class="line">          console.log(&#x27;预览图片成功&#x27;);  </span><br><span class="line">        &#125;,  </span><br><span class="line">        fail(err) &#123;  </span><br><span class="line">          console.log(&#x27;预览图片失败&#x27;, err);  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何实现页面间的数据传递"><a href="#uniApp中如何实现页面间的数据传递" class="headerlink" title="uniApp中如何实现页面间的数据传递"></a>uniApp中如何实现页面间的数据传递</h4><p>在uniApp中，你可以通过多种方式实现页面间的数据传递，以下是一些常用的方法：   </p>
<ul>
<li><strong>使用URL参数传递数据</strong>：在跳转页面时，可以通过URL参数将数据传递给目标页面。在源页面使用<code>uni.navigateTo</code>或<code>uni.redirectTo</code>等跳转方法时，可以在URL中携带参数，在目标页面通过<code>this.$route.query</code>或<code>this.$mp.query</code>来获取参数。   </li>
<li><strong>使用全局变量</strong>：可以在<code>App.vue</code>中定义全局变量，然后在各个页面中通过<code>this.$store.state.xxx</code>来访问和修改全局变量的数值。   </li>
<li><strong>使用Vuex状态管理</strong>：如果应用较为复杂，推荐使用Vuex进行状态管理。在需要传递数据的页面中，通过提交mutation或dispatch action的方式来改变状态，在目标页面通过计算属性或getter来获取状态。 </li>
<li>. <strong>使用本地缓存</strong>：可以使用<code>uni.setStorageSync</code>和<code>uni.getStorageSync</code>等方法将数据存储在本地缓存中，在不同页面中读取和修改这些数据</li>
<li><strong>事件总线（Event Bus）</strong>：创建一个Vue实例作为事件总线，通过该实例的emit和on方法来实现不同组件间的通信。</li>
</ul>
<h4 id="在uniApp中，页面的生命周期包括应用生命周期和页面生命周期。"><a href="#在uniApp中，页面的生命周期包括应用生命周期和页面生命周期。" class="headerlink" title="在uniApp中，页面的生命周期包括应用生命周期和页面生命周期。"></a>在uniApp中，页面的生命周期包括应用生命周期和页面生命周期。</h4><ul>
<li><p><strong>应用生命周期</strong>：  </p>
<ul>
<li>. <code>onLaunch</code>：应用初始化时触发，全局只触发一次。</li>
<li>. <code>onShow</code>：应用启动、从后台进入前台或重新进入应用时触发</li>
<li>. <code>onHide</code>：应用从前台进入后台时触发</li>
<li>. <code>onError</code>：应用发生脚本错误或 API 调用失败时触发</li>
<li>. <code>onUniNViewMessage</code>：监听来自原生 页面发送到 uni-page 的消息。</li>
</ul>
</li>
<li><p><strong>页面生命周期</strong>：</p>
</li>
<li><p>. <code>onLoad</code>：页面加载时触发</p>
</li>
<li><p>. <code>onShow</code>：页面显示&#x2F;切入前台时触发</p>
</li>
<li><p>. <code>onReady</code>：页面初次渲染完成时触发</p>
</li>
<li><p><code>onHide</code>：页面隐藏&#x2F;切入后台时触发</p>
</li>
<li><p><code>onUnload</code>：页面卸载时触发</p>
</li>
<li><p><code>onPullDownRefresh</code>：下拉时触发</p>
</li>
<li><p>. <code>onReachBottom</code>：上拉触底触发</p>
</li>
<li><p>. <code>onShareAppMessage</code>：用户点击转发时触发</p>
</li>
<li><p>. <code>onPageScroll</code>：页面滚动时触发</p>
</li>
<li><p>. <code>onResize</code>：页面尺寸改变时触发。</p>
</li>
</ul>
<h4 id="实现微信登录-uni-getUserProfile-uni-login"><a href="#实现微信登录-uni-getUserProfile-uni-login" class="headerlink" title="实现微信登录 - uni.getUserProfile() &#x2F; uni.login()"></a>实现微信登录 - uni.getUserProfile() &#x2F; uni.login()</h4><ul>
<li><strong>引入uni-app的登录插件</strong>：uni-app提供了一个名为<code>uni-login</code>的插件，可以方便地实现微信登录功能。你可以在uni-app的插件市场中搜索并安装该插件。</li>
<li><strong>配置插件参数</strong>：在插件安装完成后，你需要在<code>manifest.json</code>文件中配置插件的参数。将微信开放平台注册的AppID填入<code>uni-login</code>插件的配置中。</li>
<li><strong>调用登录方法</strong>：在需要进行微信登录的页面中，你可以调用<code>uni.login</code>方法来触发微信登录操作。该方法会返回一个包含登录凭证的对象。</li>
<li><strong>获取用户信息</strong>：登录成功后，你可以使用<code>uni.getUserInfo</code>方法来获取用户的基本信息，如昵称、头像等。该方法也会返回一个包含用户信息的对象。</li>
<li><strong>处理登录回调</strong>：在登录成功后，你可以将登录凭证发送到后端服务器进行验证，并根据验证结果进行相应的操作，如保存用户信息、跳转到主页等。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uni.<span class="title function_">login</span>(&#123;  </span><br><span class="line">        <span class="attr">provider</span>: <span class="string">&#x27;weixin&#x27;</span>,  </span><br><span class="line">        <span class="title function_">success</span>(<span class="params">res</span>) &#123;  </span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登录凭证：&#x27;</span>, res.<span class="property">code</span>);  </span><br><span class="line">          <span class="comment">// 将登录凭证发送到后端服务器进行验证  </span></span><br><span class="line">          <span class="comment">// 处理登录回调  </span></span><br><span class="line">        &#125;,  </span><br><span class="line">        <span class="title function_">fail</span>(<span class="params">err</span>) &#123;  </span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登录失败&#x27;</span>, err);  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;);  </span><br></pre></td></tr></table></figure>



<h4 id="button-open-type-属性"><a href="#button-open-type-属性" class="headerlink" title="button open-type 属性"></a>button open-type 属性</h4><p>在uniApp中，<code>button</code>组件的<code>open-type</code>属性用于指定按钮的开放类型，决定了按钮的行为。常用的<code>open-type</code>属性值包括：  </p>
<ul>
<li><code>getUserInfo</code>：触发获取用户信息的行为，用户点击按钮后会弹出授权询问框，询问用户是否授权小程序获取用户信息。   </li>
<li><code>getPhoneNumber</code>：触发获取用户手机号的行为，用户点击按钮后会弹出授权询问框，询问用户是否授权小程序获取用户手机号。   </li>
<li><code>contact</code>：触发客服消息会话，打开客服会话界面。</li>
<li><code>share</code>：触发小程序分享功能，打开分享界面。</li>
<li><code>launchApp</code>：打开APP内部页面或小程序。</li>
</ul>
<h4 id="小程序支付和h5支付有什么区别"><a href="#小程序支付和h5支付有什么区别" class="headerlink" title="小程序支付和h5支付有什么区别"></a>小程序支付和h5支付有什么区别</h4><ul>
<li><strong>小程序支付</strong>：小程序支付是指在微信小程序中进行的支付操作。开发者可以通过调用微信提供的 <code>wx.requestPayment</code> 接口来实现在小程序内进行支付。对于小程序支付，通常需要使用微信提供的商户号和证书来进行交易。</li>
<li><strong>H5 支付</strong>：H5 支付是指在移动浏览器中进行的网页端支付操作。H5 支付通常使用传统的网页形式接入各个第三方平台（如微信、支付宝等）提供的接口，用户通过浏览器完成整个交易过程。</li>
</ul>
<h4 id="uniapp-request-封装"><a href="#uniapp-request-封装" class="headerlink" title="uniapp request 封装"></a>uniapp request 封装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">	<span class="comment">// 在类初始化上加上baseUrl属性, 添加请求根路径</span></span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">baseUrl</span> = <span class="string">&#x27;http://159.75.169.224:7300/pz&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取用户信息</span></span><br><span class="line">	<span class="title function_">getUserInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">// 调用登录api</span></span><br><span class="line">		uni.<span class="title function_">login</span>(&#123;</span><br><span class="line">			<span class="attr">success</span>: <span class="function">(<span class="params">res</span>)=&gt;</span> &#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">				<span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">					<span class="attr">url</span>: <span class="string">&#x27;/auth/wxLogin&#x27;</span>,</span><br><span class="line">					<span class="attr">data</span>: &#123;</span><br><span class="line">						<span class="attr">code</span>: res.<span class="property">code</span></span><br><span class="line">					&#125;,</span><br><span class="line">					<span class="attr">success</span>: <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">						<span class="comment">// console.log(&#x27;login_success_res&#x27;,res)</span></span><br><span class="line">					&#125;,</span><br><span class="line">					<span class="attr">fail</span>: <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">						<span class="comment">// console.log(&#x27;login_fail_res&#x27;,res)</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 请求封装</span></span><br><span class="line">	<span class="title function_">request</span>(<span class="params">option=&#123;</span></span><br><span class="line"><span class="params">		showLoading: <span class="literal">false</span></span></span><br><span class="line"><span class="params">	&#125;</span>)&#123;</span><br><span class="line">		<span class="comment">// 判断是否有url</span></span><br><span class="line">		<span class="keyword">if</span>(!option.<span class="property">url</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(option.<span class="property">showLoading</span>)&#123;</span><br><span class="line">			<span class="title function_">showLoading</span>()</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		uni.<span class="title function_">request</span>(&#123;</span><br><span class="line">			<span class="attr">url</span>: <span class="variable language_">this</span>.<span class="property">baseUrl</span> + option.<span class="property">url</span>,</span><br><span class="line">			<span class="comment">// https://apifox.com/apidoc/shared-50a14ca5-c1d1-47ca-99f0-315ecfa52706</span></span><br><span class="line">			<span class="comment">// http://159.75.169.224:7300/pz</span></span><br><span class="line">			<span class="comment">// option.data参数由外部传入</span></span><br><span class="line">			<span class="attr">data</span>: option.<span class="property">data</span> ? option.<span class="property">data</span> : &#123;&#125;,</span><br><span class="line">			<span class="attr">header</span>: option.<span class="property">header</span> ? option.<span class="property">header</span> : &#123;&#125;,</span><br><span class="line">			<span class="attr">method</span>: option.<span class="property">method</span> ? option.<span class="property">method</span> : <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">			<span class="comment">// 请求接口成功处理</span></span><br><span class="line">			<span class="attr">success</span>:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">				uni.<span class="title function_">hideLoading</span>()</span><br><span class="line">				<span class="comment">// 后端返回异常</span></span><br><span class="line">				<span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">code</span> != <span class="number">10000</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>(option.<span class="property">fail</span> &amp;&amp; <span class="keyword">typeof</span> option.<span class="property">fail</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">						option.<span class="title function_">fail</span>(res.<span class="property">data</span>)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">if</span>(option.<span class="property">success</span> &amp;&amp; <span class="keyword">typeof</span> option.<span class="property">success</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">						option.<span class="title function_">success</span>(res.<span class="property">data</span>)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="comment">// 失败处理</span></span><br><span class="line">			<span class="attr">fail</span>:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">				uni.<span class="title function_">hideLoading</span>()</span><br><span class="line">				option.<span class="title function_">fail</span>(res.<span class="property">data</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 接口请求前添加loading效果,不能放在接口请求中，防止有接口并发，添加多个loading，单独封装，loading有仅只有一个loading效果</span></span><br><span class="line">	<span class="title function_">showLoading</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="comment">// 将状态记录缓存</span></span><br><span class="line">		<span class="keyword">const</span> isShowLoading = uni.<span class="title function_">getStorageSync</span>(<span class="string">&#x27;isShowLoading&#x27;</span>)</span><br><span class="line">		<span class="comment">// 让loading有仅只有一个loading效果</span></span><br><span class="line">		<span class="keyword">if</span>(isShowLoading)&#123;</span><br><span class="line">			uni.<span class="title function_">hideLoading</span>()</span><br><span class="line">			uni.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;isShowLoading&#x27;</span>,<span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		uni.<span class="title function_">showLoading</span>(&#123;</span><br><span class="line">			<span class="attr">title</span>: <span class="string">&#x27;加载中...&#x27;</span>,</span><br><span class="line">			<span class="attr">complete</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">				uni.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;isShowLoading&#x27;</span>,<span class="literal">true</span>)</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">fail</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">				uni.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;isShowLoading&#x27;</span>,<span class="literal">false</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Utils</span>()</span><br></pre></td></tr></table></figure>



<h4 id="uniapp-跨域解决"><a href="#uniapp-跨域解决" class="headerlink" title="uniapp 跨域解决"></a>uniapp 跨域解决</h4><ul>
<li>代理 - h5使用vite.config.js 设置代理，小程序可以封装config.js 对url过滤拼接</li>
<li>使用内置浏览器</li>
</ul>
<h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><h4 id="vue2和vue3的区别"><a href="#vue2和vue3的区别" class="headerlink" title="vue2和vue3的区别"></a>vue2和vue3的区别</h4><ol>
<li><p><strong>性能优化</strong>：</p>
<ul>
<li>Vue 3 重写了虚拟 DOM 渲染器，引入了更高效的编译器和静态提升等技术，以提高整体性能。</li>
<li>使用 Proxy 替代 Object.defineProperty 实现数据响应式，从而提供更快速和更直观的响应式系统。</li>
</ul>
</li>
<li><p><strong>Composition API</strong>：</p>
<ul>
<li>在 Vue 3 中引入了 Composition API，利用使用hook的方式引入vue API</li>
</ul>
</li>
<li><p><strong>Teleport 组件</strong>：</p>
<ul>
<li>引入了 Teleport 组件，在代码中可以方便地挂载子组件到任意 DOM 节点上。</li>
</ul>
</li>
<li><p><strong>Fragment 标签</strong>：</p>
<ul>
<li>引入了 Fragment 标签（<code>&lt;template&gt;</code> 上添加 <code>v-if</code>、<code>v-for</code> 等指令），使得模板中可以直接使用无需额外包裹根元素。</li>
</ul>
</li>
<li><p><strong>Tree-shaking 支持</strong>：</p>
<ul>
<li>对于常见打包工具如 webpack、rollup 等有很好支持，在构建时能够进行更全面有效的 Tree-shaking。</li>
</ul>
</li>
<li><p><strong>ts 支持</strong>：</p>
<ul>
<li>在 Vue 3 中使用 TypeScript 结合组合式API可以让开发者享受到更强大、便捷和安全性方面有所提升。</li>
</ul>
</li>
</ol>
<h4 id="object-defineproperty如何监听数组，为什么无法获取数组变化"><a href="#object-defineproperty如何监听数组，为什么无法获取数组变化" class="headerlink" title="object.defineproperty如何监听数组，为什么无法获取数组变化"></a>object.defineproperty如何监听数组，为什么无法获取数组变化</h4><ul>
<li><strong>Object.defineProperty 监听数组</strong>：使用 <code>Object.defineProperty</code> 监听数组时，会为数组的索引属性设置 <code>get</code> 和 <code>set</code> 方法来实现监听数组元素的读取和修改操作。这样可以在访问或修改数组元素时触发相应的操作。</li>
<li><strong>无法获取数组变化原因</strong>：<code>Object.defineProperty</code> 可以用来监听对象属性的变化，但对于数组来说，它无法直接监听数组的变化，操作数组时，并不会触发属性的 <code>set</code> 方法。因为修改的实际上是数组的内部结构，而不是修改数组对象的属性</li>
<li><strong>解决方法</strong>：为了监听数组的变化，Vue专门设计用于监听数组响应式操作的方法，如 <code>$set</code>、<code>$delete</code>，这些方法可以拦截数组的操作。vue3使用 <code>Proxy</code> 对象可以更方便地监听数组的变化，因为它可以直接拦截数组的操作，而不需要为数组的每个索引属性都设置 <code>get</code> 和 <code>set</code> 方法。</li>
</ul>
<h4 id="Vue-中使用-data-包裹属性的原因"><a href="#Vue-中使用-data-包裹属性的原因" class="headerlink" title="Vue 中使用 data 包裹属性的原因"></a><strong>Vue 中使用 data 包裹属性的原因</strong></h4><ol>
<li><strong>数据响应式</strong>：将数据定义在 <code>data</code> 对象中可以使这些数据变成响应式的。当数据发生变化时，Vue 能够检测到并自动更新相关的视图，从而实现数据和视图的同步更新。</li>
<li><strong>组件作用域</strong>：将数据放在 <code>data</code> 对象中可以确保这些数据只在当前组件的作用域内有效，避免了数据命名冲突</li>
<li><strong>方便管理</strong>：通过将所有数据都放在 <code>data</code> 对象中，可以更好地组织和管理组件内部的数据，使代码结构更清晰、易读和易维护。</li>
<li><strong>Vue 实例化时合并处理</strong>：Vue 在实例化组件时会将 <code>data</code> 对象进行合并处理，确保组件能够正确访问到其中定义的数据。</li>
</ol>
<h4 id="vue2-组件中data是函数不是对象为什么"><a href="#vue2-组件中data是函数不是对象为什么" class="headerlink" title="vue2 组件中data是函数不是对象为什么"></a>vue2 组件中data是函数不是对象为什么</h4><p>vue2 组件data是函数，vue实例既可以是对象也可以是函数；</p>
<p>组件中的 <code>data</code> 选项通常是一个函数而不是一个对象。这是因为 Vue 在实例化组件时会将组件的配置选项进行合并处理，如果 <code>data</code> 是一个对象，那么所有该组件实例共享同一份数据对象，可能会导致数据互相影响。</p>
<h4 id="vue生命周期和组件间生命周期顺序"><a href="#vue生命周期和组件间生命周期顺序" class="headerlink" title="vue生命周期和组件间生命周期顺序"></a>vue生命周期和组件间生命周期顺序</h4><p><strong>Vue 2 生命周期</strong></p>
<p>Vue 2 的组件生命周期钩子如下：</p>
<ol>
<li><strong>beforeCreate</strong>：实例被创建，数据观测和事件配置尚未开始。</li>
<li><strong>created</strong>：实例已完成创建，数据观测和事件配置已完成，$el 还未挂载。</li>
<li><strong>beforeMount</strong>：在挂载开始之前被调用，相关的 render 函数首次被调用。</li>
<li><strong>mounted</strong>：实例被挂载到 DOM 上，此时可以进行 DOM 操作。</li>
<li><strong>beforeUpdate</strong>：数据变化后，组件重新渲染之前被调用。</li>
<li><strong>updated</strong>：组件重新渲染后被调用。</li>
<li><strong>beforeDestroy</strong>：组件实例销毁之前被调用，可以进行清理工作。</li>
<li><strong>destroyed</strong>：组件实例被销毁后调用，再也不可使用。</li>
</ol>
<p><strong>Vue 3 生命周期</strong></p>
<p>Vue 3 对生命周期钩子的命名方式进行了调整，同时引入了 Composition API。Vue 3 的组件生命周期钩子如下：</p>
<ol>
<li><strong>setup</strong></li>
<li><strong>beforeMount</strong>：同 Vue 2。</li>
<li><strong>mounted</strong>：同 Vue 2。</li>
<li><strong>beforeUpdate</strong>：同 Vue 2。</li>
<li><strong>updated</strong>：同 Vue 2。</li>
<li><strong>beforeUnmount</strong>：对应 Vue 2 的 <code>beforeDestroy</code>，组件实例销毁之前调用。</li>
<li><strong>unmounted</strong>：对应 Vue 2 的 <code>destroyed</code>，组件实例被销毁后调用。</li>
</ol>
<p><strong>组件间的生命周期顺序</strong></p>
<ol>
<li>父组件<ul>
<li><code>beforeCreate</code></li>
<li><code>created</code></li>
<li><code>beforeMount</code></li>
<li>子组件<ul>
<li><code>beforeCreate</code></li>
<li><code>created</code></li>
<li><code>beforeMount</code></li>
<li><code>mounted</code></li>
</ul>
</li>
<li><code>mounted</code></li>
</ul>
</li>
<li>父组件更新时<ul>
<li><code>beforeUpdate</code></li>
<li>子组件<ul>
<li><code>beforeUpdate</code></li>
<li><code>updated</code></li>
</ul>
</li>
<li><code>updated</code></li>
</ul>
</li>
<li>父组件销毁时<ul>
<li><code>beforeUnmount</code></li>
<li>子组件<ul>
<li><code>beforeUnmount</code></li>
<li><code>unmounted</code></li>
</ul>
</li>
<li><code>unmounted</code></li>
</ul>
</li>
</ol>
<h4 id="vue如何定义路由"><a href="#vue如何定义路由" class="headerlink" title="vue如何定义路由"></a>vue如何定义路由</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home.vue&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About.vue&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [  </span><br><span class="line">  &#123;  </span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,  </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span>,  </span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Home</span>,  </span><br><span class="line">  &#125;,  </span><br><span class="line">  &#123;  </span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,  </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;About&#x27;</span>,  </span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">About</span>,  </span><br><span class="line">  &#125;,  </span><br><span class="line">];  </span><br><span class="line"><span class="comment">// 通过createRouter创建路由实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;  </span><br><span class="line">    <span class="comment">// 设置路由模式  History 模式</span></span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),  </span><br><span class="line">    <span class="comment">// 设置 hash模式</span></span><br><span class="line">  <span class="comment">//history: createWebHashHistory(),</span></span><br><span class="line">  routes,  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>

<h4 id="hash和history-路由模式区别"><a href="#hash和history-路由模式区别" class="headerlink" title="hash和history 路由模式区别"></a>hash和history 路由模式区别</h4><p><strong>URL 结构</strong></p>
<ul>
<li><p><strong>Hash 模式</strong>：</p>
<ul>
<li><p>URL 中包含一个<code>#</code>符号，后面跟着路由路径。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/#/about  </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>#</code> 符号后面的部分被称为 “hash”，它不会被浏览器发送到服务器。</p>
</li>
</ul>
</li>
<li><p><strong>History 模式</strong>：</p>
<ul>
<li><p>URL 中没有<code>#</code>符号，而是使用常规的路由路径。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/about  </span><br></pre></td></tr></table></figure>
</li>
<li><p>这种方式更符合 RESTful 风格的 URL。</p>
</li>
</ul>
</li>
</ul>
<p><strong>浏览器支持</strong></p>
<ul>
<li>Hash 模式<ul>
<li>兼容所有浏览器，包括较老的版本，因为它使用了简易的 URL 结构。</li>
</ul>
</li>
<li>History 模式<ul>
<li>需要现代浏览器的支持（大部分现代浏览器都支持 HTML5 的 History API）。老旧浏览器可能不支持。</li>
</ul>
</li>
</ul>
<p><strong>服务器部署</strong></p>
<ul>
<li><strong>Hash 模式</strong>：<ul>
<li>不需要特别的服务器配置，因为所有哈希路由都在前端处理，服务器只需提供初始的 HTML 文件。</li>
</ul>
</li>
<li><strong>History 模式</strong>：<ul>
<li>需要服务器配置以确保所有路由都指向同一个 HTML 文件。这通常涉及到重定向规则，保证用户访问的 URL 返回的是应用的前端代码。否则会出现404</li>
</ul>
</li>
</ul>
<p><strong>并发处理</strong></p>
<ul>
<li><strong>Hash 模式</strong>：<ul>
<li>当 URL 改变时，浏览器只是改变了 hash 部分，这不会导致页面重新加载。</li>
</ul>
</li>
<li><strong>History 模式</strong>：<ul>
<li>URL 的变化会导致浏览器的状态变化，前进、后退按钮的处理也需要依赖于 History API。</li>
</ul>
</li>
</ul>
<h4 id="v-show和v-if区别"><a href="#v-show和v-if区别" class="headerlink" title="v-show和v-if区别"></a>v-show和v-if区别</h4><ol>
<li>v-show是通过CSS的display属性来控制元素的显示和隐藏，而v-if是通过DOM操作来添加或删除元素来实现的。v-show的初始渲染比v-if快</li>
<li>v-show适用于频繁切换显示和隐藏的元素，因为它只是简单地切换CSS属性，不会引起DOM的重新渲染。而v-if适用于不经常切换的元素，因为它会在DOM中添加或删除元素，会引起DOM的重新渲染。</li>
<li>如果当前组件在 created 中存在接口的调用，不销毁组件，重新获取，就会获取到错误的数据，通常建议使用v-if而不是v-show。</li>
<li>v-show不支持<template>元素，而v-if可以作用在<template>元素上使用。</template></template></li>
<li><strong>当组件需要在指定时机创建，在指定时机销毁时，需要使用 v-if。而 当组件仅需要创建一次时，则可以使用 v-show。</strong></li>
</ol>
<h4 id="v-if和v-for的优先级"><a href="#v-if和v-for的优先级" class="headerlink" title="v-if和v-for的优先级"></a>v-if和v-for的优先级</h4><p>vue2：v-for的优先级高于v-if。会先确保在循环渲染列表时能够完全渲染，再进行条件判断条件判断</p>
<p>vue3：在 vue3 中 v-if 的优先级要高于 v-for，当v-if的条件为false时，Vue 3会跳过整个v-for循环，不会对列表中的每个元素进行渲染</p>
<h4 id="v-for的key作用，v-for遍历数组中能否使用index作为key"><a href="#v-for的key作用，v-for遍历数组中能否使用index作为key" class="headerlink" title="v-for的key作用，v-for遍历数组中能否使用index作为key"></a>v-for的key作用，v-for遍历数组中能否使用index作为key</h4><p>可以，但不推荐，可能会引发一下问题</p>
<ol>
<li>当数组数据发生变化时，可能会导致不必要的重新渲染。</li>
<li>如果数组中的元素位置发生变化，可能会导致错误的DOM元素被更新。</li>
<li>不利于Vue正确地跟踪每个元素的状态和身份。</li>
</ol>
<h4 id="vue组件通信方式"><a href="#vue组件通信方式" class="headerlink" title="vue组件通信方式"></a>vue组件通信方式</h4><p> <strong>父子组件通信</strong></p>
<ul>
<li><strong>Props</strong>：<ul>
<li>父组件通过 <code>props</code> 向子组件传递数据。</li>
</ul>
</li>
<li><strong>$emit</strong>：<ul>
<li>子组件通过 <code>$emit</code> 向父组件发送事件和数据。</li>
</ul>
</li>
<li><strong>Slots</strong>：<ul>
<li>用于在父组件中定义内容，以便在子组件中使用。</li>
<li>适合需要灵活插槽内容的场景。</li>
</ul>
</li>
</ul>
<p><strong>兄弟组件通信</strong></p>
<ul>
<li><strong>通过父组件</strong>：<ul>
<li>兄弟组件通过共同的父组件进行通信，父组件接收子组件的事件并再次传递给另一个子组件。</li>
</ul>
</li>
<li><strong>Event Bus</strong>：<ul>
<li>可以创建一个事件总线（Event Bus）用于非父子关系组件之间的通信。</li>
</ul>
</li>
</ul>
<p><strong>Provide&#x2F;Inject</strong></p>
<ul>
<li>用于祖先组件与后代组件之间的通信。</li>
<li>适合深层嵌套组件的场景。</li>
</ul>
<h4 id="vuex-pinia"><a href="#vuex-pinia" class="headerlink" title="vuex&#x2F; pinia"></a>vuex&#x2F; pinia</h4><ul>
<li>用于跨多个组件的复杂状态管理。</li>
<li>适合中大型应用程序。</li>
</ul>
<h4 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h4><p><strong>创建Pinia实例</strong> - Vue.js应用程序的入口文件（通常是<code>main.js</code>）中，创建一个Pinia实例并将其添加到Vue应用程序中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>  </span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)  </span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()  </span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(pinia)  </span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>定义状态</strong> - 可以使用<code>defineStore</code>函数定义状态。创建一个新的<code>.js</code>文件，例如<code>counter.js</code>，并在其中定义一个计数器状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./counter.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, &#123;  </span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;  </span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>  </span><br><span class="line">  &#125;),  </span><br><span class="line">  <span class="attr">actions</span>: &#123;  </span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;  </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="title function_">decrement</span>(<span class="params"></span>) &#123;  </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>--  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>在组件中使用状态</strong> - 可以使用<code>useStore</code>函数来访问和使用Pinia中定义的状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;div&gt;  </span><br><span class="line">    &lt;p&gt;Count: &#123;&#123; counter.count &#125;&#125;&lt;/p&gt;  </span><br><span class="line">    &lt;button @click=&quot;counter.increment()&quot;&gt;Increment&lt;/button&gt;  </span><br><span class="line">    &lt;button @click=&quot;counter.decrement()&quot;&gt;Decrement&lt;/button&gt;  </span><br><span class="line">  &lt;/div&gt;  </span><br><span class="line">&lt;/template&gt;  </span><br><span class="line"></span><br><span class="line">&lt;script&gt;  </span><br><span class="line">import &#123; useCounterStore &#125; from &#x27;./counter.js&#x27;  </span><br><span class="line"></span><br><span class="line">export default &#123;  </span><br><span class="line">  setup() &#123;  </span><br><span class="line">    const counter = useCounterStore()  </span><br><span class="line"></span><br><span class="line">    return &#123;  </span><br><span class="line">      counter  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="双向数据绑定原理"><a href="#双向数据绑定原理" class="headerlink" title="双向数据绑定原理"></a>双向数据绑定原理</h4><p>在 Vue 2 中，双向数据绑定是通过 Object.defineProperty() 方法对数据对象的属性进行劫持实现的。当数据对象被创建时，Vue 2 会递归地将对象的属性转换为 getter 和 setter，并在属性被访问或修改时触发更新</p>
<p>在 Vue 3 中，双向数据绑定依然是通过响应式系统实现的，但采用了 Proxy 对象替代了 Object.defineProperty()。</p>
<h4 id="v-model-vue2与vue3分别作用在普通元素和组件元素的区别"><a href="#v-model-vue2与vue3分别作用在普通元素和组件元素的区别" class="headerlink" title="v-model - vue2与vue3分别作用在普通元素和组件元素的区别"></a>v-model - vue2与vue3分别作用在普通元素和组件元素的区别</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 当作用于普通元素时，v-model在vue2与vue3没有什么区别</span><br><span class="line"><span class="tag">&lt;<span class="name">inpuy</span> <span class="attr">v-model</span>=<span class="string">&quot;a&quot;</span> /&gt;</span></span><br><span class="line">// 等价于</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;a&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;(e)=&gt;&#123;a=e.target.value&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">// 当v-model 用于自定义组件键上时</span><br><span class="line">// vue2</span><br><span class="line"><span class="tag">&lt;<span class="name">son</span> <span class="attr">v-model</span>=<span class="string">&quot;a&quot;</span>/&gt;</span></span><br><span class="line">//等价于</span><br><span class="line"><span class="tag">&lt;<span class="name">son</span> <span class="attr">:value</span>=<span class="string">&quot;a&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;(a)=&gt;&#123;a=e&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">// vue3</span><br><span class="line"><span class="tag">&lt;<span class="name">son</span> <span class="attr">v-model</span>=<span class="string">&quot;a&quot;</span>/&gt;</span></span><br><span class="line">//等价于</span><br><span class="line"><span class="tag">&lt;<span class="name">son</span> <span class="attr">:modelValue</span>=<span class="string">&quot;a&quot;</span> @<span class="attr">update:modelValue</span>=<span class="string">&quot;(e)=&gt;&#123;a=e&#125;&quot;</span>/&gt;</span></span><br><span class="line">// 子组件可以直接用defindprops接受modelValue</span><br><span class="line">// 全称为</span><br><span class="line"><span class="tag">&lt;<span class="name">son</span> <span class="attr">v-model:modelValue</span>=<span class="string">&quot;a&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="nextTick作用"><a href="#nextTick作用" class="headerlink" title="nextTick作用"></a>nextTick作用</h4><p><code>nextTick</code> 是 Vue 中的一个异步方法，它的作用是在 DOM 更新之后执行回调函数。<code>nextTick</code> 方法接受一个回调函数作为参数，并在 DOM 更新完成后执行该回调函数。因为在页面渲染后执行，可以在vue中获取到最新的DOM元素</p>
<h4 id="vue虚拟Dom"><a href="#vue虚拟Dom" class="headerlink" title="vue虚拟Dom"></a>vue虚拟Dom</h4><p>虚拟 DOM 是一个轻量级的 JavaScript 对象树，它是对真实 DOM 的抽象表示。当数据发生变化时，Vue 会通过比较新旧虚拟 DOM 树的差异，然后只更新需要变化的部分</p>
<h4 id="vue虚拟Dom怎么生成"><a href="#vue虚拟Dom怎么生成" class="headerlink" title="vue虚拟Dom怎么生成"></a>vue虚拟Dom怎么生成</h4><p>Vue 的虚拟 DOM 是通过模板编译器（Template Compiler）生成的。模板编译器会将模板解析成抽象语法树（AST），然后将 AST 转换为渲染函数（Render Function），最终生成虚拟 DOM。</p>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><h4 id="react理解-和-特征"><a href="#react理解-和-特征" class="headerlink" title="react理解 和 特征"></a>react理解 和 特征</h4><p>​	<strong>理解</strong></p>
<ul>
<li>react是构建用户界面的js库，提供了UI层面的解决方案</li>
<li>遵循组件设计，声明式编程，函数式编程概念</li>
<li>使用虚拟DOM来操纵实际DOM，减少性能开支</li>
<li>react将界面分割成独立小块，每一块为一个组件，通过组件嵌套组合构成整个页面</li>
</ul>
<p>​	<strong>特征</strong></p>
<ul>
<li>JSX语法</li>
<li>单项数据流</li>
<li>虚拟DOM</li>
<li>声明式编程，函数式编程</li>
<li>组件化</li>
</ul>
<h4 id="MVC框架主要问题是什么"><a href="#MVC框架主要问题是什么" class="headerlink" title="MVC框架主要问题是什么"></a>MVC框架主要问题是什么</h4><h4 id="Flux是什么"><a href="#Flux是什么" class="headerlink" title="Flux是什么"></a>Flux是什么</h4><h4 id="什么是jsx"><a href="#什么是jsx" class="headerlink" title="什么是jsx"></a>什么是jsx</h4><p>一种语言的扩展，简化了代码的开发。它利用了js语法和html标签相结合的语法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用react createElement创建元素</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> reactElement = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">	h3,</span><br><span class="line">    &#123;<span class="attr">className</span>:<span class="string">&#x27;name_vale&#x27;</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;Element Value&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//jsx 语法</span></span><br><span class="line"><span class="keyword">const</span> reactElement = (</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">className</span>=<span class="string">&#x27;name_value&#x27;</span>&gt;</span>Element Value<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><p>虚拟DOM是真实DOM在内存中的表示，并于实际DOM同步。</p>
<h4 id="React-工作原理"><a href="#React-工作原理" class="headerlink" title="React 工作原理"></a>React 工作原理</h4><p>React会创建一个虚拟DOM。 当一个组件的状态改变时，React首先会通过Diff算法来标记虚拟DOM中的改变，第二步是调节，会用diff的结构来更新DOM</p>
<h4 id="React有什么优点"><a href="#React有什么优点" class="headerlink" title="React有什么优点"></a>React有什么优点</h4><ul>
<li>模版引入JSX语法，使得组件的代码更加可读，也更容易看懂组件布局和组件间的引用</li>
<li>支持服务端渲染，对SEO和性能进行改进</li>
<li>React 只关注View层，所以可以和其他任何框架一起使用</li>
</ul>
<h4 id="react中类组件和函数组件的理解"><a href="#react中类组件和函数组件的理解" class="headerlink" title="react中类组件和函数组件的理解"></a>react中类组件和函数组件的理解</h4><p>​	<strong>类组件</strong></p>
<ol>
<li><strong>定义方式</strong></li>
</ol>
<ul>
<li>使用 ES6 的类语法定义，需继承自 <code>React.Component</code>。</li>
<li>通常具有生命周期方法（如 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code> 等）。</li>
<li>需要使用 <code>this</code> 关键字来访问和管理组件的状态和方法</li>
<li>类组件调用方式需要对组件进行实例化，调用render方法</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;  </span><br><span class="line">    <span class="variable language_">super</span>(props);  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  increment = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);  </span><br><span class="line">  &#125;;  </span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> (  </span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">    );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>状态管理</strong><ul>
<li><strong>类组件</strong>使用 <code>state</code> 对象来管理组件的状态，并通过 <code>this.setState</code> 方法来更新状态。</li>
</ul>
</li>
<li><strong>生命周期方法</strong><ul>
<li><strong>类组件</strong>有完整的生命周期方法，可以在特定的阶段执行某些代码（如在组件挂载、更新和卸载时）。</li>
</ul>
</li>
</ol>
<p><strong>函数式组件</strong></p>
<ol>
<li><strong>定义方式</strong></li>
</ol>
<ul>
<li>使用 JavaScript 函数定义，通常是无状态的。</li>
<li>从 React 16.8 开始，函数组件可以使用 <code>Hooks</code>（如 <code>useState</code> 和 <code>useEffect</code>）来管理状态和副作用。</li>
<li>不需要使用 <code>this</code> 关键字</li>
<li>函数式组件调用即执行函数</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyFunctionComponent</span> = (<span class="params"></span>) =&gt; &#123;  </span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;  </span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);  </span><br><span class="line">  &#125;;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">  );  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>状态管理</strong><ul>
<li><strong>函数组件</strong>使用 <code>useState</code> Hook 来管理状态，更加灵活和简洁。</li>
</ul>
</li>
<li><strong>生命周期方法</strong><ul>
<li><strong>函数组件</strong>没有生命周期方法，但可以使用 <code>useEffect</code> Hook 来实现相同的效果，基于依赖数组控制副作用的执行时机。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>区别</th>
<th>函数组件</th>
<th>类组件</th>
</tr>
</thead>
<tbody><tr>
<td>是否有this</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>是否有生命周期</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>是否有状态state</td>
<td>没有</td>
<td>有</td>
</tr>
</tbody></table>
<h4 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h4><p>React组件生命周期可以分为3个阶段 ：(初始化 -)挂载 - 更新 - 销毁( - 错误捕获)</p>
<div class="tabs" id="unique-name"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="unique-name-1">挂载( Mounting)</button><button type="button" class="tab " data-href="unique-name-2">更新( Updating)</button><button type="button" class="tab " data-href="unique-name-3">卸载( Unmounting)</button><button type="button" class="tab " data-href="unique-name-4">错误边界 (componentDidCatch)</button></ul><div class="tab-contents"><div class="tab-item-content active" id="unique-name-1"><p>组件实例化并插入DOM的过程<br>这个阶段包括以下生命周期：</p>
<ul>
<li>constructor()</li>
<li>static getDerivedStateFromProps()</li>
<li>render()</li>
<li><strong>componentDidMount()</strong></li>
</ul>
<p><strong>挂载阶段 - 详细</strong></p>
<ol>
<li>constructor()<ul>
<li>构造函数，在组件创建时调用，用于初始化状态和绑定事件处理函数</li>
<li>在构造函数中调用super(props) 来调用父类的构造函数，并将props传递给父类</li>
<li>初始化组件的状态可以通过 this,stat &#x3D; { } 实现</li>
</ul>
</li>
<li>static getDerivedStateFromProps()<ul>
<li>当组件接收新的porps时调用，在渲染之前执行。</li>
<li>用于根据新的props计算并更新组件的状态</li>
<li>应返回一个对象来更新状态，或者返回null来表示不需要更新状态</li>
</ul>
</li>
<li>render()<ul>
<li>必须得生命周期方法，用于渲染组件模板</li>
<li>返回一个React元素，秒数组件的输出</li>
<li>不能再这个方法中修改组件的状态或这行副作用操作，会导致死循环</li>
</ul>
</li>
<li>componentDidMount()<ul>
<li>在组件初始化渲染之后立即调用</li>
<li>通常执行一些初始化操作，例如网络请求，获取初始数据</li>
<li>这个方法只会在组件生命周期中调用一次</li>
</ul>
</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;<span class="title class_">Component</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>)</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;constructor&#x27;</span>)</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">props, state</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(getDerivedStateFromProps)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组件挂载后执行的代码</span></span><br><span class="line">    <span class="title function_">conponentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;conponentDidMount&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;render&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>挂载阶段生命周期<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数组件代替</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyFunctionComponent</span> = (<span class="params">&#123; someValue &#125;</span>) =&gt; &#123;  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 组件更新后执行的代码  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component updated&#x27;</span>);  </span><br><span class="line">  &#125;, [someValue]); <span class="comment">// 将某个值作为依赖，依赖项变化时执行  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="unique-name-2"><p>组件props或state发生变化，导致组件重新渲染的过程<br>这个阶段包括以下生命周期：</p>
<ul>
<li>static getDerivedStateFromProps()</li>
<li>shouldComponentUpdata()</li>
<li>render()</li>
<li>getSnapshotBeforeUpdate()</li>
<li>componentDidUpdate()</li>
</ul>
<p><strong>更新阶段生命周期 - 详细</strong></p>
<ol>
<li>shouldComponentUpdate(nextProps, nextState)<ul>
<li>在组件接收到新的props或者state时调用，在渲染之前执行</li>
<li>可以根据最新的props或者state决定是否需要重新渲染组件</li>
<li>默认返回true，表示组件将会重新渲染，可以通过返回false来阻止重新渲染</li>
</ul>
</li>
<li>render()<ul>
<li>必须得生命周期方法，用于渲染组件模板</li>
<li>返回一个React元素，秒数组件的输出</li>
<li>不能再这个方法中修改组件的状态或这行副作用操作，会导致死循环</li>
</ul>
</li>
<li>getSnapshotBeforeUpdate(prevProps, prevState)<ul>
<li>在最新的渲染输出被提交到DOM之前调用</li>
<li>用于获取更新前的DOM快照或执行一些DOM操作</li>
<li>返回值将作为componentDidUpdate方法的第三个参数</li>
</ul>
</li>
<li>conponentDidUpdate(prevProps, prevState, snapshot)<ul>
<li>在更新组件更新完成后立即调用</li>
<li>通常用于执行一些副作用操作，比如更新后的DOM操作，网络请求</li>
<li>可以访问到更新之前的props，state。以及getSnapshotBeforeUpdate返回值</li>
</ul>
</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;<span class="title class_">Component</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;constructor&#x27;</span>)</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;shouldComponentUpdate&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, prevState</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getSnapshotBeforeUpdate&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组件更新后执行的代码</span></span><br><span class="line">    <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentUpdate&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>更新生命周期<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>this.state.count += 1&#125;&gt;修改state<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数组件代替</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyFunctionComponent</span> = (<span class="params">&#123; someValue &#125;</span>) =&gt; &#123;  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 组件更新后执行的代码  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component updated&#x27;</span>);  </span><br><span class="line">  &#125;, [someValue]); <span class="comment">// 将某个值作为依赖，依赖项变化时执行  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="unique-name-3"><p>组件从DOM中移除的过程<br>这个阶段包括以下生命周期：</p>
<ul>
<li>componentWillUnmount()</li>
</ul>
<p><strong>卸载生命周期 - 详细</strong></p>
<ol>
<li>componentWillUnmount()<ul>
<li>在组件即将被销毁并从DOM中移除之前调用</li>
<li>用于执行一些清理工作，比如取消订阅，清除定时器，监听器等</li>
<li>在这个方法中不能调用setState，因为组件即将被销毁</li>
</ul>
</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;<span class="title class_">Component</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(constructor)</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组件卸载前执行的代码</span></span><br><span class="line">    <span class="title function_">componentWillUnnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ComponentWillUnmount&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>销毁组件生命周期<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数式组件代替</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyFunctionComponent</span> = (<span class="params"></span>) =&gt; &#123;  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 清理函数，在组件卸载前执行  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component will unmount&#x27;</span>);  </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;, []); <span class="comment">// 空数组将会在每次渲染后执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="unique-name-4"><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;  </span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;  </span><br><span class="line">    <span class="comment">// 处理错误  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error caught:&quot;</span>, error);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数组件本身不能实现错误边界，但可以利用类组件来包装。</p>
</blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>





<h4 id="如何跟踪功能组件的卸载"><a href="#如何跟踪功能组件的卸载" class="headerlink" title="如何跟踪功能组件的卸载"></a>如何跟踪功能组件的卸载</h4><p>在函数式组件中，useEffect可以返回一个清理函数，可以在清理函数中定义要清楚理的资源。在DOM组件删除之前调用，清理设置，防止内存泄漏。例如计时器，订阅，监听事件</p>
<h4 id="react响应式原理"><a href="#react响应式原理" class="headerlink" title="react响应式原理"></a>react响应式原理</h4><h4 id="render函数的渲染过程，解析流程"><a href="#render函数的渲染过程，解析流程" class="headerlink" title="render函数的渲染过程，解析流程"></a>render函数的渲染过程，解析流程</h4><h4 id="hooks-useMemo和useCallback-区别"><a href="#hooks-useMemo和useCallback-区别" class="headerlink" title="hooks - useMemo和useCallback 区别"></a>hooks - useMemo和useCallback 区别</h4><h4 id="hooks-useState和useRef-区别"><a href="#hooks-useState和useRef-区别" class="headerlink" title="hooks - useState和useRef 区别"></a>hooks - useState和useRef 区别</h4><h4 id="useEffect的两个参数？依赖项只传一个和空数组，不传依赖项的区别"><a href="#useEffect的两个参数？依赖项只传一个和空数组，不传依赖项的区别" class="headerlink" title="useEffect的两个参数？依赖项只传一个和空数组，不传依赖项的区别"></a>useEffect的两个参数？依赖项只传一个和空数组，不传依赖项的区别</h4><h4 id="useEffect的return-函数在依赖项不同的情况下，有何区别"><a href="#useEffect的return-函数在依赖项不同的情况下，有何区别" class="headerlink" title="useEffect的return 函数在依赖项不同的情况下，有何区别"></a>useEffect的return 函数在依赖项不同的情况下，有何区别</h4><h4 id="React-Hooks底层原理，如何实现状态更新"><a href="#React-Hooks底层原理，如何实现状态更新" class="headerlink" title="React Hooks底层原理，如何实现状态更新"></a>React Hooks底层原理，如何实现状态更新</h4><h4 id="怎么实现全局数据存储-redux数据不持久化怎么解决"><a href="#怎么实现全局数据存储-redux数据不持久化怎么解决" class="headerlink" title="怎么实现全局数据存储? redux数据不持久化怎么解决"></a>怎么实现全局数据存储? redux数据不持久化怎么解决</h4><h4 id="父组件渲染如何让子组件不渲染，类组件和hooks方法"><a href="#父组件渲染如何让子组件不渲染，类组件和hooks方法" class="headerlink" title="父组件渲染如何让子组件不渲染，类组件和hooks方法"></a>父组件渲染如何让子组件不渲染，类组件和hooks方法</h4><p><strong>类组件</strong></p>
<ul>
<li><p><strong>条件渲染</strong>：在父组件的 <code>render</code> 方法中使用条件语句，根据特定条件决定是否渲染子组件。例如，可以使用 <code>if</code> 语句或三元表达式来控制子组件的渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ParentComponent extends React.Component &#123;  </span><br><span class="line">  render() &#123;  </span><br><span class="line">    const shouldRenderChild = // 根据某个条件判断是否渲染子组件  </span><br><span class="line">    return (  </span><br><span class="line">      &lt;div&gt;  </span><br><span class="line">        &#123;shouldRenderChild &amp;&amp; &lt;ChildComponent /&gt;&#125;  </span><br><span class="line">      &lt;/div&gt;  </span><br><span class="line">    );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过 props 控制</strong>：将一个布尔类型的 prop 传递给子组件，根据该 prop 的值决定子组件是否进行渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ParentComponent extends React.Component &#123;  </span><br><span class="line">  render() &#123;  </span><br><span class="line">    const shouldRenderChild = // 根据某个条件判断是否渲染子组件  </span><br><span class="line">    return (  </span><br><span class="line">      &lt;div&gt;  </span><br><span class="line">        &lt;ChildComponent shouldRender=&#123;shouldRenderChild&#125; /&gt;  </span><br><span class="line">      &lt;/div&gt;  </span><br><span class="line">    );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class ChildComponent extends React.Component &#123;  </span><br><span class="line">  render() &#123;  </span><br><span class="line">    if (!this.props.shouldRender) &#123;  </span><br><span class="line">      return null; // 不渲染子组件  </span><br><span class="line">    &#125;  </span><br><span class="line">    return (  </span><br><span class="line">      // 子组件的渲染内容  </span><br><span class="line">    );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>函数组件</strong></p>
<ul>
<li><strong>条件渲染</strong>：在函数组件中使用条件语句，根据特定条件决定是否返回子组件的 JSX。例如，可以使用 <code>if</code> 语句或三元表达式来控制子组件的渲染。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function ParentComponent() &#123;  </span><br><span class="line">  const shouldRenderChild = // 根据某个条件判断是否渲染子组件  </span><br><span class="line">  return (  </span><br><span class="line">    &lt;div&gt;  </span><br><span class="line">      &#123;shouldRenderChild &amp;&amp; &lt;ChildComponent /&gt;&#125;  </span><br><span class="line">    &lt;/div&gt;  </span><br><span class="line">  );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>通过 props 控制</strong>：将一个布尔类型的 prop 传递给子组件，根据该 prop 的值决定是否返回子组件的 JSX。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function ParentComponent() &#123;  </span><br><span class="line">  const shouldRenderChild = // 根据某个条件判断是否渲染子组件  </span><br><span class="line">  return (  </span><br><span class="line">    &lt;div&gt;  </span><br><span class="line">      &lt;ChildComponent shouldRender=&#123;shouldRenderChild&#125; /&gt;  </span><br><span class="line">    &lt;/div&gt;  </span><br><span class="line">  );  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">function ChildComponent(&#123; shouldRender &#125;) &#123;  </span><br><span class="line">  if (!shouldRender) &#123;  </span><br><span class="line">    return null; // 不渲染子组件  </span><br><span class="line">  &#125;  </span><br><span class="line">  return (  </span><br><span class="line">    // 子组件的渲染内容  </span><br><span class="line">  );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>





<h4 id="state-状态-和props-属性-区别"><a href="#state-状态-和props-属性-区别" class="headerlink" title="state( 状态)和props( 属性)区别"></a>state( 状态)和props( 属性)区别</h4><p>一个组件状态可以由两个参数决定：内部数据state，外部数据props</p>
<p>state：是一种数据结构，用于组件挂载时所需数据的默认值。由内部定义，组件初始化时定义，需要通过setState进行修改<br>props：是组件的配置。一般由父组件或兄弟组件进行传递，在组件内部是不能被修改的，</p>
<h4 id="什么是props透传"><a href="#什么是props透传" class="headerlink" title="什么是props透传"></a>什么是props透传</h4><p>props透传指的是通过多层嵌套的组件传递props的一个过程。为了方便开发和维护。一层一层传递props，不现实。<br>所以可以使用其他模式：使用上下文(Context&#x2F; useContext) 或状态管理库(Redux) )来代替porps透传。这种些方法不需要每个组件传递props</p>
<h4 id="什么是React-上下文-contest"><a href="#什么是React-上下文-contest" class="headerlink" title="什么是React 上下文 - contest"></a>什么是React 上下文 - contest</h4><p>react contest 是一项功能，它提供一种在组件数中传递数据的方法，而无需再每一层手动传递。它允许创建一个全局状态。被包裹的任何子孙组件都能访问该状态</p>
<p>Context API 由三部分组成：</p>
<ol>
<li>createContext：创建上下文</li>
<li>Context.provider 该组件用于为上下文提供值，被该标签包裹的子组件可以获取value的值</li>
<li>Context.Consumer 或useContext hooks: 获取从上下文中传递的值。</li>
</ol>
<h4 id="渲染数组元素"><a href="#渲染数组元素" class="headerlink" title="渲染数组元素"></a>渲染数组元素</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Reacr</span> <span class="keyword">from</span> <span class="string">&#x27;reacr&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">listElement</span>:<span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> list  = [</span><br><span class="line">        <span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;py&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;ts&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        	<span class="tag">&lt;<span class="name">ul</span>&gt;</span> &#123;list.map((item, index, array)=&gt;<span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span> )&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="为什么使用map-时需要key"><a href="#为什么使用map-时需要key" class="headerlink" title="为什么使用map() 时需要key"></a>为什么使用map() 时需要key</h4><p>可以帮助React确定元素的更改，添加，或移动等操作。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Reacr</span> <span class="keyword">from</span> <span class="string">&#x27;reacr&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">listElement</span>:<span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> list  = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">        	<span class="attr">lang</span>: <span class="string">&#x27;js&#x27;</span></span><br><span class="line">    	&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">lang</span>: <span class="string">&#x27;py&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">       	&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">lang</span>: <span class="string">&#x27;ts&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        	<span class="tag">&lt;<span class="name">ul</span>&gt;</span> &#123;list.map((item, index, array)=&gt;(</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">item.id</span>&#125;`&#125;&gt;</span>&#123;item.lang&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span> )&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h4><p><strong>受控组件</strong></p>
<p>受控组件是指在组件的状态与表单元素的值之间存在严格的联系的组件。</p>
<ul>
<li>表单元素的值由组件状态控制。</li>
<li>通过事件处理程序（如 <code>onChange</code>）更新状态。</li>
<li>组件对输入值的控制使得表单具有更强的可预测性和可控性。</li>
</ul>
<p><strong>非受控组件</strong></p>
<p>非受控组件是指组件的状态不通过 React 的状态来管理，而是使用 React 的 <code>ref</code> 来直接访问 DOM 元素的值。</p>
<ul>
<li>表单元素的值直接在 DOM 中存储，而不是节点状态。</li>
<li>可以通过 <code>ref</code> 来访问和获取输入值。</li>
<li>更适合于表单逻辑较简单的场景或不需要对每次输入进行实时验证的情况。</li>
</ul>
<h4 id="如何实现移除定时器"><a href="#如何实现移除定时器" class="headerlink" title="如何实现移除定时器"></a>如何实现移除定时器</h4><p>在 React 中，移除定时器通常需要在组件卸载时进行操作。在类组件中你可以利用 React 提供的生命周期方法 <code>componentWillUnmount</code> 来实现移除定时器的功能。在函数组件中可以利用useEffect hooks 的回调函数进行移除</p>
<h4 id="react-组件通信"><a href="#react-组件通信" class="headerlink" title="react 组件通信"></a>react 组件通信</h4><p><strong>父子组件通信</strong></p>
<ul>
<li><strong>Props：</strong><ul>
<li>父组件通过 <code>props</code> 向子组件传递数据。</li>
</ul>
</li>
<li><strong>回调函数</strong>：<ul>
<li>子组件通过调用父组件传递的回调函数来向父组件传递数据。</li>
</ul>
</li>
</ul>
<p><strong>兄弟组件通信</strong></p>
<ul>
<li><strong>通过父组件</strong>：<ul>
<li>兄弟组件通过共同的父组件进行通信，即父组件管理兄弟组件的状态。</li>
</ul>
</li>
<li><strong>Context API</strong><ul>
<li>用于跨组件传递数据，而不需要通过每一级组件传递 props。</li>
</ul>
</li>
</ul>
<p><strong>Event Emitters</strong></p>
<ul>
<li>可以使用事件发射器模式来实现组件间的通信，尽管这在 React 中不太常见，通常还是倾向于使用 React 的内建机制。</li>
</ul>
<p><strong>Refs</strong></p>
<ul>
<li>通过 <code>ref</code> 可以直接访问子组件的实例方法或属性，但这种方式不太符合 React 的数据流理念，需谨慎使用。</li>
</ul>
<p><strong>React hooks</strong> (自定义 hooks)</p>
<ul>
<li>创建自定义 hooks 以共享逻辑和状态。</li>
</ul>
<h4 id="hooks-useState有什么特点"><a href="#hooks-useState有什么特点" class="headerlink" title="hooks - useState有什么特点"></a>hooks - useState有什么特点</h4><p>useState 返回一个状态值和一个更新函数</p>
<p>在初始化渲染期间，返回的状态与初始匹配。使用更新函数进行状态更新时，采用新状态值作为参数，进行异步更新，重新渲染不会触发useState API。更新函数还可以接受函数返回值的方式。</p>
<p>react18，将所有事件都进行批处理，即多次setState会被合并为1次执行，提高了性能，在数据层，将多个状态更新合并成一次处理（在视图层，将多次渲染合并成一次渲染）</p>
<h4 id="hooks-useEffect有什么特点"><a href="#hooks-useEffect有什么特点" class="headerlink" title="hooks - useEffect有什么特点"></a>hooks - useEffect有什么特点</h4><p>useEffect钩子允许在功能组件中执行副作用，，例如数据获取、订阅、手动操作 DOM 等。它使你能够在函数组件中处理这些副作用，同时保留组件的声明式架构。</p>
<ul>
<li>第一个参数是一个函数，执行副作用的代码。</li>
<li>第二个参数是一个数组，指定了依赖项。只有当依赖项发生变化时，副作用才会重新执行。</li>
</ul>
<p><strong>作用的执行时机</strong></p>
<p><code>useEffect</code> 在组件的生命周期中执行的时机如下：</p>
<ul>
<li><strong>组件挂载时</strong>：当组件首次渲染到 UI 上时。</li>
<li><strong>依赖项变化时</strong>：如果指定了依赖项数组，当数组中的某个值发生变化时，<code>useEffect</code> 会重新执行。</li>
<li><strong>组件卸载时</strong>：如果提供了清理函数，它会在组件卸载或依赖项变化时调用。</li>
</ul>
<p><strong>依赖数组</strong></p>
<p>当依赖数组为空时，<code>useEffect</code> 只在组件挂载时执行一次，类似于 class 组件的 <code>componentDidMount</code>。<br>如果依赖数组中包含状态或 props，副作用将在组件挂载和依赖项变化时执行。<br>如果不提供依赖数组，<code>useEffect</code> 将在每次渲染后执行，这可能导致性能问题。</p>
<h4 id="hooks-useMemo用途？如何工作？"><a href="#hooks-useMemo用途？如何工作？" class="headerlink" title="hooks - useMemo用途？如何工作？"></a>hooks - useMemo用途？如何工作？</h4><p>用于缓存计算结构。useMemo仅在任何依赖项的值发生变化时，才会重新计算记忆值。这种优化可以帮助一些复杂，消耗性能较高的计算<br>第一个参数，接受一个执行计算的回调<br>第二个参数，接受依赖关系数组，只有至少一个依赖关系发生变化时，才会触发重新执行</p>
<h4 id="hooks-useCallback用途？如何工作？"><a href="#hooks-useCallback用途？如何工作？" class="headerlink" title="hooks - useCallback用途？如何工作？"></a>hooks - useCallback用途？如何工作？</h4><h4 id="hooks-useMemo和useCallback有什么区别"><a href="#hooks-useMemo和useCallback有什么区别" class="headerlink" title="hooks - useMemo和useCallback有什么区别"></a>hooks - useMemo和useCallback有什么区别</h4><ol>
<li>useMemo： 用于缓存计算结果，而useCallback用于缓存函数本身</li>
<li>useMemo： 如果依赖项未更改，则缓存计算值并在后续渲染时返回该值</li>
<li>useCallback：缓存函数本身并返回相同实例，出非依赖项更改</li>
</ol>
<h4 id="hooks-useContext用途-如何工作"><a href="#hooks-useContext用途-如何工作" class="headerlink" title="hooks - useContext用途? 如何工作?"></a>hooks - useContext用途? 如何工作?</h4><p>React应用程序中，数据是从父组件到子组件传递。如果较深层的组件需要使用到该porps，就会嵌套很多层props，过程过于繁琐。而Context上下文，提供了在组件之间共享数据的方法，无需明确的传递props到每一层。<br>当上下文值发生改变时，useContext组件总是会重新渲染。</p>
<h4 id="hooks-useRef-用途？作用？"><a href="#hooks-useRef-用途？作用？" class="headerlink" title="hooks - useRef 用途？作用？"></a>hooks - useRef 用途？作用？</h4><p>useRef返回一个可以修改的ref对象，即一个属性。该对象当前值有传递的参数进行初始化。返回对象将在整个组件生命周期中持续存在。</p>
<h4 id="什么是React-memo"><a href="#什么是React-memo" class="headerlink" title="什么是React.memo()"></a>什么是React.memo()</h4><p>React.memo() 是一个高阶组件。如果组件总是不变，渲染相同内容。可以在某些情况下将其封装在React.mome() 中调用，避免重新渲染以提高性能。如果React.memo() 组件中使用了useState，useReducer，useContext，那么当状态或上下文发生变化时，也会重新渲染</p>
<h4 id="什么是React-Fragment"><a href="#什么是React-Fragment" class="headerlink" title="什么是React Fragment"></a>什么是React Fragment</h4><p>从组件返回多个元素是React常见做法。片段允许形成子元素列表，而无需再DOM中创建不必要的节点</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">frag</span>(<span class="params"></span>)&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son1</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son2</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"></span><br><span class="line">    &lt;!-- or --&gt;</span><br><span class="line">    &lt;<span class="title class_">React</span>.<span class="property">Fragment</span>&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Son1</span>/&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Son2</span>/&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="如何跟踪引用功能组件中对象字段的变化"><a href="#如何跟踪引用功能组件中对象字段的变化" class="headerlink" title="如何跟踪引用功能组件中对象字段的变化"></a>如何跟踪引用功能组件中对象字段的变化</h4><p>使用useEffect钩子，将对象字段作为依赖数组传递，每次渲染后会重新获取对象字段</p>
<h4 id="如何访问DOM元素"><a href="#如何访问DOM元素" class="headerlink" title="如何访问DOM元素"></a>如何访问DOM元素</h4><p>使用 React.createRef() 或 useRef(), 之后通过ref.current 获取元素属性</p>
<p><strong>Redux 或其他状态管理库</strong></p>
<ul>
<li>用于管理应用程序的全局状态，并在不同组件之间进行通信。</li>
<li>适合中大型应用程序，具有复杂状态管理需求</li>
</ul>
<h4 id="react合成事件，为什么不使用浏览器原生事件，出发点是什么，考虑什么"><a href="#react合成事件，为什么不使用浏览器原生事件，出发点是什么，考虑什么" class="headerlink" title="react合成事件，为什么不使用浏览器原生事件，出发点是什么，考虑什么"></a>react合成事件，为什么不使用浏览器原生事件，出发点是什么，考虑什么</h4><ol>
<li><p><strong>跨浏览器兼容性</strong>：</p>
<ul>
<li>不同浏览器对事件的实现和行为可能存在差异。通过合成事件，React 确保了在所有主流浏览器中事件处理的一致性，简化了开发者的工作。</li>
</ul>
</li>
<li><p><strong>性能优化</strong>：</p>
<ul>
<li>合成事件在 React 内部通过池化（event pooling）机制来管理事件。即在事件处理后，合成事件对象会被重用，减少了内存的分配和垃圾回收，提高了性能。</li>
</ul>
</li>
<li><p><strong>统一的 API</strong>：</p>
<ul>
<li>使用合成事件，React 提供了一个统一的事件处理接口，所有事件在 React 中的行为和属性是一致的。这对于开发者来说，提升了代码的可读性和可维护性。</li>
</ul>
</li>
<li><p><strong>事件生命周期管理</strong>：</p>
<ul>
<li>React 能够更好地控制事件的生命周期。这允许 React 在组件的卸载和更新过程中做出更智能的管理，避免了潜在的内存泄漏问题。</li>
</ul>
</li>
<li><p><strong>与 React 生态系统的集成</strong>：</p>
<ul>
<li>合成事件使得事件处理和 React 的整体运行机制能够更紧密地集成。比如，React 能够在事件处理过程中进行一系列优化、调度和协调操作。</li>
</ul>
</li>
<li><p><strong>简化处理逻辑</strong>：</p>
<ul>
<li>合成事件的 API 被设计得更易用，尤其是在处理高阶组件和函数组件时。合成事件使得这些情况的事件处理变得更简单。</li>
</ul>
</li>
<li><p><strong>支持新的功能</strong>：</p>
<ul>
<li>通过合成事件，React 能够更灵活地支持一些新的功能，比如暂停和恢复事件的处理，或在切换到并发模式时更好地处理事件。</li>
</ul>
</li>
</ol>
<h4 id="react18新特性"><a href="#react18新特性" class="headerlink" title="react18新特性"></a>react18新特性</h4><ul>
<li><strong>去掉了对IE浏览器的支持</strong></li>
<li><strong>事件自动批处理（Automatic Batching）</strong>：React 18 中的自动批处理允许多个状态更新被智能地合并在一起，从而减少组件的重新渲染次数。这意味着即使在异步代码中，多个状态更新也会自动批处理，提高性能。</li>
<li><strong>开始并发模式（Concurrent Rendering）</strong>：React 18 引入了并发特性，使得渲染可以被中断，以便于高优先级的更新。这样可以确保用户界面在处理复杂更新时保持响应性。</li>
<li><strong><code>Suspense</code> 组件的增强</strong>：React 18 扩展了 <code>Suspense</code> 的功能，使其不仅可以用于数据加载，还可以与并发特性结合使用。允许开发者在异步数据加载时更优雅地控制加载状态。</li>
<li><strong><code>useTransition</code> Hook</strong>：新增 <code>useTransition</code> API 来标记状态更新为过渡更新。这使得开发者可以在需要时为用户界面保留流畅性和响应性，尤其是在使用状态更新时。</li>
<li><strong><code>useDeferredValue</code> Hook</strong>：这个 Hook 允许开发者将一个状态值的更新延后一段时间，从而优化用户界面的响应。在输入框中输入文字时，可以实现更平滑的体验。</li>
<li><strong><code>startTransition</code> API</strong>：这个 API 允许开发者将某些更新标记为不紧急的，从而让 React 更加智能地管理其渲染优先级。</li>
<li><strong>全新的 <code>createRoot</code> API</strong>：React 18 引入了 <code>createRoot</code> 方法，用于挂载 React 应用的新根实例。这是采用并发特性的新推荐方式。</li>
<li><strong><code>Concurrent Features</code>的支持</strong>：React 18 允许开发者通过 <code>use</code> 和 <code>Suspense</code> 结合使用小的惰性加载逻辑，提高应用的数据获取效率和界面的可交互性。</li>
<li><strong>新特性的无缝过渡</strong>：React 18 支持在现有代码中逐步过渡到新特性，降低了更新的复杂性。</li>
</ul>
<h4 id="React-diff-算法介绍"><a href="#React-diff-算法介绍" class="headerlink" title="React diff 算法介绍"></a>React diff 算法介绍</h4><ol>
<li><strong>虚拟 DOM</strong></li>
</ol>
<p>在 React 中，每个组件都有一个对应的虚拟 DOM 树。当状态改变时，React 会重新构建新的虚拟 DOM 树。这个虚拟 DOM 是一个轻量级的 JavaScript 对象，它包含了整个真实 DOM 树的映射关系。</p>
<ol start="2">
<li><strong>Diff 算法</strong></li>
</ol>
<p>在重新构建新的虚拟DOM树后，React 使用 diff 算法来比较新旧两棵虚拟 DOM 树，并找出最小操作来更新实际的页面DOM树。</p>
<ul>
<li>属性和事件处理函数变化</li>
</ul>
<p>如果节点类型相同（比如都是 <code>div</code> 元素），但属性或事件处理函数发生了变化，则需要更新该节点上相应属性或事件处理函数。</p>
<ul>
<li>组件类型变化</li>
</ul>
<p>如果节点由组件A变成了另一个不同类型的组件B，则旧节点需要被销毁并且新节点需要创建。</p>
<ul>
<li>列表元素遍历</li>
</ul>
<p>Diff算法会遍历列表元素，准确找出哪些地方增加、删除、移动或更新了列表中的子元素。</p>
<ol start="3">
<li><p>Diff 策略</p>
<p>在进行Diff算法时，React采用以下策略：</p>
<ul>
<li><strong>深度优先遍历</strong>：React使用深度优先策略来递归比较两棵虚拟DOM树。</li>
<li><strong>双端比较</strong>：从头部和尾部同时开始比较子元素列表，在某些情况下可以大幅减少移动操作次数。</li>
<li><strong>Key属性</strong>：当为列表渲染添加唯一key属性时（通常使用数据中唯一ID），可以帮助React识别具体哪些项目被添加、删除、移动或更新。</li>
<li><strong>批量执行</strong>：将多次修改合并为一次性修改以提高性能。</li>
</ul>
</li>
</ol>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><h4 id="什么是Redux"><a href="#什么是Redux" class="headerlink" title="什么是Redux"></a>什么是Redux</h4><h4 id="Redux有什么优点"><a href="#Redux有什么优点" class="headerlink" title="Redux有什么优点"></a>Redux有什么优点</h4><h4 id="Redux-遵循的三个原则是什么"><a href="#Redux-遵循的三个原则是什么" class="headerlink" title="Redux 遵循的三个原则是什么"></a>Redux 遵循的三个原则是什么</h4><h4 id="对-“单一事实来源”-有什么理解"><a href="#对-“单一事实来源”-有什么理解" class="headerlink" title="对 “单一事实来源” 有什么理解"></a>对 “单一事实来源” 有什么理解</h4><h4 id="列出-Redux-组件"><a href="#列出-Redux-组件" class="headerlink" title="列出 Redux 组件"></a>列出 Redux 组件</h4><h4 id="数据如何通过-Redux-流动"><a href="#数据如何通过-Redux-流动" class="headerlink" title="数据如何通过 Redux 流动"></a>数据如何通过 Redux 流动</h4><h4 id="如何在Redux中定义Action"><a href="#如何在Redux中定义Action" class="headerlink" title="如何在Redux中定义Action"></a>如何在Redux中定义Action</h4><h4 id="解释Reducer的作用"><a href="#解释Reducer的作用" class="headerlink" title="解释Reducer的作用"></a>解释Reducer的作用</h4><h4 id="Store在Redux中的意义是什么"><a href="#Store在Redux中的意义是什么" class="headerlink" title="Store在Redux中的意义是什么"></a>Store在Redux中的意义是什么</h4><h4 id="Redux与Flux有什么不同"><a href="#Redux与Flux有什么不同" class="headerlink" title="Redux与Flux有什么不同"></a>Redux与Flux有什么不同</h4><h4 id="Redux-的核心概念包括-Store、Action、Reducer-和-Middleware。"><a href="#Redux-的核心概念包括-Store、Action、Reducer-和-Middleware。" class="headerlink" title="Redux 的核心概念包括 Store、Action、Reducer 和 Middleware。"></a>Redux 的核心概念包括 Store、Action、Reducer 和 Middleware。</h4><ol>
<li>Store</li>
</ol>
<p>Redux 中的 Store 是单一状态树，存储着整个应用的状态。可以通过 <code>createStore</code> 函数来创建一个 Store。</p>
<ol start="2">
<li>Action</li>
</ol>
<p>Action 是一个包含描述动作类型和负载数据的简单对象。它要求使用纯函数形式来描述对应操作，通常由 action creator 函数来创建。</p>
<ol start="3">
<li>Reducer</li>
</ol>
<p>Reducer 是一个纯函数，它接收先前的状态和 action，并返回新的状态。Reducer 定义了如何更新应用程序中相关部分的状态。</p>
<ol start="4">
<li>Dispatch</li>
</ol>
<p>Dispatch 是 store 对象提供的方法，用于触发 action 的执行并更新应用程序中相应部分的状态。</p>
<ol start="5">
<li>Middleware</li>
</ol>
<p>Middleware 允许你扩展 Redux 功能，在 action 触发到达 reducer 前进行额外处理或拦截操作。比如日志记录、异步操作等都可以通过 middleware 来实现。</p>
<p><strong>工作流程</strong></p>
<ol>
<li><strong>组件发起 Action</strong>：组件调用 <code>dispatch</code> 方法发送一个 action 到 store。</li>
<li><strong>Store 分发 Action</strong>：store 接收到 action 后将其传递给 reducer 进行处理。</li>
<li><strong>Reducer 更新 State</strong>：reducer 根据接收到的action类型以及负载数据来计算出新的 state。</li>
<li><strong>Store 更新订阅者</strong>：store 的 state 更新后会通知所有订阅者（比如 React 组件），从而重新渲染页面以反映最新 state。</li>
</ol>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><h4 id="什么是-Webpack？"><a href="#什么是-Webpack？" class="headerlink" title="什么是 Webpack？"></a>什么是 Webpack？</h4><p>Webpack 是一个前端构建工具，它将不同类型的资源（JavaScript、CSS、图片等）视为模块，通过分析模块间的依赖关系，将它们打包成一个或多个静态文件，以提高Web应用的加载速度和性能。</p>
<h4 id="Webpack-的核心概念有哪些？"><a href="#Webpack-的核心概念有哪些？" class="headerlink" title="Webpack 的核心概念有哪些？"></a>Webpack 的核心概念有哪些？</h4><ul>
<li><strong>入口（Entry）</strong>：指示 Webpack 从哪里开始构建依赖图，入口文件是应用的起点。</li>
<li><strong>输出（Output）</strong>：定义 Webpack 打包后的文件存放位置和命名规则。</li>
<li><strong>加载器（Loader）</strong>：允许 Webpack 处理非 JavaScript 文件（比如 CSS、图片、类型脚本等），将这些文件转换为模块。</li>
<li><strong>插件（Plugin）</strong>：可以扩展 Webpack 的功能，用于执行范围更广的任务，如代码压缩、提取 CSS 等。</li>
<li><strong>模块（Module）</strong>：Webpack 将文件视为模块，通过依赖管理实现模块化。</li>
</ul>
<h4 id="webpack-打包过程"><a href="#webpack-打包过程" class="headerlink" title="webpack 打包过程"></a>webpack 打包过程</h4><ol>
<li><strong>解析入口文件</strong>：Webpack从入口文件开始，通过解析入口文件中的依赖关系来构建应用程序的依赖图。Webpack支持多种模块类型，包括CommonJS、ES6模块、AMD等。</li>
<li><strong>加载模块</strong>：Webpack使用加载器（Loader）来处理不同类型的模块。加载器可以将模块转换为Webpack可识别的模块格式，并且可以在加载模块时执行一些额外的操作，如代码转换、压缩等。</li>
<li><strong>生成代码块</strong>：Webpack将所有模块打包成一个或多个代码块（Chunk）。代码块是一组相关的模块，它们被组合在一起以便于加载和执行。Webpack使用代码分割（Code Splitting）技术来将代码块拆分成更小的块，以便于并行加载和执行。</li>
<li><strong>代码块转换为资源文件</strong>：Webpack将代码块转换为静态资源文件，如JavaScript文件、CSS文件、图片等。Webpack使用插件（Plugin）来处理资源文件，如压缩、优化等。</li>
<li><strong>输出打包文件</strong>：最后，Webpack将所有资源文件打包成一个或多个输出文件。输出文件可以是单个JavaScript文件、多个JavaScript文件、CSS文件、图片等。Webpack使用输出配置（Output Configuration）来指定输出文件的名称、路径等。</li>
</ol>
<h4 id="如何配置-Webpack-的输出选项？"><a href="#如何配置-Webpack-的输出选项？" class="headerlink" title="如何配置 Webpack 的输出选项？"></a>如何配置 Webpack 的输出选项？</h4><p>在 <code>webpack.config.js</code> 中可以这样配置输出选项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;  </span><br><span class="line">    <span class="attr">output</span>: &#123;  </span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,  </span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),  </span><br><span class="line">    &#125;,  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>



<h4 id="什么是-Loader，举几个常见的例子？"><a href="#什么是-Loader，举几个常见的例子？" class="headerlink" title="什么是 Loader，举几个常见的例子？"></a>什么是 Loader，举几个常见的例子？</h4><p>Loader 是用于将不同类型的文件转换为模块的工具。常见的 Loader 包括：</p>
<ul>
<li><code>babel-loader</code>：将 ES6&#x2F;ES7 等语法转换为 ES5。</li>
<li><code>css-loader</code>：使 Webpack 能够理解 <code>@import</code> 和 <code>url()</code>。</li>
<li><code>style-loader</code>：将 CSS 插入 <code>&lt;script&gt;</code> 标签中。</li>
<li><code>file-loader</code>：处理文件和图像，返回 URL。</li>
</ul>
<h4 id="什么是插件，如何使用它？"><a href="#什么是插件，如何使用它？" class="headerlink" title="什么是插件，如何使用它？"></a>什么是插件，如何使用它？</h4><p>插件是用于扩展 Webpack 功能的插件。可以用来进行文件优化、代码压缩等。使用方式通常是在 <code>webpack.config.js</code> 中的 <code>plugins</code> 数组中引入。例如，使用 <code>HtmlWebpackPlugin</code> 插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);  </span><br><span class="line"></span><br><span class="line">module.exports = &#123;  </span><br><span class="line">    plugins: [  </span><br><span class="line">        new HtmlWebpackPlugin(&#123;  </span><br><span class="line">            template: &#x27;src/index.html&#x27;,  </span><br><span class="line">        &#125;),  </span><br><span class="line">    ],  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>



<h4 id="Webpack-中的热模块替换（Hot-Module-Replacement-HMR）是什么？"><a href="#Webpack-中的热模块替换（Hot-Module-Replacement-HMR）是什么？" class="headerlink" title="Webpack 中的热模块替换（Hot Module Replacement, HMR）是什么？"></a>Webpack 中的热模块替换（Hot Module Replacement, HMR）是什么？</h4><p>HMR 是一种在运行时更新已被修改的模块，而不需要完全刷新页面的技术。这样可以大大提高开发效率。启用 HMR 通常需要配置 devServer，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;  </span><br><span class="line">    hot: true,  </span><br><span class="line">&#125;,  </span><br></pre></td></tr></table></figure>



<h4 id="如何实现代码分割？"><a href="#如何实现代码分割？" class="headerlink" title="如何实现代码分割？"></a>如何实现代码分割？</h4><p>代码分割可以通过使用动态导入（<code>import()</code>）来实现，Webpack 会自动将模块拆分成多个文件。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import(/* webpackChunkName: &quot;my-chunk-name&quot; */ &#x27;./my-module&#x27;)  </span><br><span class="line">    .then(module =&gt; &#123;  </span><br><span class="line">        // 使用模块  </span><br><span class="line">    &#125;);  </span><br></pre></td></tr></table></figure>



<h4 id="解释一下-Webpack-的四个生命周期钩子。"><a href="#解释一下-Webpack-的四个生命周期钩子。" class="headerlink" title="解释一下 Webpack 的四个生命周期钩子。"></a>解释一下 Webpack 的四个生命周期钩子。</h4><ul>
<li>**<code>initialize</code>**：Webpack 初始化的阶段。</li>
<li>**<code>compile</code>**：在构建过程中，模块准备被打包。</li>
<li>**<code>emit</code>**：在生成资源文件之前，Webpack 可以修改生成的文件。</li>
<li>**<code>done</code>**：所有编译完成后的阶段，进行最终的回调操作。</li>
</ul>
<h4 id="如何在生产环境和开发环境中配置-Webpack？"><a href="#如何在生产环境和开发环境中配置-Webpack？" class="headerlink" title="如何在生产环境和开发环境中配置 Webpack？"></a>如何在生产环境和开发环境中配置 Webpack？</h4><p>通常可以创建两个配置文件 <code>webpack.dev.js</code> 和 <code>webpack.prod.js</code>，在开发阶段可以启用热模块替换和源代码映射，而生产阶段则可以启用压缩和优化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js  </span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;  </span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,  </span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span>,  </span><br><span class="line">    <span class="comment">// 其他开发环境配置  </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.prod.js  </span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;  </span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,  </span><br><span class="line">    <span class="attr">optimization</span>: &#123;  </span><br><span class="line">        <span class="attr">minimize</span>: <span class="literal">true</span>,  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="comment">// 其他生产环境配置  </span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>



<h4 id="模块化-Commonjs，AMD，CMD，UMD，ES6-Module分别有什么区别"><a href="#模块化-Commonjs，AMD，CMD，UMD，ES6-Module分别有什么区别" class="headerlink" title="模块化 Commonjs，AMD，CMD，UMD，ES6 Module分别有什么区别"></a>模块化 Commonjs，AMD，CMD，UMD，ES6 Module分别有什么区别</h4><p><strong>CommonJS</strong></p>
<p>CommonJS 是一种模块化规范，主要用于服务器端的 JavaScript( Node环境)。它的特点是：</p>
<ul>
<li>使用 <code>require()</code> 方法加载模块。</li>
<li>使用 <code>module.exports</code> 导出模块。</li>
<li>同步加载模块，即在代码执行时立即加载模块。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入模块  </span></span><br><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块  </span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;  </span><br><span class="line">  <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> math.<span class="title function_">add</span>(a, b);  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="attr">subtract</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> math.<span class="title function_">subtract</span>(a, b);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p><strong>AMD</strong></p>
<p>AMD（Asynchronous Module Definition）是一种异步加载模块的规范，主要用于浏览器端的 JavaScript。它的特点是：</p>
<ul>
<li>使用 <code>define()</code> 方法定义模块。</li>
<li>使用 <code>require()</code> 方法异步加载模块。</li>
<li>支持在浏览器端异步加载模块，避免了阻塞页面加载的问题。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块  </span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;math&#x27;</span>], <span class="keyword">function</span>(<span class="params">math</span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> &#123;  </span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> math.<span class="title function_">add</span>(a, b);  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="attr">subtract</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> math.<span class="title function_">subtract</span>(a, b);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步加载模块  </span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;calculator&#x27;</span>], <span class="keyword">function</span>(<span class="params">calculator</span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(calculator.<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>));  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<p><strong>CMD</strong></p>
<p>CMD（Common Module Definition）是一种类似于 AMD 的模块化规范，主要用于浏览器端的 JavaScript。它的特点是：</p>
<ul>
<li>使用 <code>define()</code> 方法定义模块。</li>
<li>使用 <code>require()</code> 方法异步加载模块。</li>
<li>支持在浏览器端异步加载模块，避免了阻塞页面加载的问题。</li>
<li>与 AMD 不同的是，CMD 是在需要使用模块时才加载模块，而不是在页面加载时就加载所有模块。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块  </span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;  </span><br><span class="line">  <span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>);  </span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> math.<span class="title function_">add</span>(a, b);  </span><br><span class="line">  &#125;;  </span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">subtract</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> math.<span class="title function_">subtract</span>(a, b);  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步加载模块  </span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;calculator&#x27;</span>], <span class="keyword">function</span>(<span class="params">calculator</span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(calculator.<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>));  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<p><strong>UMD</strong></p>
<p>UMD（Universal Module Definition）是一种通用的模块化规范，可以同时支持 CommonJS、AMD 和全局变量的方式。它的特点是：</p>
<ul>
<li>先判断是否支持 CommonJS，如果支持则使用 CommonJS 规范加载模块。</li>
<li>如果不支持 CommonJS，则判断是否支持 AMD，如果支持则使用 AMD 规范加载模块。</li>
<li>如果既不支持 CommonJS 也不支持 AMD，则将模块作为全局变量加载。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">root, factory</span>) &#123;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;  </span><br><span class="line">    <span class="comment">// AMD  </span></span><br><span class="line">    <span class="title function_">define</span>([<span class="string">&#x27;math&#x27;</span>], factory);  </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;  </span><br><span class="line">    <span class="comment">// CommonJS  </span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>));  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// 全局变量  </span></span><br><span class="line">    root.<span class="property">calculator</span> = <span class="title function_">factory</span>(root.<span class="property">math</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;(<span class="variable language_">this</span>, <span class="keyword">function</span>(<span class="params">math</span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> &#123;  </span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> math.<span class="title function_">add</span>(a, b);  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="attr">subtract</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> math.<span class="title function_">subtract</span>(a, b);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;));  </span><br></pre></td></tr></table></figure>

<p><strong>ES6 Module</strong></p>
<p>ES6 Module 是 ECMAScript 6 标准中新增的模块化规范，主要用于浏览器端和服务器端的 JavaScript。它的特点是：</p>
<ul>
<li>使用 <code>import</code> 和 <code>export</code> 关键字导入和导出模块。</li>
<li>支持静态分析，可以在编译时确定模块的依赖关系。</li>
<li>支持异步加载模块。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入模块  </span></span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块  </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> math.<span class="title function_">add</span>(a, b);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> math.<span class="title function_">subtract</span>(a, b);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>





<h4 id="webpack能处理什么文件，不能处理什么文件"><a href="#webpack能处理什么文件，不能处理什么文件" class="headerlink" title="webpack能处理什么文件，不能处理什么文件"></a>webpack能处理什么文件，不能处理什么文件</h4><p><strong>Webpack 能处理的文件类型</strong></p>
<ol>
<li><strong>JavaScript 文件</strong>：Webpack 可以处理 ES6、CommonJS、AMD 等模块化标准的 JavaScript 文件，并可以通过 <code>babel-loader</code> 转换 ES6+ 代码。</li>
<li><strong>CSS 文件</strong>：可以通过 <code>css-loader</code> 和 <code>style-loader</code> 处理 CSS 文件，还可以处理 SASS、LESS 等预处理样式。</li>
<li><strong>图像和字体文件</strong>：通过 <code>file-loader</code> 和 <code>url-loader</code>，Webpack 可以处理 JPEG、PNG、SVG 等图像文件，以及 TTF、WOFF、WOFF2 等字体文件。</li>
<li><strong>HTML 文件</strong>：通过 <code>html-webpack-plugin</code> 插件，Webpack 可以处理 HTML 文件，并自动插入生成的 JavaScript 和 CSS 文件。</li>
<li><strong>JSON 文件</strong>：Webpack 能够直接处理和导入 JSON 文件。</li>
<li><strong>其他文件</strong>：可以使用特定的 loader 处理其他类型的文件，如 Markdown、XML、YAML 等。</li>
</ol>
<p><strong>Webpack 不能处理的文件类型</strong></p>
<ol>
<li><strong>原生代码</strong>：如 C、C++ 等编写的代码，Webpack 并没有内置支持，需要借助额外工具来编译。</li>
<li><strong>特定的非模块化文件</strong>：如某些二进制文件、视频文件等，Webpack 虽然可以通过 loader 处理，但并不适合直接用于打包。</li>
<li><strong>大型项目中的超高复杂度文件</strong>：在某些情况下，大型项目中的文件结构过于复杂可能需要自定义解决方案，Webpack 可能不是最佳选择。</li>
</ol>
<h4 id="webpack-处理性能优化"><a href="#webpack-处理性能优化" class="headerlink" title="webpack 处理性能优化"></a>webpack 处理性能优化</h4><p><strong>代码分割（Code Splitting）</strong></p>
<ul>
<li><strong>动态导入</strong>：使用 <code>import()</code> 动态导入模块，按需加载，减少初始加载体积。</li>
<li><strong>Entry Points</strong>：将应用程序的不同部分分成不同的入口点，以便每个入口点只加载其所需的依赖。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：动态导入  </span></span><br><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;my-button&#x27;</span>);  </span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./module.js&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">module</span> =&gt;</span> &#123;  </span><br><span class="line">        <span class="variable language_">module</span>.<span class="title function_">doSomething</span>();  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<p><strong>Tree Shaking</strong></p>
<ul>
<li><p>Tree Shaking 是一种静态分析技术，旨在减少打包文件的大小。它的核心目标是从最终的捆绑结果中删除未被引用的模块或导出。通过这种方式，开发者可以避免在生产环境中载入多余的代码，从而提高性能和加载速度。</p>
</li>
<li><p><strong>工作原理</strong></p>
<p>Tree Shaking 依赖于 ES6 模块系统（即使用 <code>import</code> 和 <code>export</code> 语法），这是因为这种系统具有静态结构，能够在编译时进行更好的分析。以下是主要原因：</p>
<ul>
<li><strong>静态分析</strong>：由于模块导入和导出在编译时是已知的，Webpack 和其他打包工具能够分析哪些模块被使用，哪些没有。</li>
<li><strong>明确的引用</strong>：与 CommonJS 这样的动态加载方式不同，ES6 语法明确声明了模块的依赖</li>
</ul>
</li>
<li><p><strong>步骤</strong></p>
<ol>
<li><strong>解析代码</strong>：打包工具解析应用程序的代码，构建模块的依赖图。</li>
<li><strong>分析使用情况</strong>：查找哪些模块和导出实际被使用，哪些是未使用的“死代码”。</li>
<li><strong>删除未使用的代码</strong>：在生成最终的捆绑文件之前，去除未被引用的模块和导出</li>
</ol>
</li>
<li><p><strong>副作用</strong></p>
<p>一些代码可能会有副作用，例如修改全局变量、添加事件监听等。为了安全地使用 Tree Shaking，建议在 <code>package.json</code> 文件中明确指定哪些模块是有副作用的，或者通过 <code>sideEffects: false</code> 来声明整个库没有副作用。</p>
</li>
</ul>
<p><strong>减少打包体积</strong></p>
<ul>
<li>**使用 <code>TerserPlugin</code>**：压缩和优化 JS 文件。</li>
<li><strong>移除未使用的依赖</strong>：检查包并移除不必要的依赖。</li>
</ul>
<p><strong>使用 DllPlugin</strong></p>
<ul>
<li>将不频繁变动的依赖这些库单独打包，从而提高整体打包速度。</li>
</ul>
<p><strong>图片和资源优化</strong></p>
<ul>
<li>使用 <code>image-webpack-loader</code> 对图片进行压缩和优化，减少其体积，进而提高加载速度。</li>
<li>通过 <code>file-loader</code> 或 <code>url-loader</code> 根据文件大小进行合理的打包和加载。</li>
</ul>
<p><strong>CSS优化</strong></p>
<ul>
<li>使用 <code>MiniCssExtractPlugin</code> 将 CSS 分离到单独的文件中，减少 JS 文件的体积，提高加载速度。</li>
<li>避免在 CSS 中使用过大的背景图，考虑加载替代图像的方式。</li>
</ul>
<p><strong>使用预取和懒加载</strong></p>
<ul>
<li>使用 Webpack 的 <code>Prefetch</code> 功能，让某些较大的资源在空闲时预加载。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 示例：在 Webpack 中启用 Prefetch  </span><br><span class="line">import(/* webpackPrefetch: true */ &#x27;./module.js&#x27;);  </span><br></pre></td></tr></table></figure>

<p><strong>开启长缓存</strong></p>
<ul>
<li>使用 <code>contenthash</code> 指定生成文件的名称，使文件在更新后才能发生变化，从而使 CDN 缓存更高效。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;  </span><br><span class="line">    filename: &#x27;[name].[contenthash].js&#x27;,  </span><br><span class="line">    path: path.resolve(__dirname, &#x27;dist&#x27;),  </span><br><span class="line">&#125;,  </span><br></pre></td></tr></table></figure>

<p><strong>打包分析</strong></p>
<ul>
<li>使用 Webpack Bundle Analyzer 插件，分析打包后的文件，查看模块的体积，找出可以优化的部分。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-bundle-analyzer  </span><br></pre></td></tr></table></figure>

<p><strong>开发模式优化</strong></p>
<ul>
<li>在开发模式中使用 <code>webpack-dev-server</code> 或 <code>webpack-dev-middleware</code> 提高热模块替换的效率，减少不必要的完整打包。</li>
</ul>
<p><strong>使用 HTTP&#x2F;2</strong></p>
<ul>
<li>如果你服务器支持 HTTP&#x2F;2，可以并行加载多个小文件，建议保持较小的入口点。</li>
</ul>
<p><strong>减少请求数量</strong></p>
<ul>
<li>将多个 CSS 或 JS 文件合并为一个，减少初始请求的数量。</li>
</ul>
<p><strong>使用 Service Workers</strong></p>
<ul>
<li>可以将页面预加载和缓存逻辑实现到 Service Worker 中，进一步加快页面加载速度。</li>
</ul>
<h4 id="SPA首屏优化方案"><a href="#SPA首屏优化方案" class="headerlink" title="SPA首屏优化方案"></a>SPA首屏优化方案</h4><ol>
<li><p><strong>资源优化</strong></p>
<ul>
<li><strong>静态资源优化压缩</strong>：对于首屏需要的静态资源（如CSS、JavaScript、图片等），可以进行优化，如压缩、合并、缓存等。使用压缩工具可以减小文件大小，合并多个文件可以减少请求数量，使用缓存可以减少网络请求。</li>
<li><strong>使用CDN</strong>：将静态资源部署到CDN上，提高资源访问效率</li>
</ul>
</li>
<li><p><strong>减少js代码执行</strong></p>
<ul>
<li><strong>代码分割 - 按需加载&#x2F; 异步加载</strong>：使用Webpack等构建工具的代码分割功能，将应用程序的代码拆分成多个小块（chunks）。这样可以实现按需加载或异步加载，只加载当前页面所需的代码，减少首屏加载的大小和时间。</li>
<li><strong>预加载和懒加载</strong>：通过预加载和懒加载技术，可以在首屏加载完成后，异步加载其他页面所需的代码和资源。预加载可以在后台加载页面所需的资源，以提前准备好下一个页面的加载。懒加载可以延迟加载某些组件或模块，只在需要时才进行加载。</li>
</ul>
</li>
<li><p><strong>服务端渲染（SSR）</strong>：将部分页面在服务器端进行渲染，生成静态HTML返回给客户端。这样可以加快首屏加载速度，因为客户端只需要展示已经渲染好的HTML，而不需要等待JavaScript代码的下载和执行。</p>
</li>
<li><p><strong>优化网络请求</strong>：</p>
<ul>
<li><p><strong>减少请求数量</strong>：</p>
<ul>
<li>合并css和js文件，减少http请求，雪碧图&#x2F;精灵图</li>
<li>使用http&#x2F;2 ，多路复用请求</li>
</ul>
</li>
<li><p><strong>缓存</strong>：</p>
<ul>
<li>配置浏览器缓存策略：减少重复加载</li>
<li>使用service worker进行资源缓存</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>骨架屏</strong></p>
<ul>
<li>在页面加载时显示骨架屏，提升用户感知性能</li>
</ul>
</li>
<li><p><strong>优化渲染</strong></p>
<ul>
<li><strong>提前渲染</strong><ul>
<li>提前渲染关键性能：确保关键内容在html中靠前位置，优先渲染</li>
</ul>
</li>
<li><strong>渲染优化</strong><ul>
<li>避免大型DOM操作，优化渲染性能</li>
<li>使用虚拟滚动技术，优化长列表渲染</li>
</ul>
</li>
<li><strong>使用现代构建工具和技术</strong><ul>
<li>构建工具配置</li>
<li>Tree Sharking技术</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><h4 id="如何理解html，css，js"><a href="#如何理解html，css，js" class="headerlink" title="如何理解html，css，js"></a>如何理解html，css，js</h4><ol>
<li><strong>HTML</strong>：HTML（HyperText Markup Language）是一种用于创建Web页面结构的标记语言。</li>
<li><strong>CSS</strong>：CSS（Cascading Style Sheets）是一种用于控制Web页面样式的语言</li>
<li><strong>JavaScript</strong>：JavaScript是一种用于实现Web页面交互的脚本语言</li>
</ol>
<h4 id="html代码第一行有什么作用"><a href="#html代码第一行有什么作用" class="headerlink" title="html代码第一行有什么作用"></a>html代码第一行有什么作用</h4><p>告诉浏览器采用哪种HTML版本解释页面内容。不同的HTML版本有不同的规范和特性，因此通过<code>&lt;!DOCTYPE&gt;</code>声明可以确保浏览器正确地呈现页面。</p>
<h4 id="html的meta属性有哪些，都是什么作用"><a href="#html的meta属性有哪些，都是什么作用" class="headerlink" title="html的meta属性有哪些，都是什么作用"></a>html的meta属性有哪些，都是什么作用</h4><p><code>meta</code>元素是HTML中用来提供关于文档的元数据（metadata）的标签。以下是一些常见的<code>meta</code>属性及其作用：</p>
<ol>
<li><code>charset</code>: 指定文档使用的字符编码，例如UTF-8。</li>
<li><code>name=&quot;viewport&quot;</code>: 用于控制页面在移动设备上的显示，包括宽度、缩放等。</li>
<li><code>name=&quot;description&quot;</code>: 提供对文档内容的简短描述，通常被搜索引擎用于搜索结果中显示。</li>
<li><code>name=&quot;keywords&quot;</code>: 指定与文档相关的关键词，有助于搜索引擎索引。</li>
<li><code>name=&quot;author&quot;</code>: 用于指定文档的作者。</li>
<li><code>http-equiv=&quot;refresh&quot;</code>: 自动刷新页面或定时跳转到其他页面。</li>
</ol>
<p>这些是<code>meta</code>元素中常见的属性，它们可以帮助优化网页内容、提高SEO</p>
<h4 id="隐藏一个元素有哪些方法"><a href="#隐藏一个元素有哪些方法" class="headerlink" title="隐藏一个元素有哪些方法"></a>隐藏一个元素有哪些方法</h4><ol>
<li><p>CSS <code>display</code> 属性:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过给元素添加 hidden 类，可以将其隐藏起来。</span><br><span class="line"><span class="selector-class">.hidden</span> &#123;  </span><br><span class="line">    <span class="attribute">display</span>: none;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>CSS <code>visibility</code> 属性:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过给元素添加 hidden 类，可以使元素不可见但仍占据页面空间。</span><br><span class="line"><span class="selector-class">.hidden</span> &#123;  </span><br><span class="line">    <span class="attribute">visibility</span>: hidden;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>设置元素的 <code>style.display</code> 属性:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过 JavaScript 修改元素的 display 属性来隐藏它。</span><br><span class="line">document.getElementById(&#x27;elementId&#x27;).style.display = &#x27;none&#x27;;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>设置元素的 <code>style.visibility</code> 属性:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过 JavaScript 修改元素的 visibility 属性来隐藏它。</span><br><span class="line">document.getElementById(&#x27;elementId&#x27;).style.visibility = &#x27;hidden&#x27;;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="小程序和h5有什么区别"><a href="#小程序和h5有什么区别" class="headerlink" title="小程序和h5有什么区别"></a>小程序和h5有什么区别</h4><ul>
<li><strong>运行环境</strong> -  小程序是平台内部运行的轻量级应用，可以直接在平台运行；h5 用户需要通过浏览器访问网址来使用</li>
<li><strong>开发语言</strong> - 小程序通常采用特定的框架和语言进行开发，例如微信小程序采用WXML、WXSS和JavaScript；H5 使用现代web前技术</li>
<li><strong>权限</strong> - 小程序能够调用更多的系统API权限。 h5是基于浏览器，在安全方面着想，受限程度多。</li>
<li><strong>分发方式</strong> - 小程序必须依赖该用户平台，而h5 则不用依赖于特定浏览器</li>
</ul>
<h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><h4 id="盒子模型介绍"><a href="#盒子模型介绍" class="headerlink" title="盒子模型介绍"></a>盒子模型介绍</h4><p>CSS 盒子模型包括内容区域（content）、内边距（padding）、边框（border）和外边距（margin）四个部分。</p>
<h4 id="css-布局方式有哪些"><a href="#css-布局方式有哪些" class="headerlink" title="css 布局方式有哪些"></a>css 布局方式有哪些</h4><p>CSS中常见的布局方式有以下几种：</p>
<ol>
<li><strong>流动布局（Flow Layout）</strong>：元素按照在HTML中出现的顺序依次排列，可以通过设置<code>float</code>属性实现左浮动或右浮动。</li>
<li><strong>定位布局（Positioning Layout）</strong>：通过设置<code>position</code>属性为<code>absolute</code>、<code>relative</code>或<code>fixed</code>来控制元素的位置。</li>
<li><strong>弹性盒子布局（Flexbox Layout）</strong>：使用<code>display: flex</code>或<code>display: inline-flex</code>来创建灵活的布局，可以方便地控制元素的排列顺序、对齐方式等。</li>
<li><strong>网格布局（Grid Layout）</strong>：使用CSS网格布局可以将页面划分为行和列，通过定义网格容器和网格项来实现复杂的布局。</li>
<li><strong>多列布局（Multiple Column Layout）</strong>：通过设置<code>column-count</code>、<code>column-width</code>等属性，将文本内容分成多列显示。</li>
</ol>
<h4 id="讲一下弹性盒子布局"><a href="#讲一下弹性盒子布局" class="headerlink" title="讲一下弹性盒子布局"></a>讲一下弹性盒子布局</h4><p>通过将容器设置为<code>display: flex</code>或<code>display: inline-flex</code>，容器内的子元素就会成为弹性项目弹性盒子布局的主要特点包括：</p>
<ul>
<li><strong>主轴和交叉轴</strong>：主轴是弹性项目排列的方向，交叉轴与主轴垂直。开发者可以通过<code>flex-direction</code>属性控制主轴的方向。</li>
<li><strong>弹性项目的灵活性</strong>：弹性项目可以根据需要扩展、收缩，可以通过<code>flex-grow</code>、<code>flex-shrink</code>和<code>flex-basis</code>属性来控制。</li>
<li><strong>对齐方式</strong>：可以通过<code>justify-content</code>和<code>align-items</code>等属性来控制弹性项目在主轴和交叉轴上的对齐方式。</li>
<li><strong>顺序控制</strong>：可以通过<code>order</code>属性调整弹性项目的排列顺序。</li>
<li>.</li>
</ul>
<h4 id="css元素居中方式"><a href="#css元素居中方式" class="headerlink" title="css元素居中方式"></a>css元素居中方式</h4><ol>
<li><p>水平居中：</p>
<ul>
<li>对于块级元素，可以使用 <code>margin: 0 auto;</code> 来实现水平居中。</li>
<li>对于行内元素，可以将父元素设置为 <code>text-align: center;</code> 并且将子元素设为 <code>display: inline-block;</code> 来实现水平居中。</li>
</ul>
</li>
<li><p>垂直居中：</p>
<ul>
<li>使用 Flexbox 布局，可以通过将父容器设置为 <code>display: flex;</code> 并且使用 <code>align-items: center;</code> 来实现垂直居中。</li>
<li>使用 Grid 布局，可以通过将父容器设置为 <code>display: grid; place-items: center;</code> 来实现垂直和水平同时居中。</li>
</ul>
</li>
<li><p>水平和垂直都居中：</p>
<ul>
<li><p>使用绝对定位（position:absolute）和 transform 属性来使元素水平和垂直同时居中。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.centered</span> &#123;  </span><br><span class="line">  <span class="attribute">position</span>: absolute;  </span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;  </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;  </span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>表格布局方式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;  </span><br><span class="line">  <span class="attribute">display</span>: table;  </span><br><span class="line">  <span class="attribute">width</span> :<span class="number">100%</span>; <span class="comment">/*宽度设置*/</span>  </span><br><span class="line">  <span class="attribute">height</span> :<span class="number">100vh</span>;<span class="comment">/*高度设置*/</span>  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="selector-class">.centered</span> &#123;  </span><br><span class="line">  <span class="attribute">display</span> :table-cell;  </span><br><span class="line">  <span class="attribute">vertical-align</span> :middle;  </span><br><span class="line">  <span class="attribute">text-align</span>:center;<span class="comment">/*文本信息左右对齐的属性*/</span>  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="css回流，重绘，合并图层，GPU-加速"><a href="#css回流，重绘，合并图层，GPU-加速" class="headerlink" title="css回流，重绘，合并图层，GPU 加速"></a>css回流，重绘，合并图层，GPU 加速</h4><p>减少回流和重绘：</p>
<ol>
<li>使用 transform 属性来移动元素，而不是使用 top 或 left。</li>
<li>使用 requestAnimationFrame 来执行动画，这样可以将所有的 DOM 更新合并成一个，并在下一帧统一处理。</li>
<li>避免频繁修改样式属性，最好通过修改 CSS 类名的方式来批量改变元素样式。</li>
</ol>
<p>合并图层：</p>
<ol>
<li>避免创建大量复杂的 z-index 嵌套结构，这可能会导致浏览器创建大量图层。</li>
<li>将页面中不经常变化的部分放在单独的图层中，比如使用 will-change 属性或 translate3d 来提前启用 GPU 加速。</li>
</ol>
<p>GPU 加速：</p>
<ol>
<li>将需要使用 GPU 加速渲染的元素设为 3D 变换。例如：transform: translateZ(0) 或者 perspective: 1000px。</li>
<li>尽量避免过多地同时开启硬件加速，因为它也会消耗额外内存。</li>
</ol>
<h4 id="关于适配问题"><a href="#关于适配问题" class="headerlink" title="关于适配问题"></a>关于适配问题</h4><ol>
<li><p>普通移动端(H5)</p>
<p>盒子可以采用rem单位( rem是针对html根元素的fontSize)，可以通过动态获取屏幕可视宽度，来设置html的fontSize属性。从而达到适配</p>
</li>
<li><p>uniapp 小程序 做适配</p>
<p>使用 rpx单位，一般开发时，若设计图宽度一般为750px。例如测量一个元素宽度为300px。代码中直接写300rpx即可。</p>
<p>早期uniapp是推荐使用upx，目前改成了 rpx。rpx是根据屏幕宽度自适应的动态单位，基准单位为750rpx。会进行px换算: 1rpx &#x3D; 750*(设计稿元素宽度px &#x2F; 设计稿基准宽度px)</p>
<p>例如： 设计稿为640px，元素宽度为100px，则换算后为 117 rpx</p>
<p>750*(100px&#x2F;640px) &#x3D; 117rpx</p>
</li>
<li><p>扩展 - px、em、rem、%、vh、vw</p>
<ul>
<li>px  绝对单位，精确像素展示</li>
<li>em   相对单位，相对于父节点字体进行计算</li>
<li>rem   相对单位，相对根节点html的字体大小来计算</li>
<li>%   百分比，根据父节点的大小进行百分比计算</li>
<li>vh   百分比，根据可视高度进行百分比计算，1vh &#x3D; 可视高度1%</li>
<li>vw   百分比，根据可视宽度进行百分比计算，1vh &#x3D; 可视宽度1%</li>
</ul>
</li>
</ol>
<h4 id="BFC实现方法"><a href="#BFC实现方法" class="headerlink" title="BFC实现方法"></a>BFC实现方法</h4><p>BFC（块级格式化上下文）是 CSS 中的一个重要概念，它可以影响元素的布局和渲染。BFC 的主要作用是创建一个独立的渲染环境，使得元素的布局不受外部影响，从而避免一些常见的布局问题。</p>
<p>解决的问题：</p>
<ol>
<li><strong>清除浮动</strong>：当一个元素设置了浮动后，其父元素的高度将会塌陷，导致布局错乱。使用 BFC 可以触发父元素形成一个独立的渲染环境，使得其高度可以正确地被计算并包裹浮动元素。</li>
<li><strong>避免外边距重叠</strong>：在普通流中相邻块级盒子的上外边距和下外边距有时会发生重叠。将这些盒子放入不同的 BFC 中可以避免外边距重叠。</li>
<li><strong>自适应两栏布局</strong>：当需要实现两栏等高自适应布局时，可以利用 BFC 来清除浮动，并保证两栏等高。</li>
<li><strong>垂直居中问题</strong>：利用 BFC 可以实现一些垂直居中效果，例如通过设置父元素为 BFC 并采用 flex 布局实现垂直居中。</li>
<li><strong>阻止文字环绕</strong>：使用 BFC 可以防止文字环绕非浮动块级盒子。</li>
<li><strong>margin 重叠</strong>: 在普通流中，相邻的两个块级盒子的上下外边距会发生重叠，导致外边距的计算结果不符合预期</li>
</ol>
<p>BFC 的实现方法有以下几种：</p>
<ol>
<li><strong>float 属性</strong>：当元素设置了 float 属性时，会创建一个 BFC。这是因为 float 元素会脱离文档流，形成一个独立的渲染环境。</li>
<li><strong>position 属性</strong>：当元素设置了 position 属性为 absolute 或 fixed 时，会创建一个 BFC。这是因为绝对定位和固定定位的元素会脱离文档流，形成一个独立的渲染环境。</li>
<li><strong>display 属性</strong>：当元素设置了 display 属性为 inline-block、table-cell、table-caption、flex、inline-flex 或 grid 时，会创建一个 BFC。这是因为这些属性会使元素形成一个独立的渲染环境。</li>
<li><strong>overflow 属性</strong>：当元素设置了 overflow 属性为 auto、scroll 或 hidden 时，会创建一个 BFC。这是因为 overflow 属性可以控制元素的溢出内容，从而形成一个独立的渲染环境。</li>
</ol>
<h4 id="对IFC的理解"><a href="#对IFC的理解" class="headerlink" title="对IFC的理解"></a>对IFC的理解</h4><p>IFC 是 CSS 中的一种布局模式，IFC 是指内联格式化上下文，它是一种用于排列内联元素的 CSS 布局模式</p>
<p>IFC 的特点包括：</p>
<ul>
<li>内联元素会在水平方向上依次排列，直到排满一行，然后自动换行到下一行。</li>
<li>IFC 中的元素会在垂直方向上对齐，例如顶部对齐、底部对齐等。</li>
<li>IFC 中的元素会在水平方向上对齐，例如左对齐、右对齐等。</li>
<li>IFC 中的元素会根据自身的大小和内容自动调整位置和大小，以适应容器的大小和其他元素的位置。</li>
</ul>
<p><strong>flex</strong></p>
<ol>
<li><strong>容器属性</strong>：<ul>
<li><code>display</code>：设置容器为 flex 布局。</li>
<li><code>flex-direction</code>：设置主轴的方向（row、row-reverse、column、column-reverse）。</li>
<li><code>flex-wrap</code>：设置是否换行（nowrap、wrap、wrap-reverse）。</li>
<li><code>justify-content</code>：设置主轴上的对齐方式（flex-start、flex-end、center、space-between、space-around）。</li>
<li><code>align-items</code>：设置交叉轴上的对齐方式（flex-start、flex-end、center、baseline、stretch）。</li>
<li><code>align-content</code>：设置多根轴线的对齐方式（flex-start、flex-end、center、space-between、space-around、stretch）。</li>
</ul>
</li>
<li><strong>项目属性</strong>：<ul>
<li><code>order</code>：设置项目的排列顺序。</li>
<li><code>flex-grow</code>：设置项目的放大比例。</li>
<li><code>flex-shrink</code>：设置项目的缩小比例。</li>
<li><code>flex-basis</code>：设置项目的基准大小。</li>
<li><code>flex</code>：设置项目的放大比例、缩小比例和基准大小。</li>
<li><code>align-self</code>：设置单个项目在交叉轴上的对齐方式。</li>
</ul>
</li>
</ol>
<h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>媒体查询是一种用于网页设计的技术，它允许根据设备的特性（如屏幕大小、分辨率、设备方向等）来应用不同的样式表</p>
<h4 id="骨架屏原理"><a href="#骨架屏原理" class="headerlink" title="骨架屏原理"></a>骨架屏原理</h4><ol>
<li>设计骨架屏：首先需要设计好网页的基本结构，并确定哪些元素会在页面加载时展示为骨架屏。这可能包括导航栏、列表、卡片等重要的页面结构元素。</li>
<li>创建骨架屏样式：利用CSS来定义骨架屏的样式，通常是使用灰色或者其他淡色调来绘制基本结构。你可以使用占位符元素、伪类选择器或者内联样式来实现这些效果。</li>
<li>控制显示与隐藏：借助JavaScript或者其他前端框架，在页面加载时将对应的骨架屏样式应用到页面上，并在实际内容加载完成后切换回真实内容。这可以通过动态添加&#x2F;移除CSS类名、使用条件渲染（例如Vue.js中的v-if指令）等方式来实现。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css">  </span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 配置骨架屏样式 */</span>  </span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.skeleton</span> &#123;  </span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#f2f2f2</span>;  </span></span><br><span class="line"><span class="language-css">      <span class="attribute">border-radius</span>: <span class="number">4px</span>;  </span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;  </span></span><br><span class="line"><span class="language-css">    &#125;  </span></span><br><span class="line"><span class="language-css">    </span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 实际内容容器 */</span>  </span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.content</span> &#123;  </span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: none; <span class="comment">/* 默认隐藏 */</span>  </span></span><br><span class="line"><span class="language-css">    &#125;  </span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!-- 需要展示成为骨架屏的部分 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;skeleton&quot;</span> <span class="attr">id</span>=<span class="string">&quot;skeleton1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 实际内容 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span> <span class="attr">id</span>=<span class="string">&quot;realContent&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 这里放置真正的网页内容 --&gt;</span>  </span><br><span class="line">    ...  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 模拟数据加载延迟  </span></span></span><br><span class="line"><span class="language-javascript"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// 数据加载完成后显示真正内容  </span></span></span><br><span class="line"><span class="language-javascript">   <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;realContent&#x27;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>;  </span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// 移除对应位置上原有的 skeleton 元素  </span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;skeleton1&#x27;</span>);  </span></span><br><span class="line"><span class="language-javascript">   element.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(element);  </span></span><br><span class="line"><span class="language-javascript">&#125;, <span class="number">3000</span>); <span class="comment">// 模拟3秒钟后数据加载完毕  </span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="鼠标穿透属性"><a href="#鼠标穿透属性" class="headerlink" title="鼠标穿透属性"></a>鼠标穿透属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.popup</span>&#123;</span><br><span class="line">    // 可以将被该层的元素遮挡的鼠标事件穿透过去，不被遮挡</span><br><span class="line">    <span class="attribute">pointer-events</span>: none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SCSS"><a href="#SCSS" class="headerlink" title="SCSS"></a>SCSS</h3><ol>
<li><strong>SCSS 与 CSS 的区别</strong>：要求应聘者解释 SCSS 与纯 CSS 之间的区别，以及为什么使用 SCSS 的优势。这可能涉及到 SCSS 提供的变量、嵌套、混合、继承等功能，以及它们对代码组织和可维护性的影响。</li>
<li><strong>SCSS 中的变量</strong>：询问应聘者如何在 SCSS 中声明和使用变量，并要求举例说明如何使用变量提高样式表的可维护性。</li>
<li><strong>嵌套</strong>：考察应聘者对于在 SCSS 中如何利用嵌套来组织样式规则，并讨论其优点和缺点。也可以问一些关于嵌套过度导致选择器权重过高或产生不必要复杂性等情况下可能遇到的问题。</li>
<li><strong>混合（Mixins）</strong>：询问应聘者如何创建和使用 SCSS 混合，以及混合与函数之间有什么不同之处。</li>
<li><strong>继承（Inheritance）</strong>：了解应聘者对于在 SCSS 中如何利用继承来减少重复代码并提高样式表可读性方面所持有观点。</li>
<li><strong>函数与指令（Functions and Directives）</strong>: 考察应聘者是否熟悉 SassScript 函数以及编写自定义指令时需要注意哪些事项。</li>
<li><strong>导入其他文件</strong>：询问候选人他们是如何在项目中管理多个 SCSS 文件，并探讨他们认为最佳实践是什么？</li>
<li><strong>SCSS 的工作原理</strong>：考虑向候选人提出关于编译器将 SCSS 转换为纯 CSS 的工作原理相关问题。</li>
</ol>
<h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><h4 id="说说js中的数据类型-基本数据类型和引用数据类型区别，以及存储上的差别"><a href="#说说js中的数据类型-基本数据类型和引用数据类型区别，以及存储上的差别" class="headerlink" title="说说js中的数据类型,基本数据类型和引用数据类型区别，以及存储上的差别"></a>说说js中的数据类型,基本数据类型和引用数据类型区别，以及存储上的差别</h4><p>JavaScript中的数据类型分为两大类：基本数据类型（原始数据类型）和引用数据类型。</p>
<p><strong>基本数据类型</strong></p>
<p>基本数据类型在内存中存储的是值，包含以下几种：</p>
<ol>
<li><strong>Undefined</strong>：表示一个未定义的值，默认值为<code>undefined</code>。</li>
<li><strong>Null</strong>：表示一个空值，意为“无”。</li>
<li><strong>Boolean</strong>：布尔值，只有两个值：<code>true</code>和<code>false</code>。</li>
<li><strong>Number</strong>：表示数字，包括整数和浮点数，所有数字都采用64位浮点数表示。</li>
<li><strong>BigInt</strong>：表示可以表示任意大小的整数，超出Number的安全范围（<code>Number.MAX_SAFE_INTEGER</code>）。</li>
<li><strong>String</strong>：表示字符序列，用于存储文本。</li>
<li><strong>Symbol</strong>：表示唯一且不可变的值，在ES6引入，用于对象属性的唯一性。</li>
</ol>
<p><strong>引用数据类型</strong></p>
<p>引用数据类型存储的是对象的引用或指针，而不是对象本身。主要包括：</p>
<ol>
<li><strong>Object</strong>：最基本的引用数据类型，可以用来存放键值对。</li>
<li><strong>Array</strong>：特殊的对象，用于存放有序列表，可以通过索引访问。</li>
<li><strong>Function</strong>：JavaScript中的函数也是对象，因此也是引用数据类型。</li>
<li><strong>Date</strong>、<strong>RegExp</strong>等：这些都是特定类型的对象。</li>
</ol>
<p><strong>存储上的差别</strong></p>
<ol>
<li><strong>存储方式</strong>：<ul>
<li><strong>基本数据类型</strong>：直接存储在栈（Stack）内存中。由于是固定大小，访问速度快。</li>
<li><strong>引用数据类型</strong>：存储在堆（Heap）内存中，变量保存的是引用地址。访问速度相对较慢。</li>
</ul>
</li>
<li><strong>复制方式</strong>：<ul>
<li><strong>基本数据类型</strong>：赋值时，会创建一个新的副本，例如：<code>let a = 10; let b = a;</code>，此时<code>a</code>和<code>b</code>是两个独立的值。</li>
<li><strong>引用数据类型</strong>：赋值时，实际上是复制了引用，比如：<code>let obj1 = &#123;name: &#39;Alice&#39;&#125;; let obj2 = obj1;</code>，此时<code>obj1</code>和<code>obj2</code>指向同一个对象，修改其中一个会影响另一个。</li>
</ul>
</li>
<li><strong>类型检查</strong>：<ul>
<li><strong>基本数据类型</strong>直接用<code>typeof</code>来判断。</li>
<li><strong>引用数据类型</strong>在判断时需要特别注意，因为数组和对象在<code>typeof</code>下都是<code>object</code>，可以使用<code>Array.isArray()</code>来判断数组。</li>
</ul>
</li>
</ol>
<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>将一种数据类型自动转换为另一种数据类型而不需要显式地调用转换函数。</p>
<ul>
<li><p>字符串连接</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;  </span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&quot;20&quot;</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + b); <span class="comment">// 输出 &quot;1020&quot;，此时数字 10 隐式转换为字符串 &quot;10&quot;，然后与字符串 &quot;20&quot; 连接。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比较操作符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;  </span><br><span class="line"><span class="comment">//因为使用了双等号进行比较时，JavaScript 会进行隐式转换使得数字 10 转化为字符串 &quot;10&quot;。</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="string">&quot;10&quot;</span>) &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;相等&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数学运算</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="number">5</span> - <span class="string">&#x27;3&#x27;</span>;   </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// 输出2, &#x27;3&#x27;被隐式转化成了数字3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>布尔值上下文</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d= !!<span class="string">&quot;hello&quot;</span>; <span class="comment">// true, !! 可以将任何值强制隐式地变成布尔值。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（相等运算符）和-（严格相等运算符）"><a href="#（相等运算符）和-（严格相等运算符）" class="headerlink" title="==（相等运算符）和 ===（严格相等运算符）"></a><code>==</code>（相等运算符）和 <code>===</code>（严格相等运算符）</h4><p>&#x3D;&#x3D; ，在比较之前，会进行类型转换（隐式转换），即使两个值的类型不同，JavaScript 也会尝试将它们转换为相同的类型进行比较</p>
<p>&#x3D;&#x3D;&#x3D;，不进行类型转换，只有当两个值的类型相同且值相等时，才返回 <code>true</code>，可以避免潜在的错误</p>
<h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><p><strong>常用方法：</strong></p>
<ol>
<li><code>push()</code>：在数组末尾添加一个或多个元素，并返回新的长度。</li>
<li><code>pop()</code>：删除并返回数组删除的元素。</li>
<li><code>shift()</code>：删除并返回数组删除的元素。</li>
<li><code>unshift()</code>：在数组开头添加一个或多个元素，并返回新的长度。</li>
<li><code>concat()</code>：连接两个或更多数组，并返回新数组。</li>
<li><code>slice(start, end)</code>：从现有数组中返回选定的元素。</li>
</ol>
<p><strong>特殊方法:</strong></p>
<ol>
<li><p><code>map(callback)</code>:</p>
<ul>
<li>这个方法会对数组中的每个元素都执行回调函数，并将回调函数返回的结果组成一个新的数组返回。</li>
<li>示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  </span><br><span class="line"><span class="keyword">const</span> doubledNumbers = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>);  </span><br><span class="line"><span class="comment">// doubledNumbers 现在是 [2, 4, 6, 8]  </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>filter(callback)</code>:</p>
<ul>
<li>这个方法会根据指定函数过滤原始数据，通过回调函数的boolean，得到符合条件数据组成新数组返回。</li>
<li>示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  </span><br><span class="line"><span class="keyword">const</span> evenNumbers = numbers.<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> ===<span class="number">0</span>);  </span><br><span class="line"><span class="comment">// evenNumbers 现在是 [2,4]  </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>reduce(callback [, initialValue])</code>:</p>
<ul>
<li>这个方法通过提供一个函数来累积所有值以生成单个值。</li>
<li>它接受一个回调函数和一个初始值作为参数，并且这个回调函数接收了上一次调用得到 的结果（或者初始值）和当前元素作为参数。</li>
<li>示例:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span> ,<span class="number">4</span>];  </span><br><span class="line"><span class="keyword">const</span> sum = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulater,currentValue</span>)=&gt;</span> accumulater+currentValue ,<span class="number">0</span> );  </span><br><span class="line"><span class="comment">// sum现在等于10</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="数组扁平化和数组去重"><a href="#数组扁平化和数组去重" class="headerlink" title="数组扁平化和数组去重"></a>数组扁平化和数组去重</h4><p><strong>数组扁平化：</strong></p>
<p>数组扁平化是将多维数组转换为一维数组的过程。这在处理嵌套数组时非常有用。以下是一些实现方式：</p>
<ol>
<li>使用 <code>flat()</code> 方法：<code>flat()</code> 方法可以将嵌套数组展开指定的层数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>]]];  </span><br><span class="line"><span class="keyword">const</span> flattenedArray = nestedArray.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>);  </span><br><span class="line"><span class="comment">// flattenedArray 现在是 [1, 2, 3, 4, 5]  </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用递归函数：可以编写一个递归函数来处理嵌套数组。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenArray</span>(<span class="params">arr</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(val) ? acc.<span class="title function_">concat</span>(<span class="title function_">flattenArray</span>(val)) : acc.<span class="title function_">concat</span>(val), []);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>]]];  </span><br><span class="line"><span class="keyword">const</span> flattenedArray = <span class="title function_">flattenArray</span>(nestedArray);  </span><br><span class="line"><span class="comment">// flattenedArray 现在是 [1, 2, 3, 4, 5]  </span></span><br></pre></td></tr></table></figure>

<p><strong>数组去重：</strong></p>
<p>数组去重是指从数组中移除重复的元素，只保留唯一的元素。以下是一些实现方式：</p>
<ol>
<li>使用 <code>Set</code>：可以使用 <code>Set</code> 数据结构来创建一个不重复的数组。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>];  </span><br><span class="line"><span class="keyword">const</span> uniqueArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array));  </span><br><span class="line"><span class="comment">// uniqueArray 现在是 [1, 2, 3, 4, 5]  </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <code>filter()</code> 和 <code>indexOf()</code>：可以使用 <code>filter()</code> 方法结合 <code>indexOf()</code> 方法来过滤重复的元素。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>];  </span><br><span class="line"><span class="keyword">const</span> uniqueArray = array.<span class="title function_">filter</span>(<span class="function">(<span class="params">value, index, self</span>) =&gt;</span> self.<span class="title function_">indexOf</span>(value) === index);  </span><br><span class="line"><span class="comment">// uniqueArray 现在是 [1, 2, 3, 4, 5]  </span></span><br></pre></td></tr></table></figure>



<h4 id="forEach-和-map-区别"><a href="#forEach-和-map-区别" class="headerlink" title="forEach 和 map 区别"></a>forEach 和 map 区别</h4><p><code>forEach</code> 和 <code>map</code> 都是用于对数组进行遍历和处理的方法</p>
<ul>
<li>如果只需要循环遍历并处理每个元素而不需要生成新的数据，则可以使用 <code>forEach</code></li>
<li>如果希望对原始数据进行映射或转换，并且获得一个新的处理后数据集合，则可以使用 <code>map</code></li>
</ul>
<p><strong><code>forEach</code>:</strong></p>
<ul>
<li><code>forEach</code> 方法是数组的原生方法，它接受一个函数作为参数，并对数组中的每个元素执行该函数。</li>
<li>它没有返回值（或者说返回值为 <code>undefined</code>），因此主要用于遍历数组并对其中的元素执行一些操作。</li>
<li>由于没有返回值，无法通过 <code>forEach</code> 直接得到一个新的数组。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  </span><br><span class="line">array.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(element);  </span><br><span class="line">&#125;);  </span><br><span class="line"><span class="comment">// 输出：1、2、3、4  </span></span><br></pre></td></tr></table></figure>

<p><strong><code>map</code>:</strong></p>
<ul>
<li><code>map</code> 方法也是数组的原生方法，它接受一个函数作为参数，并对数组中的每个元素执行该函数。不同之处在于，它会将处理后得到的结果组成一个新数组并返回。</li>
<li>可以使用 <code>map</code> 方法将原始数组映射&#x2F;转换为新的数组。</li>
<li>对原始数据进行映射或转换时非常有用。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  </span><br><span class="line"><span class="keyword">const</span> doubledArray = array.<span class="title function_">map</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> element * <span class="number">2</span>);  </span><br><span class="line"><span class="comment">// doubledArray 现在是 [2, 4, 6, 8]  </span></span><br></pre></td></tr></table></figure>



<h4 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h4><ol>
<li><code>length</code>：返回字符串的长度。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello&quot;</span>;  </span><br><span class="line"><span class="keyword">const</span> length = str.<span class="property">length</span>; <span class="comment">// length 现在等于 5  </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>charAt(index)</code> 或者 <code>[index]</code>：返回指定索引位置的字符。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello&quot;</span>;  </span><br><span class="line"><span class="keyword">const</span> firstChar = str.<span class="title function_">charAt</span>(<span class="number">0</span>); <span class="comment">// firstChar 现在等于 &quot;H&quot;  </span></span><br><span class="line"><span class="comment">// 或者  </span></span><br><span class="line"><span class="keyword">const</span> firstChar2 = str[<span class="number">0</span>]; <span class="comment">// firstChar2 现在等于 &quot;H&quot;  </span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>toUpperCase()</code> 和 <code>toLowerCase()</code>：将字符串中的字母转换为大写或小写。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line"><span class="keyword">const</span> upperCaseStr1 = str1.<span class="title function_">toUpperCase</span>(); <span class="comment">// upperCaseStr1 现在等于 &quot;HELLO&quot;  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&quot;WORLD&quot;</span>;  </span><br><span class="line"><span class="keyword">const</span> lowerCaseStr2 = str2.<span class="title function_">toLowerCase</span>(); <span class="comment">// lowerCaseStr2 现在等于 &quot;world&quot;  </span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>indexOf(substring)</code> 和 <code>lastIndexOf(substring)</code>：查找子串第一次出现和最后一次出现的位置（索引）。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sentence = <span class="string">&#x27;The quick brown fox jumps over the lazy dog&#x27;</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sentence.<span class="title function_">indexOf</span>(<span class="string">&#x27;fox&#x27;</span>)); <span class="comment">// 输出 16  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sentence.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;the&#x27;</span>)); <span class="comment">// 输出 35  </span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>replace(searchValue, replaceValue)</code>：替换字符串中某个子串为新值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message =<span class="string">&#x27;I am learning JavaScript&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newMessage= message.<span class="title function_">replace</span>(<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newMessage);<span class="comment">//输出: I am learning Python  </span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>split(separator)</code>拆分一个字符串成数组，通过指定分隔符。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sentence=<span class="string">&quot;Welcome to our website&quot;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> words=sentence.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(words);<span class="comment">//输出[&quot;Welcome&quot;, &quot;to&quot;, &quot;our&quot;, 	&quot;website&quot;]  </span></span><br></pre></td></tr></table></figure>

<h4 id="typeof和instanceof-区别"><a href="#typeof和instanceof-区别" class="headerlink" title="typeof和instanceof 区别"></a>typeof和instanceof 区别</h4><ul>
<li>**<code>typeof</code>**： 在 JavaScript 中，原生数据类型（如字符串、数字、布尔值等）使用typeof 或 &#x3D;&#x3D;&#x3D; 来判断<ul>
<li>返回一个字符串，表示变量的类型。</li>
<li>适用于基本数据类型和函数类型的检查。</li>
<li>对于对象和数组返回的都是 <code>&quot;object&quot;</code>，不会提供细粒度的信息。</li>
</ul>
</li>
<li>**<code>instanceof</code>**：对于非原生数据类型，例如对象、数组、函数等，可以使用 <code>instanceof</code> 运算符来判断其类型。<code>instanceof</code> 运算符可以检查一个对象是否是某个构造函数或类的实例。<ul>
<li>返回一个布尔值，表示对象是否是特定构造函数的实例。</li>
<li>适用于所有对象和自定义类型的检查，能够准确检测对象类型。</li>
</ul>
</li>
</ul>
<h4 id="js原型？原型链？有什么特点？"><a href="#js原型？原型链？有什么特点？" class="headerlink" title="js原型？原型链？有什么特点？"></a>js原型？原型链？有什么特点？</h4><p><strong>原型（prototype)</strong></p>
<ul>
<li><strong>原型</strong>：JavaScript 中的原型（prototype）是一种对象间的关联机制，是实现继承和属性共享的基础。</li>
<li>特点：<ol>
<li>原型是对象与对象之间的关系，本质上是一种引用关系。</li>
<li>能够实现对象属性和方法的共享，提高代码的重用性和效率。</li>
<li>当访问一个对象的属性或方法时，JavaScript 引擎会沿着原型链向上查找，直到找到该属性或方法。</li>
</ol>
</li>
</ul>
<p><strong>原型链（prototype chain）</strong></p>
<ul>
<li><strong>原型链</strong>：原型链是由对象的原型与对象组成的链式结构，直到到达原型链的顶端（即 <code>Object.prototype</code>）</li>
<li>特点：<ol>
<li>每个对象都有一个指向其原型的链接，即 <code>__proto__</code> 属性。</li>
<li>当访问一个对象的属性或方法时，JavaScript 引擎会沿着原型链向上查找，直到找到该属性或方法所在的原型对象。</li>
<li>原型链会一直追溯下去直至 <code>Object.prototype</code> 对象 ：person1 —&gt; Person.prototype —&gt; Object.prototype —&gt; null</li>
</ol>
</li>
</ul>
<p><strong>Function.prototype</strong></p>
<p>在 JavaScript 中，<code>Function.prototype</code> 是一个特殊的对象，它是所有函数的原型。当我们创建一个函数时，该函数会自动关联到 <code>Function.prototype</code>。这意味着所有函数对象都可以访问 <code>Function.prototype</code> 上的方法和属性。<br>而 <code>Function.prototype</code> 指向的是一个包含常用函数方法的空函数对象，这个对象是所有函数对象的原型，用于存放和共享函数对象所需的方法和属性。</p>
<h4 id="作用域和作用域链的理解"><a href="#作用域和作用域链的理解" class="headerlink" title="作用域和作用域链的理解"></a>作用域和作用域链的理解</h4><p><strong>作用域</strong></p>
<p>JavaScript 中的作用域主要分为以下几种：</p>
<ol>
<li><strong>全局作用域（Global Scope）</strong>：全局作用域是指在代码中任何地方都能访问的作用域。在浏览器环境中，全局作用域是指 <code>window</code> 对象。</li>
<li><strong>函数作用域（Function Scope）</strong>：函数作用域是指在函数内部声明的变量只能在该函数内部访问。函数外部无法直接访问函数内部的变量。</li>
<li><strong>块级作用域（Block Scope）</strong>：块级作用域是指由一对花括号 <code>&#123;&#125;</code> 定义的范围内有效的作用域。在 ES6 之前，JavaScript 中没有块级作用域，变量的作用域只限于函数内部。但是在 ES6 引入了 <code>let</code> 和 <code>const</code> 关键字，使得可以在块级作用域内声明变量。</li>
<li><strong>词法作用域（Lexical Scope）</strong>：词法作用域是指变量的作用域由代码中变量声明的位置决定，与调用位置无关。JavaScript 使用词法作用域，也就是静态作用域。</li>
<li><strong>闭包（Closure）</strong>：闭包是指函数和其词法环境的组合，可以访问外部函数中定义的变量。通过闭包</li>
</ol>
<p><strong>作用域链</strong></p>
<p>当在一个函数中查找变量时，JavaScript 引擎会首先在当前函数作用域中查找。如果找不到，它会向外部作用域（外皮函数或全局作用域）查找，直到找到该变量或确定该变量未定义为止。这个查找过程形成了一个链式结构，称为“作用域链”。</p>
<p>作用域链式js查找函数和变量的一种机制，作用域链是由当前执行环境的变量对象和父级执行环境的变量对像组成的</p>
<p><strong>作用域链查找过程</strong></p>
<ol>
<li>当前执行的代码块（内层作用域）。</li>
<li>外层函数的作用域（依次向上查找）。</li>
<li>全局作用域。</li>
</ol>
<h4 id="谈谈对this的理解"><a href="#谈谈对this的理解" class="headerlink" title="谈谈对this的理解"></a>谈谈对this的理解</h4><ul>
<li><code>this</code> 是一个特殊的关键字，它并不指向函数本身，而是指向调用该函数的上下文（即函数被调用的位置）。</li>
<li>在不同的上下文中，<code>this</code> 的值会有所不同，这取决于函数被调用的方式。</li>
<li><strong>全局上下文</strong>：在全局执行环境中，<code>this</code> 指向全局对象（在浏览器中是 <code>window</code> 对象，在 Node.js 中是 <code>global</code> 对象）</li>
</ul>
<p>​	<strong><code>this</code> 的值的确定方式</strong></p>
<ul>
<li><strong>函数调用</strong>：在普通函数中，<code>this</code> 指向调用该函数的对象。如果是直接调用，<code>this</code> 会指向全局对象（非严格模式下）。</li>
<li><strong>对象的方法</strong>：当一个函数作为对象的方法被调用时，<code>this</code> 指向该对象。</li>
<li><strong>构造函数</strong>：在构造函数中，<code>this</code> 指向新创建的实例。</li>
<li><strong>ES6 箭头函数</strong>：箭头函数不具备自己的 <code>this</code>，它继承自外部函数的 <code>this</code>。</li>
<li><strong>手动绑定</strong>：可以使用 <code>call</code>、<code>apply</code> 和 <code>bind</code> 方法来手动指定 <code>this</code> 的值。</li>
</ul>
<p>​	<strong>常见的陷阱</strong></p>
<ul>
<li><strong>严格模式</strong>：在严格模式下，未绑定的 <code>this</code> 会是 <code>undefined</code> 而不是全局对象。</li>
<li><strong>事件处理函数</strong>：在事件处理程序中，<code>this</code> 通常指向触发事件的元素。</li>
<li><strong>不适合作为构造函数</strong>：箭头函数没有自己的 <code>this</code> 值，不能使用 <code>new</code> 关键字来调用，也不能作为构造函数来创建实例对象。</li>
<li><strong>不适合在对象方法中</strong>：箭头函数的 <code>this</code> 始终指向定义箭头函数时的外层作用域的 <code>this</code> 值，而不是调用时的对象。因此，如果需要在对象方法中使用 <code>this</code>，应该使用普通函数。</li>
<li><strong>不适合在需要动态 <code>this</code> 值的场景</strong>：箭头函数无法改变其 <code>this</code> 的指向，因此不适合在需要动态绑定 <code>this</code> 值的情况下使用。</li>
</ul>
<h4 id="call、apply-和-bind-方法的区别"><a href="#call、apply-和-bind-方法的区别" class="headerlink" title="call、apply 和 bind 方法的区别"></a><code>call</code>、<code>apply</code> 和 <code>bind</code> 方法的区别</h4><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>参数传递方式</th>
<th>返回值</th>
<th>立即执行</th>
</tr>
</thead>
<tbody><tr>
<td><code>call</code></td>
<td>调用函数并指定 <code>this</code></td>
<td>依次传递独立的参数</td>
<td>无</td>
<td>是</td>
</tr>
<tr>
<td><code>apply</code></td>
<td>调用函数并指定 <code>this</code></td>
<td>以数组传递参数</td>
<td>无</td>
<td>是</td>
</tr>
<tr>
<td><code>bind</code></td>
<td>创建一个新函数，指定 <code>this</code> 和参数</td>
<td>指定的参数</td>
<td>返回新函数</td>
<td>否</td>
</tr>
</tbody></table>
<ul>
<li>bind()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;  </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundFunc = sayHello.<span class="title function_">bind</span>(obj);  </span><br><span class="line"><span class="title function_">boundFunc</span>(); <span class="comment">// 输出：Hello, Alice</span></span><br></pre></td></tr></table></figure>

<ul>
<li>apply() &#x2F; call()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;  </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">sayHello.<span class="title function_">call</span>(obj); <span class="comment">// 输出：Hello, Alice  </span></span><br><span class="line">sayHello.<span class="title function_">apply</span>(obj); <span class="comment">// 输出：Hello, Alice</span></span><br></pre></td></tr></table></figure>

<h4 id="其他修改this指向的方法"><a href="#其他修改this指向的方法" class="headerlink" title="其他修改this指向的方法"></a>其他修改this指向的方法</h4><ul>
<li><strong>使用 ES6 的解构赋值</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;  </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,  </span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; sayHello &#125; = obj;  </span><br><span class="line"><span class="title function_">sayHello</span>(); <span class="comment">// 输出：Hello, Alice</span></span><br></pre></td></tr></table></figure>



<h4 id="ajax的原理"><a href="#ajax的原理" class="headerlink" title="ajax的原理"></a>ajax的原理</h4><p>AJAX（Asynchronous JavaScript and XML）是一种用于在不重新加载整个网页的情况下向服务器发送和接收数据的技术。使用 AJAX，可以通过 JavaScript 发送异步请求，从而使用户能够与页面交互而无需等待整个页面刷新</p>
<ol>
<li>使用 XMLHttpRequest 对象：JavaScript 中的 XMLHttpRequest 对象是实现 AJAX 的基础。通过创建一个新的 XMLHttpRequest 对象，可以发送 HTTP 请求到服务器，并在后台处理响应。</li>
<li>异步通信：AJAX 使用异步方式发送和接收数据，这意味着浏览器会在不阻塞其他操作的情况下进行数据通信。这样用户可以继续与页面交互，同时浏览器会在后台进行数据传输和处理。</li>
<li>服务器端处理请求：当客户端发送一个 AJAX 请求时，服务器会接受并处理该请求。通常情况下，服务器将返回 JSON、XML 或纯文本等格式化数据作为响应。</li>
<li>更新页面内容：一旦客户端收到来自服务器的响应数据，在获取到结果后就能够使用 JavaScript 动态地更新网页上对应的部分内容或执行特定操作。</li>
<li>回调函数机制：由于异步请求是非阻塞式执行, 因此在获取到响应之前无法直接得知结果。因此，在发起异步请求时需要注册回调函数，并当请求完成时执行相应回调函数以处理返回结果。</li>
</ol>
<h4 id="axios的原理"><a href="#axios的原理" class="headerlink" title="axios的原理"></a>axios的原理</h4><p>Axios 是一个基于 Promise 的 HTTP 客户端，它提供了一种简单、易用、灵活和强大的方式来发送 HTTP 请求和处理响应。</p>
<ol>
<li>基于 XMLHttpRequest 对象：Axios 使用 XMLHttpRequest 对象来发送 HTTP 请求和接收响应。它提供了一种简单、易用、灵活和强大的方式来处理 HTTP 请求和响应。</li>
<li>支持 Promise API：Axios 基于 Promise API，可以使用 Promise 的 then() 和 catch() 方法来处理异步请求和响应。这使得代码更加简洁易读，并且可以避免回调地狱的问题。</li>
<li>支持拦截器：Axios 支持请求和响应拦截器，可以在请求和响应被发送或接收之前或之后对它们进行处理。这使得可以在请求和响应中添加通用的处理逻辑，例如添加请求头、处理错误等。</li>
<li>支持取消请求：Axios 支持取消请求，可以在请求被发送之前或之后取消它们。这使得可以在需要时取消不必要的请求，从而提高性能和用户体验。要取消请求，只需调用 source.cancel() 方法</li>
<li>支持并发请求：Axios 支持并发请求，可以同时发送多个请求，并在所有请求完成后处理它们的响应。这使得可以在需要时同时发送多个请求，从而提高性能和用户体验。基于pomise.all() ;Axios使用 <code>axios.all()</code> 或 <code>axios.spread()</code> 方法来发送并发请求。</li>
</ol>
<h4 id="如何判断一个元素在可视区域内"><a href="#如何判断一个元素在可视区域内" class="headerlink" title="如何判断一个元素在可视区域内"></a>如何判断一个元素在可视区域内</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个元素是否在可视区域内的方法  </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewport</span>(<span class="params">element</span>) &#123;  </span><br><span class="line">  <span class="comment">// 获取元素相对于视口的位置信息  </span></span><br><span class="line">  <span class="keyword">const</span> rect = element.<span class="title function_">getBoundingClientRect</span>();  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断元素的四个边界是否都在视口内，如果是则返回 true，否则返回 false  </span></span><br><span class="line">  <span class="keyword">return</span> (  </span><br><span class="line">    rect.<span class="property">top</span> &gt;= <span class="number">0</span> &amp;&amp;                              <span class="comment">// 元素顶部在视口内（大于等于0）  </span></span><br><span class="line">    rect.<span class="property">left</span> &gt;= <span class="number">0</span> &amp;&amp;                             <span class="comment">// 元素左边在视口内（大于等于0）  </span></span><br><span class="line">    rect.<span class="property">bottom</span> &lt;= (<span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>) &amp;&amp;   <span class="comment">// 元素底部在视口内（小于等于视口高度）  </span></span><br><span class="line">    rect.<span class="property">right</span> &lt;= (<span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>)          <span class="comment">// 元素右边在视口内（小于等于视口宽度）  </span></span><br><span class="line">  );  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例  </span></span><br><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;yourElementId&#x27;</span>);   <span class="comment">// 获取需要检测的元素  </span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isInViewport</span>(element)) &#123;                                <span class="comment">// 调用 isInViewport 函数判断该元素是否在可见区域内，并进行相应处理  </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Element is in the viewport&#x27;</span>);                 <span class="comment">// 如果元素在可见区域内，则输出提示信息到控制台  </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Element is not in the viewport&#x27;</span>);             <span class="comment">// 如果元素除了可见区域外，则输出提示信息到控制台   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><p>柯里化的主要思想是，将一个多参数的函数转换为一系列只接受单个参数的函数，这些函数通过闭包的方式“记住”之前传递的参数，最后再返回一个值或执行某些操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> x + y;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用柯里化的add函数  </span></span><br><span class="line"><span class="keyword">const</span> add5 = <span class="title function_">add</span>(<span class="number">5</span>);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add5</span>(<span class="number">2</span>)); <span class="comment">// 输出：7  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以一次性传入所有参数  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">5</span>)(<span class="number">2</span>)); <span class="comment">// 输出：7</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">add 是一个接受一个参数 x 的函数，返回一个接受参数 y 的函数。通过柯里化，我们可以先传入部分参数创建一个新的函数（如 add5 = add(5)），然后再传入剩余的参数来调用这个函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数柯里化在函数式编程中有很多应用，比如可以用来简化函数的调用方式、方便数据处理和组合等。通过柯里化，我们可以更灵活地使用函数和处理数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="for…in…-和-for…of…-区别"><a href="#for…in…-和-for…of…-区别" class="headerlink" title="for…in… 和 for…of… 区别"></a>for…in… 和 for…of… 区别</h4><ol>
<li>for…in<ul>
<li>适用于遍历对象（Object）的属性名。</li>
<li>在遍历时会包括对象自身的可枚举属性以及继承得到的可枚举属性。性能开支会比for…of…大</li>
<li>通常不建议直接使用 <code>for...in</code> 来遍历数组，因为它<strong>可能会遍历到数组原型链上的其他属性。</strong></li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;  </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,  </span><br><span class="line"> <span class="attr">age</span>: <span class="number">30</span>  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person) &#123;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(key, person[key]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>for…of</p>
<ul>
<li>主要用于循环<strong>可迭代对象</strong>（iterable objects），比如数组、字符串、Map、Set 等。不支持普通对象(对象没有迭代器)</li>
</ul>
</li>
</ol>
<ul>
<li>在循环时会访问到对象中具体的值，而不是键或索引。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">of</span> colors) &#123;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(color);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="js事件模型"><a href="#js事件模型" class="headerlink" title="js事件模型"></a>js事件模型</h4><p>​	<strong>事件</strong></p>
<ul>
<li><code>click</code>：鼠标点击事件</li>
<li><code>mouseover</code>：鼠标悬停事件</li>
<li><code>keydown</code>：键盘按下事件</li>
<li><code>submit</code>：表单提交事件</li>
</ul>
<p>​	<strong>事件监听器</strong></p>
<ul>
<li><code>addEventListener</code> 方法来注册事件监听器</li>
</ul>
<p>​	<strong>事件对象</strong></p>
<ul>
<li>当事件发生时，浏览器会创建一个事件对象（<code>event</code>），该对象包含事件的相关信息（如事件类型、目标元素、鼠标位置等）。</li>
</ul>
<p>​	<strong>事件冒泡与事件捕获</strong></p>
<blockquote>
<p>可以通过 <code>addEventListener</code> 的第三个参数来控制事件处理的阶段<br>element.addEventListener(‘click’, ()&#x3D;&gt;{}, true);如果设置为 <code>true</code>，则使用捕获模式；如果设置为 <code>false</code> 反之<br>默认是 <code>false</code>，即采用事件冒泡模式。</p>
</blockquote>
<ul>
<li><strong>事件捕获</strong>：事件从外部元素向内部元素传递（从文档根节点到目标元素）。</li>
<li><strong>事件冒泡</strong>：事件从目标元素向外部元素传递（从目标元素到文档根节点）。</li>
</ul>
<p>​	<strong>事件委托</strong></p>
<p>利用事件冒泡机制, 允许将事件处理程序添加到父元素上。将事件监听器绑定到父元素。</p>
<p>场景：1. 列表或菜单 2. 动态生成内容 3. 多个表单元素</p>
<p>​	<strong>防止默认行为</strong></p>
<p>阻止事件的默认行为（例如，防止表单提交）。可以通过调用事件对象的 <code>preventDefault()</code> 方法来实现</p>
<p>​	<strong>停止事件传播</strong></p>
<p>通过调用事件对象的 <code>stopPropagation()</code> 方法来停止事件的传播，防止事件冒泡到父元素。</p>
<h4 id="创建对象有哪些方法"><a href="#创建对象有哪些方法" class="headerlink" title="创建对象有哪些方法"></a>创建对象有哪些方法</h4><ol>
<li><strong>使用对象字面量</strong>：这是最简单的创建对象的方法，通过花括号 <code>&#123;&#125;</code> 来定义对象，并填入属性和方法。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;  </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,  </span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,  </span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用构造函数</strong>：可以使用构造函数来创建对象。通过 <code>new</code> 关键字和构造函数来实例化新的对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;  </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;  </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;  </span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">30</span>);  </span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用 Object 构造函数</strong>：可以使用内置的 <code>Object</code> 构造函数来创建空对象，然后逐个添加属性和方法。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Charlie&#x27;</span>;  </span><br><span class="line">person.<span class="property">age</span> = <span class="number">22</span>;  </span><br><span class="line">person.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用原型</strong>：通过定义一个原型（prototype）并将其与一个构造函数相关联，我们可以共享属性和方法，并且每个实例都有对它们的引用。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span>=age;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;David&#x27;</span>,<span class="number">28</span>);  </span><br></pre></td></tr></table></figure>

<ol>
<li><strong>ES6 中的类</strong> ：ES6 引入了类（class）语法糖，更容易地定义并继承 JavaScript 中的类。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;  </span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params">name,age</span>)&#123;  </span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">name</span>=name,  </span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">age</span>=age  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="title function_">greet</span>(<span class="params"></span>)&#123;  </span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>._name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>._age&#125;</span>`</span>)  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Eve&#x27;</span>,<span class="number">26</span>)  </span><br></pre></td></tr></table></figure>



<h4 id="new-操作符具体操作"><a href="#new-操作符具体操作" class="headerlink" title="new 操作符具体操作"></a>new 操作符具体操作</h4><ol>
<li>创建一个空对象，这个对象会成为函数的实例。</li>
<li>将这个空对象的原型指向构造函数的原型对象。</li>
<li>将构造函数中的 <code>this</code> 绑定到这个新的实例对象。</li>
<li>执行构造函数内部的代码。</li>
</ol>
<h4 id="什么数据存在对象中，什么数据存在prototype中"><a href="#什么数据存在对象中，什么数据存在prototype中" class="headerlink" title="什么数据存在对象中，什么数据存在prototype中"></a>什么数据存在对象中，什么数据存在prototype中</h4><ul>
<li><strong>存在对象本身中的数据</strong>：通常是实例特有的数据，每个对象实例都有自己的一份数据副本。这些数据可以通过对象的属性来访问和修改，属于对象的内部状态。</li>
<li><strong>存在 prototype 中的数据</strong>：通常是对象共享的数据，被所有该类型对象实例共享。这些数据一般是方法或共享的属性，定义在对象的原型上，可以被所有该类型的实例访问。当我们访问一个对象的属性时，如果该属性不在对象本身中，则会去原型链上查找。</li>
</ul>
<h4 id="如何判断a是不是b的实例"><a href="#如何判断a是不是b的实例" class="headerlink" title="如何判断a是不是b的实例"></a>如何判断a是不是b的实例</h4><p>在 JavaScript 中，可以使用 <code>instanceof</code> 运算符来判断一个对象是否是另一个对象的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>



<h4 id="深拷贝和浅拷贝区别"><a href="#深拷贝和浅拷贝区别" class="headerlink" title="深拷贝和浅拷贝区别"></a>深拷贝和浅拷贝区别</h4><p>​	<strong>浅拷贝</strong></p>
<p>浅拷贝是指创建一个新对象，普通数据类型属性会被拷贝，但引用类型变量将指向同一个引用，且这种方式只复制一层的属性。</p>
<p>常用方法：  <code>Object.assign()</code>， 使用扩展运算符， 数组的 <code>slice()</code> 或 <code>concat()</code></p>
<p>​	<strong>深拷贝</strong></p>
<p>深拷贝是指创建一个新对象，这个新对象完全复制原始对象的所有属性，包括嵌套对象的属性。深拷贝的结果是新对象与原始对象之间没有任何引用关系，彼此独立</p>
<p>常用方法： </p>
<ul>
<li><p>使用 <code>JSON.stringify()</code> 和 <code>JSON.parse()</code>（有局限性）</p>
<ul>
<li><p>使用 JSON.parse(JSON.stringify()) - 序列化</p>
<p>深拷贝时，可能会丢失以下信息：</p>
<ul>
<li>不支持 函数、正则表达式、日期对象、undefined、symbol等。</li>
<li>如果对象之间存在引用关系会导致无法正确的序列化和反序列化。</li>
</ul>
</li>
</ul>
</li>
<li><p>手动递归拷贝</p>
</li>
<li><p>使用第三方库，如 Lodash 的 <code>_.cloneDeep()</code></p>
</li>
<li><p>对数组的深拷贝还可以使用 扩展运算符</p>
</li>
</ul>
<h4 id="json-stringify-是干什么的，什么时候会使用到"><a href="#json-stringify-是干什么的，什么时候会使用到" class="headerlink" title="json.stringify() 是干什么的，什么时候会使用到"></a>json.stringify() 是干什么的，什么时候会使用到</h4><p><code>JSON.stringify()</code> 方法是用于将 JavaScript 对象或值转换为 JSON 字符串的方法。它接受一个对象或数组作为参数，然后返回对应的 JSON 字符串表示。</p>
<ol>
<li><strong>数据传输：</strong> 在客户端和服务器之间进行数据传输时，通常需要将 JavaScript 对象转换为 JSON 字符串进行传输。这样可以方便地在不同系统之间交换数据。</li>
<li><strong>本地存储：</strong> 在浏览器端使用 <code>localStorage</code> 或 <code>sessionStorage</code> 存储数据时，通常需要将 JavaScript 对象转换为 JSON 字符串再存储，以便在取出时重新解析为对象。</li>
<li><strong>日志记录：</strong> 在记录日志或调试信息时，有时会将对象转换为 JSON 格式以便于查看和分析。</li>
<li><strong>与后端交互：</strong> 在前端向后端发送数据时，常常会将 JavaScript 对象转换为 JSON 字符串，以便后端能够正确解析和处理数据。</li>
</ol>
<h4 id="防抖和节流，及应用场景"><a href="#防抖和节流，及应用场景" class="headerlink" title="防抖和节流，及应用场景"></a>防抖和节流，及应用场景</h4><p>防抖和节流都是用于控制函数执行频率的技术，它们的应用场景如下：</p>
<ol>
<li><strong>防抖（Debouncing）</strong>：防抖是指在一段时间内，多次触发同一个函数，只执行最后一次触发的函数。防抖通常用于处理用户输入，比如搜索框输入、滚动事件等。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;  </span><br><span class="line">  <span class="keyword">let</span> timer;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;  </span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;  </span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);  </span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">      func.<span class="title function_">apply</span>(context, args);  </span><br><span class="line">    &#125;, delay);  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> searchInput = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#search-input&#x27;</span>);  </span><br><span class="line">searchInput.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="title function_">debounce</span>(handleSearch, <span class="number">500</span>));  </span><br></pre></td></tr></table></figure>

<ol>
<li><strong>节流（Throttling）</strong>：节流是指在一段时间内，多次触发同一个函数，只执行一次函数。节流通常用于处理高频事件，比如鼠标移动、窗口调整等。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, delay</span>) &#123;  </span><br><span class="line">  <span class="keyword">let</span> timer;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;  </span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;  </span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;  </span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">        func.<span class="title function_">apply</span>(context, args);  </span><br><span class="line">        timer = <span class="literal">null</span>;  </span><br><span class="line">      &#125;, delay);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="title function_">throttle</span>(handleResize, <span class="number">500</span>));  </span><br></pre></td></tr></table></figure>



<h4 id="大量加载数据怎么优化，怎么避免滚动条滚动"><a href="#大量加载数据怎么优化，怎么避免滚动条滚动" class="headerlink" title="大量加载数据怎么优化，怎么避免滚动条滚动"></a>大量加载数据怎么优化，怎么避免滚动条滚动</h4><ol>
<li><strong>分页加载</strong>：将数据分成多个页面，只在用户需要时加载当前页面的数据。这样可以减少一次性加载大量数据带来的性能问题。</li>
<li><strong>虚拟滚动</strong>：使用虚拟滚动技术，只渲染可见区域内的部分数据，而不是全部数据。这种方式可以减少 DOM 元素数量，提高页面渲染性能。</li>
<li><strong>懒加载</strong>：在用户向下滚动时才进行数据加载，而不是一开始就加载所有内容。这样可以延迟实际需要显示的内容的加载时间。</li>
<li><strong>增量式加载</strong>：根据用户操作实时请求新的数据，并将它们添加到已有列表中，而不是重新获取整个列表。</li>
<li><strong>前端缓存</strong>：如果可能，在前端进行缓存以避免重复请求相同资源，并且优先从缓存中获取所需信息。</li>
<li><strong>后端优化</strong>：对于大型数据库查询或跨网络请求，请确保后端服务具备高效率和合理响应时间。</li>
<li><strong>索引和分片</strong>（针对数据库）: 如果你使用数据库，则确保表上有适当地索引以提高检索速度，并且考虑将大表切割成小片段以加快查询速度。</li>
<li><strong>压缩传输</strong>: 如果你从后端服务器获得了大量静态资源（如图片、视频等），请确保它们被适当地压缩和传输到客户端，以减小网络负载和加快下载速度。</li>
</ol>
<h4 id="图片懒加载和列表虚拟滚动怎么实现"><a href="#图片懒加载和列表虚拟滚动怎么实现" class="headerlink" title="图片懒加载和列表虚拟滚动怎么实现"></a>图片懒加载和列表虚拟滚动怎么实现</h4><p><strong>图片懒加载</strong></p>
<ol>
<li>将页面上的图片的 <code>src</code> 属性设置为占位符，例如一个空白的透明图片。</li>
<li>监听页面滚动事件，或者使用 Intersection Observer API 监听图片元素是否进入可视区域。</li>
<li>当图片进入可视区域时，将图片的 <code>src</code> 属性设置为实际的图片地址，从而触发图片加载。</li>
</ol>
<p><strong>列表虚拟滚动</strong></p>
<ol>
<li>获取列表的总高度和每个列表项的高度。</li>
<li>根据可视区域的高度计算出可见的列表项数量。</li>
<li>根据滚动位置计算出当前可见的列表项的起始索引。</li>
<li>只渲染当前可见的列表项，而不渲染整个列表。</li>
<li>随着用户滚动列表，动态更新可见列表项的内容。</li>
</ol>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包的核心概念是函数和其词法环境的组合。在函数内部定义函数，函数内部引用外部作用域的变量，形成闭包。<br>应用场景：1. 保存状态  2.封装私有变量  3. 延迟执行 3.模块化</p>
<h4 id="原生js创建自定义事件"><a href="#原生js创建自定义事件" class="headerlink" title="原生js创建自定义事件"></a>原生js创建自定义事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个名为 &quot;customEvent&quot; 的自定义事件  </span></span><br><span class="line"><span class="keyword">const</span> customEvent = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;customEvent&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要监听该事件的地方添加监听器  </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;customEvent&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Custom event triggered&#x27;</span>);  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发自定义事件  </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(customEvent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以使用 CustomEvent 构造函数来创建包含更多信息（如数据）的更复杂的自定义事件：</span></span><br><span class="line"><span class="keyword">const</span> eventData = &#123; <span class="attr">message</span>: <span class="string">&#x27;Hello, this is a custom event&#x27;</span> &#125;;  </span><br><span class="line"><span class="keyword">const</span> customEvent = <span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="string">&#x27;customEvent&#x27;</span>, &#123; <span class="attr">detail</span>: eventData &#125;);  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;customEvent&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Custom event triggered with message: <span class="subst">$&#123;event.detail.message&#125;</span>`</span>);  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(customEvent);</span><br></pre></td></tr></table></figure>



<h4 id="文件上传怎么做预览"><a href="#文件上传怎么做预览" class="headerlink" title="文件上传怎么做预览"></a>文件上传怎么做预览</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fileInput&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;preview&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    	<span class="comment">// 获取文件输入元素和预览容器  </span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>);  </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> preview = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;preview&#x27;</span>);  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 监听文件输入元素的变化事件  </span></span></span><br><span class="line"><span class="language-javascript">        fileInput.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 获取用户选择的文件  </span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> file = fileInput.<span class="property">files</span>[<span class="number">0</span>];  </span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 创建 FileReader 对象  </span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 当读取完成时触发 onload 事件  </span></span></span><br><span class="line"><span class="language-javascript">          reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 创建新的 Image 对象  </span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();  </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 将读取的文件内容设置为图片的 src 属性  </span></span></span><br><span class="line"><span class="language-javascript">            img.<span class="property">src</span> = e.<span class="property">target</span>.<span class="property">result</span>;  </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 清空预览容器并添加图片  </span></span></span><br><span class="line"><span class="language-javascript">            preview.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;  </span></span><br><span class="line"><span class="language-javascript">            preview.<span class="title function_">appendChild</span>(img);  </span></span><br><span class="line"><span class="language-javascript">          &#125;;  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 如果用户选择了文件，则读取文件内容并生成预览  </span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (file) &#123;  </span></span><br><span class="line"><span class="language-javascript">            reader.<span class="title function_">readAsDataURL</span>(file);  </span></span><br><span class="line"><span class="language-javascript">          &#125;  </span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="文件秒传怎么实现"><a href="#文件秒传怎么实现" class="headerlink" title="文件秒传怎么实现"></a>文件秒传怎么实现</h4><p>文件秒传是一种常见的文件上传优化技术，可以在用户重复上传相同文件时，通过检查文件的哈希值或其他标识，实现直接跳过上传步骤，从而大幅提升用户体验。</p>
<h4 id="切片上传"><a href="#切片上传" class="headerlink" title="切片上传"></a>切片上传</h4><ul>
<li>触发input上传事件</li>
<li>获取上传文件对象</li>
<li>创建分片数据</li>
<li>文件内容创建hash</li>
<li>调用发送分片接口</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;upload&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.bootcdn.net/ajax/libs/spark-md5/3.0.2/spark-md5.min.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.7.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取元素节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;upload&quot;</span>);  </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 监听input</span></span></span><br><span class="line"><span class="language-javascript">        input.<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">event</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取文件信息 </span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> file = event.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> fileName = event.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>].<span class="property">fileName</span>;  </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 创建分片 以50M 为一个分片</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> chunks = <span class="title function_">createChunk</span>(file, <span class="number">50</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 为上传文件创建hash</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">hash</span>(chunks);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 调用上传接口</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">uploadChunk</span>(chunks, hash, fileName);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 分片存储</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">createChunk</span>(<span class="params">file, chunkSize</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> result = []</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;file.<span class="property">size</span>;i += chunkSize)&#123;</span></span><br><span class="line"><span class="language-javascript">                result.<span class="title function_">push</span>(file.<span class="title function_">slice</span>(i, i + chunkSize))</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> result;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建hash值</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">hash</span>(<span class="params">chunks</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> spark = <span class="keyword">new</span> <span class="title class_">SparkMD5</span>()</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">function</span> <span class="title function_">_read</span>(<span class="params">index</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span>(i &gt;= chunks.<span class="property">length</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">resolve</span>(spark.<span class="title function_">end</span>())</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                    </span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">let</span> blob = chunks[index]</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">let</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>()</span></span><br><span class="line"><span class="language-javascript">                    reader.<span class="property">onload</span> = <span class="function"><span class="params">e</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> byters = e.<span class="property">target</span>.<span class="property">result</span>;</span></span><br><span class="line"><span class="language-javascript">                        spark.<span class="title function_">append</span>(bytes)</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">_read</span>(i+<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                    reader.<span class="title function_">readAsArrayBuffer</span>(blob)</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">_read</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 分片上传</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">uploadChunk</span>(<span class="params">chunks, hash, fileName</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 遍历上传</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> taskArr=[];</span></span><br><span class="line"><span class="language-javascript">            chunk.<span class="title function_">forEash</span>(<span class="function">(<span class="params">chunk, index</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> formdata = <span class="keyword">new</span> <span class="title class_">FromData</span>();</span></span><br><span class="line"><span class="language-javascript">                formdata.<span class="title function_">append</span>(<span class="string">&#x27;chunk&#x27;</span>,chunk);</span></span><br><span class="line"><span class="language-javascript">                formdata.<span class="title function_">append</span>(<span class="string">&#x27;chunkName&#x27;</span>, <span class="string">`<span class="subst">$&#123;hash&#125;</span>-<span class="subst">$&#123;index&#125;</span>-<span class="subst">$&#123;fileName&#125;</span>`</span>)</span></span><br><span class="line"><span class="language-javascript">                formdata.<span class="title function_">append</span>(<span class="string">&#x27;fileName&#x27;</span>,fileName)</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> task = axios.<span class="title function_">post</span>(<span class="string">&#x27;https://127.0.0.1:3000/&#x27;</span>, fromdata, &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">headers</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;)</span></span><br><span class="line"><span class="language-javascript">                taskArr.<span class="title function_">push</span>(task)</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Promise</span>.<span class="title function_">all</span>(taskArr)</span></span><br><span class="line"><span class="language-javascript">                .<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;通知后端，上传完毕，合并数据&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">                .<span class="title function_">catch</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="一个10g文件怎么进行分片，怎么确定合适的分片大小，分片hash过程怎么优化"><a href="#一个10g文件怎么进行分片，怎么确定合适的分片大小，分片hash过程怎么优化" class="headerlink" title="一个10g文件怎么进行分片，怎么确定合适的分片大小，分片hash过程怎么优化"></a>一个10g文件怎么进行分片，怎么确定合适的分片大小，分片hash过程怎么优化</h4><p><strong>实现步骤：</strong></p>
<ol>
<li>确定分片大小：分片大小应该根据网络带宽、服务器性能和文件大小等因素进行调整。通常情况下，分片大小应该在 1MB 到 10MB 之间。如果分片过小，会增加网络请求的次数，导致上传或下载速度变慢；如果分片过大，会增加服务器的负担，导致上传或下载失败。</li>
<li>计算分片数量：根据文件大小和分片大小计算出需要分成多少个分片。</li>
<li>分片上传或下载：将文件分成多个分片，分别上传或下载。在上传或下载过程中，需要记录每个分片的状态，以便在上传或下载失败时进行重试。</li>
<li>合并分片：在所有分片上传或下载完成后，将所有分片合并成一个完整的文件。</li>
</ol>
<h4 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h4><p>断点续传是指在上传或下载文件时，如果因为网络中断或其他原因导致上传或下载失败，可以从上次失败的位置继续上传或下载，而不需要重新开始。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li>在上传或下载过程中，记录已经上传或下载的字节数。</li>
<li>如果上传或下载失败，可以使用已经上传或下载的字节数来计算出需要继续上传或下载的位置。</li>
<li>从上次失败的位置继续上传或下载。</li>
<li>在上传或下载完成后，将所有分片合并成一个完整的文件。</li>
</ol>
<h4 id="上拉刷新，下拉加载"><a href="#上拉刷新，下拉加载" class="headerlink" title="上拉刷新，下拉加载"></a>上拉刷新，下拉加载</h4><p>使用scroll事件，您可以实现以下功能：</p>
<ol>
<li>监听滚动位置：通过scroll事件可以获取滚动条的位置信息，例如滚动条的垂直滚动位置（scrollTop）或水平滚动位置（scrollLeft）。</li>
<li>实现无限滚动：通过监听scroll事件，可以在滚动到页面底部时自动加载更多内容，实现无限滚动效果。这在需要展示大量数据的网页或应用中很常见。</li>
<li>实现懒加载：通过监听scroll事件，可以判断元素是否进入可视区域，从而实现图片或其他资源的懒加载。当用户滚动到包含懒加载元素的位置时，再加载相应的内容，以提高页面加载速度和性能。</li>
<li>实现滚动动画：通过监听scroll事件，可以根据滚动条的位置实现各种滚动动画效果，例如导航栏的固定、滚动时的渐变效果等。</li>
</ol>
<p><strong>上拉刷新：</strong></p>
<ul>
<li>当用户向上滑动页面时，检测到滑动距离达到一定阈值时，触发数据的刷新操作。</li>
<li>可以使用JavaScript监听<code>scroll</code>事件来监测页面滚动位置，并在特定条件下执行数据更新操作。</li>
<li>也可以借助第三方插件或框架（如React Native中的FlatList组件）提供的上拉刷新功能。</li>
</ul>
<p><strong>下拉加载：</strong></p>
<ul>
<li>当用户向下滑动页面至底部时，触发加载更多内容的操作。</li>
<li>同样可以利用JavaScript监听<code>scroll</code>事件并结合页面高度、滚动位置等信息来实现。</li>
<li>也可以使用第三方库或框架提供的下拉加载功能（比如Vue.js中的Infinite Scroll插件）。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>上拉刷新、下拉加载示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css">  </span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 样式用于显示loading状态 */</span>  </span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.loading</span> &#123;  </span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-align</span>: center;  </span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">20px</span>;  </span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-weight</span>: bold;  </span></span><br><span class="line"><span class="language-css">    &#125;  </span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:500px; overflow-y:auto;&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!-- 动态数据内容 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 这里是动态数据列表 --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 加载更多提示信息 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;loadMore&quot;</span> <span class="attr">class</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span>向上滑动以加载更多内容...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 模拟的动态数据  </span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> data = [<span class="string">&#x27;Item1&#x27;</span>, <span class="string">&#x27;Item2&#x27;</span>, <span class="string">&#x27;Item3&#x27;</span>];  </span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> currentPage = <span class="number">1</span>;  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 下拉加载更多  </span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">scrollTop</span> + <span class="variable language_">this</span>.<span class="property">clientHeight</span> &gt;= <span class="variable language_">this</span>.<span class="property">scrollHeight</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">loadMore</span>();  </span></span><br><span class="line"><span class="language-javascript">   &#125;  </span></span><br><span class="line"><span class="language-javascript">&#125;);  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">loadMore</span>(<span class="params"></span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">   <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;loadMore&#x27;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;  </span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// 模拟异步请求新数据（假设通过API获取新数据）  </span></span></span><br><span class="line"><span class="language-javascript">   <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">let</span> newData = [<span class="string">&#x27;New Item &#x27;</span> + (currentPage * data.<span class="property">length</span> + i) <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="title class_">Array</span>(<span class="number">5</span>))];  </span></span><br><span class="line"><span class="language-javascript">       <span class="comment">// 将新增数据添加到页面中  </span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">let</span> contentDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;content&#x27;</span>);  </span></span><br><span class="line"><span class="language-javascript">       newData.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;  </span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">let</span> newItemNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;DIV&quot;</span>);  </span></span><br><span class="line"><span class="language-javascript">           newItemNode.<span class="property">innerText</span> = item;  </span></span><br><span class="line"><span class="language-javascript">           contentDiv.<span class="title function_">appendChild</span>(newItemNode);  </span></span><br><span class="line"><span class="language-javascript">       &#125;);  </span></span><br><span class="line"><span class="language-javascript">       </span></span><br><span class="line"><span class="language-javascript">       currentPage++;  </span></span><br><span class="line"><span class="language-javascript">       </span></span><br><span class="line"><span class="language-javascript">       <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;loadMore&#x27;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;  </span></span><br><span class="line"><span class="language-javascript">   &#125;, <span class="number">1000</span>); <span class="comment">// 模拟延时请求  </span></span></span><br><span class="line"><span class="language-javascript">&#125;  </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="web常见攻击方式，如何预防"><a href="#web常见攻击方式，如何预防" class="headerlink" title="web常见攻击方式，如何预防"></a>web常见攻击方式，如何预防</h4><p>SQL注入、跨站脚本（XSS）、跨站请求伪造（CSRF）、点击劫持等。</p>
<ol>
<li>SQL注入：避免使用动态拼接SQL语句，而是使用参数化查询或者ORM框架来处理数据库操作；对用户输入进行严格验证和过滤，确保不含恶意代码。</li>
<li>跨站脚本（XSS）：对用户输入进行HTML编码或转义，以防止恶意脚本在页面中执行；设置安全的HTTP头部来减少XSS风险。</li>
<li>跨站请求伪造（CSRF）：使用随机生成的令牌来验证表单提交和重要操作的合法性；通过SameSite Cookie属性限制Cookie在跨域请求中发送。</li>
<li>点击劫持：通过设置X-Frame-Options头部或Content Security Policy (CSP) 来防止网页被嵌入到iframe中，并显示一个透明图层以遮挡可能存在于该页面上方其他内容。</li>
<li>授权和身份验证控制：强化用户认证流程、实施多因素身份验证，并且采用最小权限原则，只给予用户必要的权限。</li>
</ol>
<h4 id="js执行上下文和执行栈"><a href="#js执行上下文和执行栈" class="headerlink" title="js执行上下文和执行栈"></a>js执行上下文和执行栈</h4><blockquote>
<ul>
<li><strong>执行上下文</strong> 是代码运行时的环境，可以是全局的或函数的，每个上下文都有自己的变量环境、词法环境和 <code>this</code> 值。</li>
<li><strong>执行栈</strong> 是管理执行上下文的结构，负责跟踪当前正在执行的上下文，以及控制函数调用的顺序。</li>
</ul>
</blockquote>
<p>​	<strong>执行上下文</strong></p>
<p>代表了在某个特定地方运行的代码环境。每当 JavaScript 代码运行时，都会创建一个新的执行上下文。</p>
<ul>
<li>三个主要部分<ul>
<li><strong>变量环境</strong></li>
<li><strong>词法环境</strong></li>
<li><strong><code>this</code> 值</strong></li>
</ul>
</li>
<li>类型<ul>
<li><strong>全局执行上下文</strong></li>
<li><strong>函数执行上下文</strong></li>
<li><strong><code>eval</code> 执行上下文</strong></li>
</ul>
</li>
</ul>
<p>​	<strong>执行栈</strong></p>
<ul>
<li>工作原理<ul>
<li><strong>入栈</strong></li>
<li><strong>出栈</strong></li>
<li><strong>当前上下文</strong></li>
</ul>
</li>
</ul>
<h4 id="函数缓存"><a href="#函数缓存" class="headerlink" title="函数缓存"></a>函数缓存</h4><p>是一种优化技术，用于存储函数计算结果，从而避免重复计算。类似于框架中的计算属性。</p>
<p>​	<strong>应用场景</strong></p>
<ol>
<li>计算密集型函数： 耗时的计算</li>
<li>数据处理或转化：比如格式化日期、字符串处理等，可以缓存已经处理的结果，减少重复处理的开销。</li>
<li>组件渲染</li>
</ol>
<h4 id="js数据结构的了解"><a href="#js数据结构的了解" class="headerlink" title="js数据结构的了解"></a>js数据结构的了解</h4><p>JavaScript 中常用的数据结构主要包括数组、对象、Set、Map、WeakSet 和 WeakMap</p>
<ol>
<li><strong>数组 (Array)</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：有序的元素集合，可以存储任意类型的值。</p>
</li>
<li><p>特性</p>
<p>：</p>
<ul>
<li>动态大小，可以根据需要增加或减少元素。</li>
<li>支持多种数组方法，如 <code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>map</code>、<code>filter</code>等。</li>
<li>数组元素的索引从 0 开始。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：适合用于需要有序存储的数据，例如列表、队列等。</p>
</li>
</ul>
<ol start="2">
<li><strong>对象 (Object)</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：无序的键值对集合，用于存储相关的数据。</p>
</li>
<li><p>特性</p>
<p>：</p>
<ul>
<li>键是字符串（ES6 引入了 Symbol 类型作为键），值可以是任意类型。</li>
<li>对象的属性是动态的，可以随时添加、修改或删除。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：适合用于存储和组织与某个实体相关的信息，例如用户信息、配置选项等。</p>
</li>
</ul>
<ol start="3">
<li><strong>Set</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：代表一组唯一值的集合。</p>
</li>
<li><p>特性</p>
<p>：</p>
<ul>
<li>不允许重复值，自动去重。</li>
<li>支持基本的集合操作：添加、删除、判断是否存在。</li>
<li>迭代时元素的顺序为插入顺序。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：适用于需要保证唯一性的数据集合，例如用户活动记录、标签等。</p>
</li>
</ul>
<ol start="4">
<li><strong>Map</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：一个键值对的集合，其中键可以是任意类型（不局限于字符串）。</p>
</li>
<li><p>特性</p>
<ul>
<li>保持插入的顺序。</li>
<li>支持任何类型的值作为键。</li>
<li>提供了 <code>set</code>、<code>get</code>、<code>has</code>、<code>delete</code> 等方法来操作键值对。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：适合用于需要快速查找和更新的场景，例如存储频繁更新的配置或数据。</p>
</li>
</ul>
<ol start="5">
<li><strong>WeakSet</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：与 Set 类似，但其元素是弱引用。</p>
</li>
<li><p>特性</p>
<ul>
<li>只能存储对象类型的值。</li>
<li>当对象没有引用时，它们可能会被垃圾回收。</li>
<li>没有常规的遍历操作。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：适用于需要存储某些对象的集合，但不想阻止其被垃圾回收的场景。</p>
</li>
</ul>
<ol start="6">
<li><strong>WeakMap</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：与 Map 类似，但其键是弱引用。</p>
</li>
<li><p>特性</p>
<ul>
<li>键只能是对象，值可以是任意类型。</li>
<li>当对象没有其他引用时，可以被垃圾回收。</li>
<li>也没有常规的遍历操作。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：适用于需要关联某些对象数据，但又不希望阻止这些键对象被垃圾回收的场合。</p>
</li>
</ul>
<h4 id="DOM-BOM常见操作"><a href="#DOM-BOM常见操作" class="headerlink" title="DOM&#x2F;BOM常见操作"></a>DOM&#x2F;BOM常见操作</h4><p>DOM 提供了访问和操作 HTML 和 XML 文档的标准接口<br>而 BOM 提供了与浏览器进行交互的方法和接口。</p>
<p><strong>常见 DOM 操作</strong></p>
<ol>
<li><p><strong>选择元素</strong> </p>
<ul>
<li>通过 ID 选择单个元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = document.getElementById(&#x27;myId&#x27;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>通过类名选择多个元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const elements = document.getElementsByClassName(&#x27;myClass&#x27;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>通过标签名选择多个元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const elements = document.getElementsByTagName(&#x27;div&#x27;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>通过 CSS 选择器选择单个元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = document.querySelector(&#x27;.myClass&#x27;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>通过 CSS 选择器选择多个元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const elements = document.querySelectorAll(&#x27;div.myClass&#x27;);  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建和添加元素</strong></p>
<ul>
<li><p>创建新元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const newElement = document.createElement(&#x27;div&#x27;);  </span><br></pre></td></tr></table></figure>
</li>
<li><p>添加子元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const parentElement = document.getElementById(&#x27;parent&#x27;);  </span><br><span class="line">parentElement.appendChild(newElement);  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>修改元素内容和属性</strong></p>
<ul>
<li><p>修改文本内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.textContent = &#x27;新内容&#x27;;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 HTML 内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.innerHTML = &#x27;&lt;span&gt;新内容&lt;/span&gt;&#x27;;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>修改属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.setAttribute(&#x27;class&#x27;, &#x27;newClass&#x27;);  </span><br><span class="line">element.style.color = &#x27;red&#x27;; // 修改样式  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>删除元素</strong></p>
<ul>
<li><p>删除子元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentElement.removeChild(childElement);  </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用remove()方法删除元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.remove();  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>事件处理</strong></p>
<ul>
<li><p>添加事件监听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&#x27;click&#x27;, function() &#123;  </span><br><span class="line">    alert(&#x27;元素被点击了&#x27;);  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>
</li>
<li><p>移除事件监听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.removeEventListener(&#x27;click&#x27;, callback);  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>常见 BOM 操作</strong></p>
<ol>
<li><p><strong>访问浏览器信息</strong></p>
<ul>
<li><p>获取浏览器的用户代理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(navigator.userAgent);  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>控制浏览器窗口</strong></p>
<ul>
<li><p>打开新窗口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open(&#x27;https://www.example.com&#x27;, &#x27;_blank&#x27;);  </span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭当前窗口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.close();  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>定时器</strong></p>
<ul>
<li><p>启动定时器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;  </span><br><span class="line">    alert(&#x27;定时器到期&#x27;);  </span><br><span class="line">&#125;, 2000); // 2秒后弹出提示  </span><br></pre></td></tr></table></figure>
</li>
<li><p>清除定时器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearTimeout(timerId);  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>处理浏览器历史</strong></p>
<ul>
<li><p>前进到历史的下一个页面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.forward();  </span><br></pre></td></tr></table></figure>
</li>
<li><p>返回到历史的上一个页面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.back();  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>操作 URL</strong></p>
<ul>
<li><p>获取当前页面的 URL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(window.location.href);  </span><br></pre></td></tr></table></figure>
</li>
<li><p>跳转到新的 URL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.location.href = &#x27;https://www.example.com&#x27;;  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h4><p>在浏览器中，事件循环机制通常基于HTML5规范中定义的Event Loop模型。其主要包括以下几个部分：</p>
<ol>
<li><strong>调用栈</strong>：所有的同步任务都会被放入调用栈（call stack）中依次执行，形成一个执行上下文堆栈。</li>
<li><strong>消息队列</strong>：当异步任务完成后或者事件发生时，会将对应的回调函数放入消息队列（message queue）中等待被执行。</li>
<li><strong>事件循环</strong>：当调用栈为空时，会从消息队列中取出一个回调函数放入调用栈进行执行；如果消息队列为空，则等待新的回调函数加入。这样不断地将来自消息队列的任务推送到调用栈执行，这个过程就是所谓的“事件循环”。</li>
<li><strong>宏任务与微任务</strong>：为了更细致地控制异步操作，在每次完成一个宏观任务后都有可能需要去清空微观任务列表。因此对于每一轮循环而言，在取出并执行完一个宏观任务之后还需要检查是否有微观任务需要清空。<ul>
<li><strong>宏任务</strong>：包括整体代码块、setTimeout、setInterval、I&#x2F;O 操作等。宏任务在每次事件循环中只能执行一个，执行完毕后才会执行下一个宏任务。</li>
<li><strong>微任务</strong>：包括 Promise、MutationObserver 等。微任务在每个宏任务执行完毕后立即执行，且在下一个宏任务之前执行完毕。</li>
</ul>
</li>
</ol>
<p>事件循环机制的执行顺序可以总结为：</p>
<ol>
<li>执行当前执行栈中的同步代码。微任务，宏任务加入消息队列</li>
<li>检查微任务队列，依次执行所有微任务。微任务，宏任务加入消息队列</li>
<li>更新渲染（如果需要）。</li>
<li>执行宏任务队列中的一个任务。微任务，宏任务加入消息队列</li>
<li>重复上述步骤。</li>
</ol>
<h4 id="宏任务之间的优先级"><a href="#宏任务之间的优先级" class="headerlink" title="宏任务之间的优先级"></a>宏任务之间的优先级</h4><p>宏任务是指由浏览器提供的任务队列中的任务，例如定时器回调、用户交互事件处理、网络请求等。</p>
<p>在事件循环中，宏任务按照以下优先级依次执行：(各个浏览器厂商可能也有自己特定实现细节。)</p>
<ol>
<li>用户交互相关的宏任务（例如鼠标点击、键盘输入等）：这些任务通常具有最高优先级，因为用户交互响应性对于用户体验非常重要。</li>
<li>定时器和计时器相关的宏任务：这些包括 <code>setTimeout</code>、<code>setInterval</code> 等函数创建的异步操作。</li>
<li>I&#x2F;O 与网络请求相关的宏任务：例如异步加载资源或发送网络请求所产生的回调。</li>
<li>渲染：更新页面渲染所需要执行的宏任务。</li>
</ol>
<h4 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h4><h4 id="sql调优"><a href="#sql调优" class="headerlink" title="sql调优"></a>sql调优</h4><p>SQL 调优是优化 SQL 查询性能的过程，旨在提高查询的执行效率和响应时间</p>
<ol>
<li>确保正确的索引：在频繁用于查询条件或连接的列上创建索引，可以大大提高查询效率。</li>
<li>优化查询语句：避免使用通配符操作符（如 <code>%</code>）开头的模糊查询，尽量使用前缀索引、范围查询等更高效的方式。</li>
<li>减少返回的数据量：只选择需要的列，避免 SELECT *，限制返回的行数，利用 LIMIT 子句进行分页等。</li>
<li>消除冗余查询：尽量避免重复查询相同的数据，利用子查询或者 JOIN 语句合并查询。</li>
<li>使用合适的连接方式：根据查询逻辑选择正确的连接方式，如 INNER JOIN、LEFT JOIN、UNION 等。</li>
<li>避免使用函数和操作符：在 WHERE 子句中避免使用函数和操作符操作查询列，以免影响索引的使用。</li>
<li>优化 SQL 查询顺序：优化 WHERE 子句的顺序，将可过滤掉大量数据的条件放在前面，以尽早筛选不符合条件的数据。</li>
<li>分析查询执行计划：通过 EXPLAIN 命令或其他数据库工具，分析查询执行计划，找出潜在的性能瓶颈和优化点。</li>
<li>增加缓存和缓冲区：合理设置数据库的缓存和缓冲区大小，减少磁盘访问，提高数据读取速度。</li>
</ol>
<h4 id="webworker多线程可以避免阻塞，为什么不把js内容放到webworker运行"><a href="#webworker多线程可以避免阻塞，为什么不把js内容放到webworker运行" class="headerlink" title="webworker多线程可以避免阻塞，为什么不把js内容放到webworker运行"></a>webworker多线程可以避免阻塞，为什么不把js内容放到webworker运行</h4><p>将 JavaScript 代码放到 Web Worker 中运行可以避免阻塞主线程，因为 Web Worker 在单独的线程中运行，不会影响主线程的执行。这对于一些耗时的计算、大量数据处理和复杂的逻辑运算非常有用，可以提高页面的响应性能和用户体验。</p>
<p>但并不是所有的 JavaScript 代码都适合放到 Web Worker 中运行，主要原因有以下几点：</p>
<ol>
<li>Web Worker 无法访问 DOM：由于 Web Worker 运行在一个独立的线程中，无法直接访问 DOM 元素，因此无法进行 DOM 操作。如果 JavaScript 代码需要操作页面的 DOM 结构，就无法放到 Web Worker 中运行。</li>
<li>传递数据复杂：与主线程相比，Web Worker 与主线程之间的通信比较复杂，需要通过 postMessage 进行数据传递。如果需要频繁地传递大量数据，可能会带来额外的开销。</li>
<li>内存消耗问题：每个 Web Worker 都需要一定的内存开销，过多的 Web Worker 可能会导致内存消耗过大，影响页面的性能。</li>
<li>浏览器支持限制：虽然现代浏览器都支持 Web Worker，但并不是所有的浏览器都支持，特别是一些旧版本的浏览器可能存在兼容性问题。</li>
</ol>
<h4 id="SSR服务端渲染"><a href="#SSR服务端渲染" class="headerlink" title="SSR服务端渲染"></a>SSR服务端渲染</h4><p>SSR是一种用于在服务器上渲染网页，将完全渲染后的页面发送给客户端显示的一种技术。它允许服务器生成完整的html标签，包括动态内容。</p>
<p>SSR在服务器已经渲染好网页，发送给客户端，可以改善客户端初始加载时间。完整的html信息可见性，有利于搜索引擎。减少客户端需要下载的数据量。因此有利于带宽低，延迟高的用户</p>
<h4 id="SSR会存在跨域问题吗"><a href="#SSR会存在跨域问题吗" class="headerlink" title="SSR会存在跨域问题吗"></a>SSR会存在跨域问题吗</h4><p>跨域问题通常是指浏览器的同源策略导致的限制，在浏览器中运行的前端代码访问其他域下的资源时可能会受到限制。</p>
<p>对于服务器端渲染（SSR），由于是在服务器端进行页面渲染并直接返回给客户端，一般不会存在跨域问题；如果在服务器端渲染过程中有一些数据需要通过 AJAX 请求获取，那么这些异步数据的请求依然会存在跨域问题。</p>
<p>原因：当使用服务器端渲染时，浏览器向服务器请求页面时，服务器会处理模板和数据，最终返回一段已经渲染好的 HTML 页面。这个 HTML 页面中的所有资源都来自于同一个域名，不会涉及到跨域请求。</p>
<h4 id="JWT认证过程"><a href="#JWT认证过程" class="headerlink" title="JWT认证过程"></a>JWT认证过程</h4><p>JWT 的认证过程基于 Token，其中包含了被加密的用户信息和签名，使得服务器端无需在每次请求中都查询数据库或者使用 Session 来进行身份验证。客户端使用 JWT 值来标识和验证用户的身份，从而完成认证和权限控制。</p>
<p>认证过程如下：</p>
<ol>
<li>客户端发送登录请求（通常是用户名和密码）到服务器端。</li>
<li>服务器端验证用户的身份和密码是否正确。</li>
<li>如果验证通过，服务器端生成一个 JWT，并将其发送回客户端。</li>
<li>客户端收到 JWT 后，将其保存在本地（通常是在 localStorage 或者 Cookie 中）。</li>
<li>客户端在每次请求需要认证的资源时，将 JWT 放入请求头（通常是在 Authorization 头部字段中）一同发送到服务器端。</li>
<li>服务器端收到请求后，从请求头中提取 JWT。</li>
<li>服务器端对 JWT 进行验证和解析，检查签名是否合法、是否过期等。</li>
<li>如果验证通过，服务器端根据 JWT 中的信息进行相应的操作，并返回资源或执行对应的业务逻辑。</li>
</ol>
<h4 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h4><p>使用 HTTPS 协议：确保数据传输过程中是加密的。HTTPS 可以保护数据在客户端和服务器之间的传输安全，并且在网络抓包时无法直接查看明文数据。</p>
<p>前端对密码进行加密：在用户输入密码后，前端可以对密码进行加密处理（例如使用哈希函数），然后将加密后的密码发送到服务器。这样即使接口被拦截，在网络请求中也只能看到经过加密处理的数据而不是明文密码。</p>
<h4 id="讲解一下promise"><a href="#讲解一下promise" class="headerlink" title="讲解一下promise"></a>讲解一下promise</h4><p>Promise 是 JavaScript 中的一种异步编程解决方案，解决了回调函数执行异步操作的回调地狱问题。它可以让我们更方便地处理异步操作。Promise 有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p>
<p>Promise 处于 pending 状态时，可以通过调用 resolve 函数将其状态改为 fulfilled，或者通过调用 reject 函数将其状态改为 rejected。</p>
<p>当 Promise 状态改变后，就会执行对应的回调函数，即 then 方法中的第一个参数或 catch 方法中的参数。</p>
<h4 id="promise后面如果有多个值，-then-怎么传值"><a href="#promise后面如果有多个值，-then-怎么传值" class="headerlink" title="promise后面如果有多个值，.then() 怎么传值"></a>promise后面如果有多个值，.then() 怎么传值</h4><p>在 Promise 中，可以通过使用链式调用的方式，多次调用 <code>.then()</code> 方法来处理多个值。每个 <code>.then()</code> 方法可以接收前一个 Promise 的结果，并返回一个新的 Promise，从而可以实现值的传递。</p>
<h4 id="async-await理解"><a href="#async-await理解" class="headerlink" title="async await理解"></a>async await理解</h4><p><code>async/await</code> 是 ES8（ECMAScript 2017）引入的异步编程模型，是建立在 Promise 之上的语法糖，让异步代码看起来更像同步代码，更易于理解和编写。<code>async</code> 函数用于定义一个异步函数，<code>await</code> 关键字用于等待一个 Promise 对象（通常是一个异步操作），等待完成后再执行后续的代码。</p>
<p><strong><code>async</code> 函数声明：</strong> 使用 <code>async</code> 关键字声明一个函数时，该函数会自动返回一个 Promise 对象。</p>
<p><strong><code>await</code> 表达式：</strong> 在 <code>async</code> 函数中，可以使用 <code>await</code> 关键字来暂停函数的执行，等待 Promise 对象的状态改变。</p>
<p><strong>错误处理：</strong> 使用 <code>try/catch</code> 结构可以捕获 <code>async/await</code> 中的异常。在 <code>try</code> 代码块中放置可能抛出异常的代码，而在 <code>catch</code> 代码块中处理异常情况。</p>
<h4 id="async-await比promise有什么优势"><a href="#async-await比promise有什么优势" class="headerlink" title="async await比promise有什么优势"></a>async await比promise有什么优势</h4><ol>
<li><strong>更直观的代码结构：</strong> <code>async/await</code> 使异步代码看起来更像同步代码，使得代码结构更加直观和易于理解。通过使用 <code>await</code> 关键字，可以在代码中明确地指定等待异步操作的结果，而不需要使用回调函数或链式调用。</li>
<li><strong>更容易处理错误：</strong> 在使用 <code>async/await</code> 时，可以使用 <code>try/catch</code> 结构来捕获和处理异常。这使得错误处理更加简洁和可读，而不需要在每个 Promise 链中都使用 <code>.catch()</code> 方法来处理错误。</li>
<li><strong>更好的错误堆栈追踪：</strong> <code>async/await</code> 可以提供更好的错误堆栈追踪，使得在出现错误时更容易定位问题所在。相比于 Promise 的链式调用，<code>async/await</code> 可以在出错的地方直接抛出异常，而不需要在每个 <code>.then()</code> 方法中手动抛出错误。</li>
<li><strong>更灵活的控制流：</strong> <code>async/await</code> 允许使用常规的控制流语句（如条件语句和循环语句），使得在异步操作之间进行逻辑控制更加灵活。这使得编写复杂的异步代码变得更加容易。</li>
</ol>
<h4 id="async-await的底层原理"><a href="#async-await的底层原理" class="headerlink" title="async await的底层原理"></a>async await的底层原理</h4><p>底层原理其实是基于 Promise 和生成器（Generator）的。</p>
<ol>
<li><code>async</code> 函数本质上是返回一个 Promise 对象，这个 Promise 对象的状态和值由 <code>async</code> 函数内部的代码决定。</li>
<li>在 <code>async</code> 函数内部使用 <code>await</code> 关键字时，其后的表达式会被封装为一个 Promise 对象，并等待该 Promise 对象的状态改变。</li>
<li>当 <code>await</code> 后面的 Promise 对象变为 resolved（已解决）状态时，<code>await</code> 表达式会返回 Promise 对象的解决值，然后程序会继续执行 <code>await</code> 后面的代码。</li>
<li>如果 <code>await</code> 后面的 Promise 对象变为 rejected（拒绝）状态，则会抛出一个异常，可以使用 <code>try/catch</code> 来捕获并处理异常。</li>
<li>生成器函数允许函数在执行过程中暂停，并在需要时回复。<code>async/await</code> 在底层会使用生成器函数来实现异步操作的暂停和回复。</li>
</ol>
<h4 id="generator的原理"><a href="#generator的原理" class="headerlink" title="generator的原理"></a>generator的原理</h4><p>Generator 是 JavaScript 中的一种特殊函数，它可以在执行过程中暂停并恢复。Generator 函数使用 <code>function*</code> 关键字进行声明，并使用 <code>yield</code> 关键字来定义暂停点。</p>
<p>Generator 函数的原理是通过迭代器（Iterator）的概念来实现的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">myGenerator</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;  </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;  </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = <span class="title function_">myGenerator</span>();  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="pnpm软连接和硬链接区别"><a href="#pnpm软连接和硬链接区别" class="headerlink" title="pnpm软连接和硬链接区别"></a>pnpm软连接和硬链接区别</h4><p>软链接（Symbolic Link）和硬链接（Hard Link）是在文件系统中用于创建链接到文件或目录的两种不同方式。</p>
<p>软链接（Symbolic Link）：</p>
<ol>
<li>软链接是一个独立的文件，其中包含一个指向另一个文件或目录的路径（绝对路径或相对路径）。</li>
<li>创建软链接时，源文件和链接之间是两个不同的文件，源文件的内容不会被复制到链接文件中，只是通过路径关联。</li>
<li>软链接可以跨文件系统，即可以跨越不同的物理硬盘或分区。</li>
<li>当源文件被删除或移动，软链接仍然保留，但软链接失效。</li>
<li>软链接可以用来创建指向文件或目录的符号链接。</li>
</ol>
<p>硬链接（Hard Link）：</p>
<ol>
<li>硬链接是文件系统中对同一个文件或目录的多个链接，它们共享相同的数据块。</li>
<li>创建硬链接时，不会创建新的文件，只是在文件系统中创建一个新的目录条目指向相同的 inode 节点。</li>
<li>硬链接只能在同一个文件系统中创建，即源文件和硬链接需要在同一文件系统内。</li>
<li>当所有硬链接都被删除后，文件才会被完全删除，并释放磁盘空间。</li>
<li>硬链接不能指向目录，只能指向文件。</li>
</ol>
<h4 id="pnpm-hoist机制"><a href="#pnpm-hoist机制" class="headerlink" title="pnpm hoist机制"></a>pnpm hoist机制</h4><p>pnpm 的 hoist 机制是一种优化依赖结构的方式，旨在减少存储空间和提高性能。<br>在传统的 npm 或者 Yarn 安装方式中，每个项目都会在其根目录下创建一个 node_modules 目录，并将所有的依赖包都安装在其中。这样的结果是，不同的项目会包含相同的依赖包的多个副本，造成存储空间的浪费。<br>而 pnpm 的 hoist 机制则将多个项目的依赖包按照相同的版本整理到一个公共的存储位置（称为 store）。具体来说，当一个包被多个项目依赖时，pnpm 会自动将这个包安装到存储位置，并创建软链接到各个项目的 node_modules 目录下。</p>
<p>流程：</p>
<ol>
<li>安装过程中，当 pnmp 发现某个依赖包在多个项目中重复出现时，它将该依赖包安装到公共存储位置（store）中，并为每个项目创建一个软链接到依赖包。</li>
<li>对于每个项目，pnpm 会在其根目录下创建一个特殊的 <code>.pnpm</code> 目录，该目录下包含一个 packages 软链接文件夹，其中存储了所有项目所依赖的包的软链接。</li>
<li>当项目需要使用某个依赖包时，pnpm 会根据软链接的路径找到对应的包。</li>
</ol>
<p>优点：</p>
<ul>
<li>节省存储空间：依赖包只会被下载一次，多个项目共享一个副本。</li>
<li>提高性能：在安装和更新依赖时，减少了 I&#x2F;O 操作，更快地完成配置。</li>
</ul>
<p>缺点：</p>
<p>pnpm hoist 机制可能会在某些情况下引发依赖冲突问题。在这种情况下，可以使用 pnmp 提供的工具来解决冲突，如 <code>pnpm recursive list</code> 可以列出所有项目的依赖关系树，并帮助找到冲突的依赖包版本。</p>
<h4 id="pnpm包的结构，三层寻址"><a href="#pnpm包的结构，三层寻址" class="headerlink" title="pnpm包的结构，三层寻址"></a>pnpm包的结构，三层寻址</h4><p>pnpm 是一个基于 npm 的包管理工具</p>
<p>它的包结构和寻址分为以下几层：</p>
<ol>
<li>根目录层：根目录层是指项目的根目录，也是 package.json 文件所在的目录。这一层主要包含一个 package.json 文件，用来记录项目的依赖关系和其他相关配置信息。</li>
<li>存储目录层：存储目录层是指存放依赖包代码的目录。pnpm 的存储目录层并不是像 npm 那样将所有依赖包放在一个统一的目录下，而是根据依赖包的名称、版本和 hash 值来生成不同的路径存放不同的依赖包。这样的做法可以有效减少存储空间的使用，同时也保证了依赖包的唯一性。</li>
<li>软链接层：软链接层是指通过软链接将依赖包连接到项目的 node_modules 目录下。当代码需要引用依赖包时，实际上是通过软链接层来找到依赖包的代码。pnpm 使用软链接的方式可以减少重复的依赖包拷贝，同时提供了更快更节省空间的安装和运行速度。</li>
</ol>
<p><strong>三层寻址</strong></p>
<p>三层寻址的过程如下：</p>
<ol>
<li>从根目录的 package.json 文件中读取项目的依赖关系。</li>
<li>根据依赖包的名称和版本等信息，在存储目录层中查找对应的依赖包。</li>
<li>将找到的依赖包通过软链接层连接到项目的 node_modules 目录下。</li>
</ol>
<p>通过三层寻址，可以在保证依赖包唯一性的同时，提高包的安装和运行效率。</p>
<h4 id="什么事幽灵依赖，会引发什么问题"><a href="#什么事幽灵依赖，会引发什么问题" class="headerlink" title="什么事幽灵依赖，会引发什么问题"></a>什么事幽灵依赖，会引发什么问题</h4><p>幽灵依赖是指在项目中存在但未在 package.json 文件中明确声明的依赖包或依赖关系。这种情况通常发生在项目代码中引入了某些依赖包，但没有及时在 package.json 文件中添加对应的依赖项。</p>
<p>会引发以下问题：</p>
<ol>
<li>不稳定的构建：由于幽灵依赖没能被明确标识在 package.json 文件中，项目的构建可能会出现不稳定性。每次安装依赖包时，依赖关系可能会发生变化，导致构建结果不一致。</li>
<li>版本不一致：没有在 package.json 中明确声明依赖关系可能会导致依赖包的版本不一致。在不同的环境中，可能会出现依赖包的不同版本被使用，从而导致代码在不同环境下表现不一致或出现功能错误。</li>
<li>安全隐患：幽灵依赖可能会带来安全隐患。如果项目中存在未声明的依赖包，且这些依赖包存在安全漏洞，攻击者可能会利用这些漏洞对项目进行攻击或注入恶意代码。</li>
<li>维护困难：在项目中存在大量幽灵依赖会增加代码的维护难度。随着项目的变大，难以追踪项目实际使用的依赖包，导致代码可读性和可维护性降低</li>
</ol>
<h4 id="package-A-和package-B-依赖同一个包，却不同版本，如何统一版本"><a href="#package-A-和package-B-依赖同一个包，却不同版本，如何统一版本" class="headerlink" title="package A 和package B 依赖同一个包，却不同版本，如何统一版本"></a>package A 和package B 依赖同一个包，却不同版本，如何统一版本</h4><ol>
<li>升级包：查看 A、B 两个包所依赖的包 C 分别的版本范围，如果范围存在交集，可以尝试将 A、B 中所依赖的包 C 版本范围升级到一个兼容的、相同的版本。这可以通过修改 A、B 的 package.json 文件中对包 C 的版本范围进行修改来实现。然后重新安装依赖并测试，确保项目能够正常运行。</li>
<li>更新依赖：如果升级包 C 的版本并不可行，可以尝试升级 A、B 包本身，以便它们能依赖同一个包 C 的相同版本。这可以通过修改 A、B 的 package.json 文件中对自身的版本范围进行修改来实现。然后重新安装依赖并测试，确保项目能够正常运行。</li>
<li>分别安装依赖包：如果无法升级包 C 的版本或者升级包 A、B 的版本也不可行，可以尝试分别安装依赖包。也就是说，分别为包 A 和包 B 创建独立的依赖环境，让它们各自安装自己所需要的依赖包版本。然后在使用它们的地方通过注入或者模块引入来分别使用对应的依赖包。</li>
<li>重构代码：如果无法统一版本，也无法分别安装依赖包，可能就需要进行代码重构了。通过重构代码，考虑使用兼容不同版本的 API 或者替代性的包来解决依赖不一致的问题。</li>
</ol>
<h4 id="关于浏览器渲染原理，重排"><a href="#关于浏览器渲染原理，重排" class="headerlink" title="关于浏览器渲染原理，重排"></a>关于浏览器渲染原理，重排</h4><p>重排（reflow）是浏览器在绘制页面时的一个重要概念。当页面发生布局变化时（如改变元素宽高、位置、字体大小等），浏览器需要重新计算元素的布局信息，并重新绘制页面。这个过程就是重排。</p>
<p>重排的代价很高，会导致页面的性能下降，因此我们应尽量减少重排的次数。<br><em>常见引起重排的操作有：</em></p>
<ol>
<li>修改 DOM 结构：如增删节点、修改节点顺序等；</li>
<li>改变元素位置和尺寸：如改变元素的位置、大小、边距、内填充等；</li>
<li>修改样式：如改变元素的背景颜色、字体大小、文字颜色等；</li>
<li>查询 DOM 元素的位置、尺寸等信息：如调用 offsetWidth、offsetHeight、scrollTop、scrollLeft 等属性。</li>
</ol>
<p><em>为了尽量减少重排，我们可以采取以下措施：</em></p>
<ol>
<li>将多次重排操作合并为一次：比如通过改变元素的 class 来一次性修改多个样式；</li>
<li>避免读取布局信息：尽量避免频繁读取 DOM 元素的位置和尺寸信息；</li>
<li>使用文档片段进行离线处理：将需要生成大量 DOM 元素的操作暂时放入文档片段中，完成后再一次性插入到页面中；</li>
<li>使用绝对定位的元素：需要频繁改变位置的元素最好采用绝对定位，避免引起其他元素的重排。</li>
</ol>
<h4 id="组件库怎么做，怎么实现"><a href="#组件库怎么做，怎么实现" class="headerlink" title="组件库怎么做，怎么实现"></a>组件库怎么做，怎么实现</h4><h4 id="如何看待框架，相比原生解决了什么问题"><a href="#如何看待框架，相比原生解决了什么问题" class="headerlink" title="如何看待框架，相比原生解决了什么问题"></a>如何看待框架，相比原生解决了什么问题</h4><h4 id="VDOM是什么，相比原生对比为什么要使用VDOM"><a href="#VDOM是什么，相比原生对比为什么要使用VDOM" class="headerlink" title="VDOM是什么，相比原生对比为什么要使用VDOM"></a>VDOM是什么，相比原生对比为什么要使用VDOM</h4><p>虚拟DOM，相比起直接操作真实的 DOM，使用 VDOM 的方式有以下几个优点：</p>
<ol>
<li>性能优化：直接操作 DOM 可能会导致频繁的重排和重绘，而 VDOM 通过在内存中构建一颗虚拟的 DOM 树，并将其与真实 DOM 进行比较，只更新有变化的部分，从而减少了不必要的 DOM 操作，提高了性能。</li>
<li>跨平台兼容性：VDOM 是对 DOM 结构的抽象，不依赖于具体的平台或浏览器实现，因此可以在不同平台上保持一致性，并提供良好的跨浏览器兼容性。</li>
<li>简化开发流程：使用 VDOM 可以更方便地进行组件化开发，并提供了一种数据驱动的方式来更新视图，代码更加清晰、易于理解和维护。</li>
<li>方便的状态管理：VDOM 结合了框架本身的状态管理机制，可以实现方便的状态管理和组件间的通信，提供了更好的代码组织和复用能力。</li>
</ol>
<p>但也有一些缺点，比如会引入一定的性能损耗，以及需要额外的代码来处理 VDOM 的生成和比较等。</p>
<h4 id="AST是什么"><a href="#AST是什么" class="headerlink" title="AST是什么"></a>AST是什么</h4><p>AST（Abstract Syntax Tree）是一种数据结构，用于表示程序代码的抽象语法结构。AST 可以帮助开发者理解和分析代码，以及进行静态分析、代码转换和优化等操作。</p>
<h4 id="BST是什么"><a href="#BST是什么" class="headerlink" title="BST是什么"></a>BST是什么</h4><p>BST（Binary Search Tree）是一种常见的数据结构，用于存储和组织数据。BST 是一种二叉树，其中每个节点最多有两个子节点。BST 通常用于实现搜索、插入和删除操作的高效数据结构。</p>
<h4 id="使用BST实现-包括insert，search，delete"><a href="#使用BST实现-包括insert，search，delete" class="headerlink" title="使用BST实现 包括insert，search，delete"></a>使用BST实现 包括insert，search，delete</h4><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><h4 id="常用-Git-命令"><a href="#常用-Git-命令" class="headerlink" title="常用 Git 命令"></a>常用 Git 命令</h4><ol>
<li><strong>基本操作</strong><ul>
<li><code>git init</code>：初始化一个新的 Git 本地仓库。</li>
<li><code>git clone &lt;repo_url&gt;</code>：克隆一个远程仓库。</li>
<li><code>git status</code>：查看当前工作区和暂存区的状态。</li>
<li><code>git add &lt;file&gt;</code>：将文件添加到暂存区。</li>
<li><code>git commit -m &quot;commit message&quot;</code>：提交暂存区的更改。</li>
<li><code>git push</code>：将本地更改推送到远程仓库。</li>
<li><code>git pull</code>：从远程仓库拉取最新的更改并合并到本地。</li>
</ul>
</li>
<li><strong>查看历史</strong><ul>
<li><code>git log</code>：查看提交历史。</li>
<li><code>git diff</code>：查看未暂存的更改。</li>
<li><code>git show &lt;commit_hash&gt;</code>：查看某次提交的详细信息。</li>
</ul>
</li>
<li><strong>分支操作</strong><ul>
<li><code>git branch</code>：列出所有分支。</li>
<li><code>git branch &lt;branch_name&gt;</code>：创建新分支。</li>
<li><code>git checkout &lt;branch_name&gt;</code>：切换到指定分支。</li>
<li><code>git merge &lt;branch_name&gt;</code> &#x2F; git rebase：合并指定分支到当前分支。</li>
</ul>
</li>
<li><strong>提交撤销操作</strong><ul>
<li>未暂存的撤销可以使用checkout</li>
<li>已暂存的撤销可以使用reset</li>
<li>回滚代码，可以使用reset配合参数( 硬重置，软重置)</li>
<li>撤销提交可以使用revert</li>
</ul>
</li>
</ol>
<h4 id="如何撤销更改？"><a href="#如何撤销更改？" class="headerlink" title="如何撤销更改？"></a>如何撤销更改？</h4><ul>
<li><p>撤销未暂存的更改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销已暂存的更改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>回滚到某个提交并丢弃后续更改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit_hash&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="如何回滚代码"><a href="#如何回滚代码" class="headerlink" title="如何回滚代码"></a>如何回滚代码</h4><ol>
<li><p><strong>使用 <code>git reset</code> 回滚至某个提交</strong></p>
<ul>
<li><p>回到某个提交并保留未提交的更改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit_hash&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>回到某个提交并丢弃未提交的更改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit_hash&gt;  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用 <code>git revert</code> 创建一个新提交</strong></p>
<ul>
<li><p>如果希望撤销某次提交，并且保持项目历史完整，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit_hash&gt;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>这会生成一个新的提交，反转指定的提交。</p>
</li>
</ul>
</li>
<li><p>软重置（Soft Reset）：这会撤销最新的提交，并将更改保留在暂存区中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure>
</li>
<li><p>硬重置（Hard Reset）：这会撤销最新的提交，并将更改完全删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="如何合并分支"><a href="#如何合并分支" class="headerlink" title="如何合并分支"></a>如何合并分支</h4><ol>
<li><p><strong>确保当前在目标分支</strong></p>
<ul>
<li><p>切换到想要合并到的分支，例如 main或master</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>合并指定分支</strong></p>
<ul>
<li><p>合并其他分支（例如 feature-branch）到当前分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge feature-branch  </span><br></pre></td></tr></table></figure>
</li>
<li><p>如果合并时没有冲突，Git 会自动完成合并。</p>
</li>
<li><p>如果出现冲突，将会提示你手动解决冲突。</p>
</li>
</ul>
</li>
</ol>
<h4 id="什么是“rebase”，它与“merge”有什么不同？"><a href="#什么是“rebase”，它与“merge”有什么不同？" class="headerlink" title="什么是“rebase”，它与“merge”有什么不同？"></a>什么是“rebase”，它与“merge”有什么不同？</h4><ul>
<li>**<code>merge</code>**：保留所有分支的历史，创建一个新的合并提交。</li>
<li>**<code>rebase</code>**：将一个分支的更改“移动”到另一个分支的基础上，形成一条线性历史，不会留下合并提交。<code>rebase</code> 通常会使历史记录更加简洁。</li>
</ul>
<h4 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h4><ol>
<li><p>编译冲突的文件。</p>
</li>
<li><p>手动编辑冲突的行。</p>
</li>
<li><p>保存文件后，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;resolved_file&gt;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>完成合并：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Merge branch &#x27;feature-branch&#x27;&quot;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="将工作区保存临时区域"><a href="#将工作区保存临时区域" class="headerlink" title="将工作区保存临时区域"></a>将工作区保存临时区域</h4><p>要回到某个提交并保留未提交的更改，然后再回到原来的工作区，您可以按照以下步骤进行操作：</p>
<ol>
<li><p>使用 <code>git stash</code> 命令将当前未提交的更改保存到一个临时区域（stash）中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash  </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>git log</code> 命令查找您要回到的提交的哈希值（commit hash）。</p>
</li>
<li><p>使用 <code>git checkout</code> 命令切换到您要回到的提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;commit-hash&gt;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>在回到的提交中进行必要的操作。</p>
</li>
<li><p>如果您完成了在回到的提交中的操作，并且想要回到原来的工作区，可以使用 <code>git stash apply</code> 命令将之前保存的更改应用到当前工作区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply  </span><br></pre></td></tr></table></figure>

<p>如果您有多个 stash，可以使用 <code>git stash list</code> 命令查看 stash 列表，并使用 <code>git stash apply stash@&#123;&lt;stash-index&gt;&#125;</code> 应用特定的 stash。</p>
</li>
</ol>
<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><h4 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h4><p><strong>五个类别：</strong></p>
<p>1xx - 信息性状态码：表示请求已被接收，继续处理。</p>
<p>2xx - 成功状态码：表示请求已成功被服务器接收、理解和处理。</p>
<p>3xx - 重定向状态码：表示需要进一步操作以完成请求。</p>
<p>4xx - 客户端错误状态码：表示服务器无法处理请求，客户端可能需要修改请求。</p>
<p>5xx - 服务器错误状态码：表示服务器在处理请求时发生了错误。</p>
<ul>
<li><strong>200 OK</strong>：请求成功，服务器成功返回请求的数据。</li>
<li><strong>201 Created</strong>：请求成功，服务器成功创建了新的资源。</li>
<li><strong>204 No Content</strong>：请求成功，服务器成功处理了请求，但没有返回任何内容。</li>
<li><strong>301 Moved Permanently</strong>：请求的资源已永久移动到新的 URL。</li>
<li><strong>400 Bad Request</strong>：请求无效，服务器无法理解请求的语法。</li>
<li><strong>401 Unauthorized</strong>：请求要求身份验证，客户端未提供有效的身份验证凭据。</li>
<li><strong>500 Internal Server Error</strong>：服务器在执行请求时发生了未知的内部错误。</li>
<li><strong>501 Not Implemented</strong>：服务器不支持实现请求所需要的功能，或者无法完成请求。</li>
<li><strong>502 Bad Gateway</strong>：作为网关或代理工作的服务器尝试执行请求时，从上游服务器接收到无效响应。</li>
<li><strong>503 Service Unavailable</strong>：服务器暂时无法处理请求（可能是由于过载或维护）。</li>
<li><strong>504 Gateway Timeout</strong>：作为网关或代理工作的服务器尝试执行请求时，但并未及时从上游服务器接收到响应。</li>
<li><strong>505 HTTP Version Not Supported</strong>：服务端不支持客户端指定的 HTTP 版本。</li>
</ul>
<h4 id="介绍-HTTP-的基本原理和工作过程。"><a href="#介绍-HTTP-的基本原理和工作过程。" class="headerlink" title="介绍 HTTP 的基本原理和工作过程。"></a>介绍 HTTP 的基本原理和工作过程。</h4><p>HTTP TCP下的用于传输超文本的协议，是 Web 数据传输的基础。通过请求-响应的交互方式实现数据传输。</p>
<p>工作过程：</p>
<ol>
<li><p>客户端发起请求：HTTP 是基于客户端-服务器模式工作的，客户端（一般是浏览器）向服务器发起 HTTP 请求。请求由请求行、请求头和请求体组成，请求行包括请求方法（如 GET、POST）、请求的 URL（统一资源定位符）、协议版本等。</p>
</li>
<li><p>服务器处理请求：服务器接收到客户端的请求后，根据请求的 URL 定位资源，并执行相应的处理逻辑，如读取文件、执行程序等。服务器处理完请求后会生成一个 HTTP 响应发送给客户端。</p>
</li>
<li><p>服务器返回响应：HTTP 响应由响应行、响应头和响应体组成。响应行包括协议版本、状态码（用于表示请求的处理结果）和状态消息。响应头包括各种元数据，如日期、内容类型等。响应体则包含实际的响应内容。</p>
</li>
<li><p>客户端接收响应：客户端接收到服务器返回的 HTTP 响应后，根据响应的内容进行处理，展示给用户或者执行相关操作。如果需要加载额外资源（如图片、样式表、脚本等），客户端会再次向服务器发起新的请求。</p>
</li>
<li><p>TCP 连接：HTTP 是基于 TCP&#x2F;IP 协议的，通信双方需要建立 TCP 连接才能进行数据传输。连接建立后，客户端和服务器之间可以通过该连接进行数据传输，传输完成后可以关闭连接。</p>
</li>
<li><p>状态保持：HTTP 协议本身是无状态的，即服务器不会保留关于客户端的状态。为了实现状态保持，通常使用一些技术手段，比如 Cookie、Session 或者 Token 来实现用户状态的管理和保持。</p>
</li>
</ol>
<h4 id="http长连接和短连接"><a href="#http长连接和短连接" class="headerlink" title="http长连接和短连接"></a>http长连接和短连接</h4><h4 id="HTTP-请求方法有哪些？它们各自的作用是什么？"><a href="#HTTP-请求方法有哪些？它们各自的作用是什么？" class="headerlink" title="HTTP 请求方法有哪些？它们各自的作用是什么？"></a>HTTP 请求方法有哪些？它们各自的作用是什么？</h4><h4 id="什么是状态码？举例说明几个常见的状态码及其含义。"><a href="#什么是状态码？举例说明几个常见的状态码及其含义。" class="headerlink" title="什么是状态码？举例说明几个常见的状态码及其含义。"></a>什么是状态码？举例说明几个常见的状态码及其含义。</h4><h4 id="介绍HTTP-1-HTTP-2-和-HTTP-3-的特性和区别。"><a href="#介绍HTTP-1-HTTP-2-和-HTTP-3-的特性和区别。" class="headerlink" title="介绍HTTP&#x2F;1 , HTTP&#x2F;2 和 HTTP&#x2F;3 的特性和区别。"></a>介绍HTTP&#x2F;1 , HTTP&#x2F;2 和 HTTP&#x2F;3 的特性和区别。</h4><h4 id="RESTful-架构风格包括哪些设计原则？"><a href="#RESTful-架构风格包括哪些设计原则？" class="headerlink" title="RESTful 架构风格包括哪些设计原则？"></a>RESTful 架构风格包括哪些设计原则？</h4><h4 id="http和https区别"><a href="#http和https区别" class="headerlink" title="http和https区别"></a>http和https区别</h4><ol>
<li>安全性:<ul>
<li>HTTP 是超文本传输协议 (Hypertext Transfer Protocol) 的缩写，它使用明文传输数据。这意味着通过 HTTP 传输的数据在网络上可以被轻松地截取和窥视，存在较高的安全风险。</li>
<li>HTTPS 是安全超文本传输协议 (Hypertext Transfer Protocol Secure) 的缩写，它使用了 SSL&#x2F;TLS 协议对数据进行加密。HTTPS 能够确保客户端和服务器之间发送的数据经过加密，并且提供身份验证机制，因此通信更加安全可靠。</li>
</ul>
</li>
<li>加密:<ul>
<li>HTTP 不对发送或接收的数据进行加密处理，因此可能会被恶意攻击者截取并窥视其中包含的敏感信息。</li>
<li>HTTPS 使用 SSL&#x2F;TLS 协议对通信过程中所发送、接收或存储到服务器上面所有信息（如个人信息、银行账号等）进行加密。</li>
</ul>
</li>
<li>默认端口:<ul>
<li>HTTP 默认端口为 80。</li>
<li>HTTPS 默认端口为 443。</li>
</ul>
</li>
</ol>
<h4 id="HTTPS-相对于-HTTP-的优点和工作原理。"><a href="#HTTPS-相对于-HTTP-的优点和工作原理。" class="headerlink" title="HTTPS 相对于 HTTP 的优点和工作原理。"></a>HTTPS 相对于 HTTP 的优点和工作原理。</h4><h4 id="https加密过程-SSL-TLS"><a href="#https加密过程-SSL-TLS" class="headerlink" title="https加密过程(SSL&#x2F; TLS)"></a>https加密过程(SSL&#x2F; TLS)</h4><h4 id="https证书如何防止篡改，防调包"><a href="#https证书如何防止篡改，防调包" class="headerlink" title="https证书如何防止篡改，防调包"></a>https证书如何防止篡改，防调包</h4><h4 id="SSL-TLS-握手过程包括哪些步骤？"><a href="#SSL-TLS-握手过程包括哪些步骤？" class="headerlink" title="SSL&#x2F;TLS 握手过程包括哪些步骤？"></a>SSL&#x2F;TLS 握手过程包括哪些步骤？</h4><h4 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h4><ol>
<li>数据传输方式：<ul>
<li>GET：通过 URL 参数传递数据，数据附在 URL 后面，以 <code>?</code> 开始，参数之间以 <code>&amp;</code> 分隔。例如：<code>http://example.com/path?name=value&amp;age=30</code></li>
<li>POST：通过请求体传递数据，在 HTTP 请求的消息体中发送，并不会显示在 URL 中。</li>
</ul>
</li>
<li>安全性：<ul>
<li>GET：因为参数附在 URL 上，所以可能会被保存在浏览器历史记录、代理服务器日志等地方，不适合发送敏感信息。</li>
<li>POST：由于数据不会暴露在 URL 上，在一定程度上比 GET 更安全，并且可以使用 HTTPS 进行加密传输。</li>
</ul>
</li>
<li>数据长度限制：<ul>
<li>GET 请求对URL长度有限制（约 2KB），而 POST 没有明确的长度限制（取决于服务器和客户端设置）。</li>
</ul>
</li>
<li>幂等性：<ul>
<li>GET 请求通常是幂等的。即多次相同的请求会产生相同结果并且没有副作用。</li>
<li>POST 请求通常是非幂等的。即多次相同的请求可能每次产生不同结果或者有副作用（如创建一个新资源）。</li>
</ul>
</li>
<li>缓存处理：<ul>
<li>对于相同URL和参数GET会被缓存到浏览器缓存或者CDN,POST则将忽略来自服务器指令</li>
</ul>
</li>
</ol>
<h4 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h4><p>指浏览器在访问网页时将一些静态资源存储在本地的过程。这样做可以减少对服务器的请求次数，加快页面加载速度，并节省带宽消耗。<br>浏览器缓存通常分为两种类型：<strong>强缓存</strong>和<strong>协商缓存</strong>。</p>
<ul>
<li><strong>强制缓存</strong>：通过设置响应头控制客户端是否直接使用缓存而不发送请求到服务器。常见的控制头有 <code>Cache-Control</code> 和 <code>Expires</code>。<ul>
<li><code>Cache-Control</code>：指令包括 <code>max-age</code>（缓存有效时间）、<code>no-cache</code>（需要进行协商缓存验证）等。</li>
<li><code>Expires</code>：设置资源过期时间，是一个绝对时间。</li>
</ul>
</li>
<li><strong>协商缓存</strong>：当强制缓存失效时，客户端会发送请求到服务器验证资源是否更新。主要通过 <code>If-Modified-Since</code> 和 <code>If-None-Match</code> 这两个请求头来实现。<ul>
<li><code>If-Modified-Since</code>：表示资源的最后修改时间，服务器会比较该时间与资源的修改时间来判断资源是否需要更新。</li>
<li><code>If-None-Match</code>：表示资源的唯一标识符（通常是 ETag），服务器会比较该标识符与当前资源的标识符来判断资源是否</li>
</ul>
</li>
</ul>
<h4 id="浏览器本地缓存方式？cookie，localStorage，sessionstorage，会把数据存在哪，受不受同源策略制约"><a href="#浏览器本地缓存方式？cookie，localStorage，sessionstorage，会把数据存在哪，受不受同源策略制约" class="headerlink" title="浏览器本地缓存方式？cookie，localStorage，sessionstorage，会把数据存在哪，受不受同源策略制约"></a>浏览器本地缓存方式？cookie，localStorage，sessionstorage，会把数据存在哪，受不受同源策略制约</h4><ul>
<li><strong>Cookie</strong>：Cookie 数据存储在客户端的浏览器中，以文本文件的形式保存在用户的计算机上。每个域名可以设置和访问自己的 Cookie 数据。Cookie 受同源策略的限制，只能被设置和访问与其所属网站相同的域名、协议和端口。</li>
<li><strong>localStorage</strong>：localStorage 是以键值对的形式将数据存储在客户端的浏览器中。数据会永久保存在浏览器的本地存储空间中，除非被显式清除或网站使用代码进行删除。每个域名有独立的 localStorage 存储空间，受同源策略的限制。</li>
<li><strong>sessionStorage</strong>：sessionStorage 也是以键值对的形式将数据存储在客户端的浏览器中。与 localStorage 不同的是，sessionStorage 中的数据在会话结束后会被清除，即当用户关闭浏览器标签页或窗口时会话结束。每个域名有独立的 sessionStorage 存储空间，受同源策略的限制。</li>
</ul>
<h4 id="跨域请求如何产生？如何解决跨域问题？"><a href="#跨域请求如何产生？如何解决跨域问题？" class="headerlink" title="跨域请求如何产生？如何解决跨域问题？"></a>跨域请求如何产生？如何解决跨域问题？</h4><h4 id="cookie-，session，token"><a href="#cookie-，session，token" class="headerlink" title="cookie ，session，token"></a>cookie ，session，token</h4><ul>
<li><strong>Cookie</strong>：Cookie 是一种在客户端存储数据的技术，通过在客户端和服务器之间传递信息来维护状态。它通常是由服务器发送到客户端的小型文本文件，存储在客户端的浏览器中。Cookie 可以包含各种信息，如用户身份标识、会话状态等，用于跟踪用户的活动和维护用户状态。Cookie 在每次 HTTP 请求中都会被自动发送到服务器，受同源策略的限制。</li>
<li><strong>Session</strong>：Session 是一种在服务器端存储用户会话数据的机制。当用户访问网站时，服务器会为每个用户创建一个唯一的会话标识符（Session ID），并将该标识符存储在服务器上。Session 数据可以存储在服务器的内存、数据库或文件系统中。与 Cookie 不同，Session 数据不存储在客户端，而是由服务器进行管理。客户端通常通过 Cookie 中的 Session ID 来与服务器建立关联，以便在后续的请求中识别用户会话。Session 数据不受同源策略的限制。</li>
<li><strong>Token</strong>：Token 是一种用于验证用户身份和授权访问的令牌。它通常是由服务器生成的一串字符，作为客户端和服务器之间进行身份验证和授权的凭据。Token 可以是短暂的，只在一次请求中使用，也可以是长期有效的，用于多个请求。与 Cookie 和 Session 不同，Token 不依赖于服务器端的存储，而是通过在客户端和服务器之间传递进行验证。Token 可以存储在客户端的本地存储（如 localStorage）中，也可以作为请求头的一部分发送到服务器。Token 可以用于实现无状态的身份验证和授权机制，不受同源策略的限制。</li>
</ul>
<h4 id="cookie-常用属性"><a href="#cookie-常用属性" class="headerlink" title="cookie 常用属性"></a>cookie 常用属性</h4><ul>
<li><strong>Name</strong>：Cookie 的名称，用于标识特定的 Cookie。</li>
<li><strong>Value</strong>：Cookie 的值，存储在客户端的浏览器中，并在每次 HTTP 请求中被发送到服务器。</li>
<li><strong>Domain</strong>：指定 Cookie 可以发送到哪些域名。默认情况下，Cookie 只能发送到设置它的页面所在的域名。可以通过设置 Domain 属性来扩展 Cookie 的作用域。</li>
<li><strong>Path</strong>：指定 Cookie 可以发送到哪些路径。默认情况下，Cookie 只能发送到设置它的页面所在的路径。可以通过设置 Path 属性来限制 Cookie 的作用范围。</li>
<li><strong>Expires&#x2F;Max-Age</strong>：指定 Cookie 的过期时间。可以通过设置 Expires 属性为一个具体的日期时间或 Max-Age 属性为一个相对时间（秒数）来控制 Cookie 的有效期。</li>
</ul>
<h4 id="Websocket-相对于传统-HTTP-请求有哪些优势？"><a href="#Websocket-相对于传统-HTTP-请求有哪些优势？" class="headerlink" title="Websocket 相对于传统 HTTP 请求有哪些优势？"></a>Websocket 相对于传统 HTTP 请求有哪些优势？</h4><h4 id="Websocket-建立连接的握手过程。"><a href="#Websocket-建立连接的握手过程。" class="headerlink" title="Websocket 建立连接的握手过程。"></a>Websocket 建立连接的握手过程。</h4><h4 id="DNS-解析流程是怎样的？"><a href="#DNS-解析流程是怎样的？" class="headerlink" title="DNS 解析流程是怎样的？"></a>DNS 解析流程是怎样的？</h4><h4 id="DNS-负载均衡、故障恢复等相关概念。"><a href="#DNS-负载均衡、故障恢复等相关概念。" class="headerlink" title="DNS 负载均衡、故障恢复等相关概念。"></a>DNS 负载均衡、故障恢复等相关概念。</h4><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><h4 id="TCP-和-UDP-的区别及应用场景。"><a href="#TCP-和-UDP-的区别及应用场景。" class="headerlink" title="TCP 和 UDP 的区别及应用场景。"></a>TCP 和 UDP 的区别及应用场景。</h4><h4 id="TCP-三次握手四次挥手"><a href="#TCP-三次握手四次挥手" class="headerlink" title="TCP 三次握手四次挥手"></a>TCP 三次握手四次挥手</h4><h4 id="TCP-连接建立和断开过程，以及流量控制、拥塞控制机制。"><a href="#TCP-连接建立和断开过程，以及流量控制、拥塞控制机制。" class="headerlink" title="TCP 连接建立和断开过程，以及流量控制、拥塞控制机制。"></a>TCP 连接建立和断开过程，以及流量控制、拥塞控制机制。</h4><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>PHP 脚本以 <strong><?php** 开始，以 **?></strong> 结束</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>PHP 变量规则：</p>
<ul>
<li>变量以 $ 符号开始，后面跟着变量的名称</li>
<li>变量名必须以字母或者下划线字符开始</li>
<li>变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）</li>
<li>变量名不能包含空格</li>
<li>变量名是区分大小写的（$y 和 $Y 是两个不同的变量）</li>
</ul>
<h4 id="print和echo区别"><a href="#print和echo区别" class="headerlink" title="print和echo区别"></a>print和echo区别</h4><p>echo 和 print 区别:</p>
<ul>
<li>echo - 可以输出一个或多个字符串</li>
<li>print - 只允许输出一个字符串，返回值总为 1</li>
</ul>
<h4 id="php数据结构"><a href="#php数据结构" class="headerlink" title="php数据结构"></a>php数据结构</h4><p>PHP 支持以下几种数据类型:</p>
<ul>
<li>String（字符串）</li>
<li>Integer（整型）</li>
<li>Float（浮点型）</li>
<li>Boolean（布尔型）</li>
<li>Array（数组）</li>
<li>Object（对象）</li>
<li>NULL（空值）</li>
<li>Resource（资源类型）</li>
</ul>
<h4 id="数据类型比较"><a href="#数据类型比较" class="headerlink" title="数据类型比较"></a>数据类型比较</h4><ul>
<li>松散比较：使用两个等号 <strong>&#x3D;&#x3D;</strong> 比较，只比较值，不比较类型。</li>
<li>严格比较：用三个等号 <strong>&#x3D;&#x3D;&#x3D;</strong> 比较，除了比较值，也比较类型。</li>
</ul>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量可以用 <strong>define()</strong> 函数或 <strong>const</strong> 关键字来定义</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">&quot;GREETING&quot;</span>, <span class="string">&quot;欢迎访问 Runoob.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="php并置运算符"><a href="#php并置运算符" class="headerlink" title="php并置运算符"></a>php并置运算符</h4><ul>
<li>并置运算符 (.) 用于把两个字符串值连接起来。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$txt1</span>=<span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="variable">$txt2</span>=<span class="string">&quot;What a nice day!&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$txt1</span> . <span class="string">&quot; &quot;</span> . <span class="variable">$txt2</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>strlen() 函数</p>
<p>返回字符串长度</p>
</li>
<li><p>strpos() 函数</p>
<p>用于在字符串内查找一个字符或一段指定的文本。</p>
</li>
</ul>
<h4 id="PHP-算术运算符"><a href="#PHP-算术运算符" class="headerlink" title="PHP 算术运算符"></a>PHP 算术运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">名称</th>
<th align="left">描述</th>
<th align="left">实例</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">x + y</td>
<td align="left">加</td>
<td align="left">x 和 y 的和</td>
<td align="left">2 + 2</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">x - y</td>
<td align="left">减</td>
<td align="left">x 和 y 的差</td>
<td align="left">5 - 2</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">x * y</td>
<td align="left">乘</td>
<td align="left">x 和 y 的积</td>
<td align="left">5 * 2</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">x &#x2F; y</td>
<td align="left">除</td>
<td align="left">x 和 y 的商</td>
<td align="left">15 &#x2F; 5</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">x % y</td>
<td align="left">模（除法的余数）</td>
<td align="left">x 除以 y 的余数</td>
<td align="left">5 % 2 10 % 8 10 % 2</td>
<td align="left">1 2 0</td>
</tr>
<tr>
<td align="left">-x</td>
<td align="left">设置负数</td>
<td align="left">取 x 的相反符号</td>
<td align="left"><code>&lt;?php $x = 2; echo -$x; ?&gt;</code></td>
<td align="left">-2</td>
</tr>
<tr>
<td align="left">~x</td>
<td align="left">取反</td>
<td align="left">x 取反，按二进制位进行”取反”运算。运算规则：<code>~1=-2;    ~0=-1;</code></td>
<td align="left"><code>&lt;?php $x = 2; echo ~$x; ?&gt;</code></td>
<td align="left">-3</td>
</tr>
<tr>
<td align="left">a . b</td>
<td align="left">并置</td>
<td align="left">连接两个字符串</td>
<td align="left">“Hi” . “Ha”</td>
<td align="left">HiHa</td>
</tr>
</tbody></table>
<h4 id="php条件语句"><a href="#php条件语句" class="headerlink" title="php条件语句"></a>php条件语句</h4><p>在 PHP 中，提供了下列条件语句：</p>
<ul>
<li><strong>if 语句</strong> - 在条件成立时执行代码</li>
<li><strong>if…else 语句</strong> - 在条件成立时执行一块代码，条件不成立时执行另一块代码</li>
<li><strong>if…elseif….else 语句</strong> - 在若干条件之一成立时执行一个代码块</li>
<li><strong>switch 语句</strong> - 在若干条件之一成立时执行一个代码块</li>
</ul>
<h4 id="PHP-switch-条件语句"><a href="#PHP-switch-条件语句" class="headerlink" title="PHP switch 条件语句"></a>PHP switch 条件语句</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        <span class="comment">// 代码块1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        <span class="comment">// 代码块2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 更多的 case 语句</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 如果没有匹配的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="PHP-数组"><a href="#PHP-数组" class="headerlink" title="PHP 数组"></a>PHP 数组</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cars</span>=<span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Toyota&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;I like &quot;</span> . <span class="variable">$cars</span>[<span class="number">0</span>] . <span class="string">&quot;, &quot;</span> . <span class="variable">$cars</span>[<span class="number">1</span>] . <span class="string">&quot; and &quot;</span> . <span class="variable">$cars</span>[<span class="number">2</span>] . <span class="string">&quot;.&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="PHP-数组排序函数"><a href="#PHP-数组排序函数" class="headerlink" title="PHP 数组排序函数"></a>PHP 数组排序函数</h4><ul>
<li>sort() - 对数组进行升序排列</li>
<li>rsort() - 对数组进行降序排列</li>
<li>asort() - 根据关联数组的值，对数组进行升序排列</li>
<li>ksort() - 根据关联数组的键，对数组进行升序排列</li>
<li>arsort() - 根据关联数组的值，对数组进行降序排列</li>
<li>krsort() - 根据关联数组的键，对数组进行降序排列</li>
</ul>
<h4 id="PHP-循环-While-循环"><a href="#PHP-循环-While-循环" class="headerlink" title="PHP 循环 - While 循环"></a>PHP 循环 - While 循环</h4><p>供了下列循环语句：</p>
<ul>
<li><p><strong>while</strong> - 只要指定的条件成立，则循环执行代码块</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$i</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$i</span>&lt;=<span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;The number is &quot;</span> . <span class="variable">$i</span> . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="variable">$i</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>do…while</strong> - 首先执行一次代码块，然后在指定的条件成立时重复这个循环</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$i</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$i</span>++;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;The number is &quot;</span> . <span class="variable">$i</span> . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$i</span>&lt;=<span class="number">5</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>for</strong> - 循环执行代码块指定的次数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">1</span>; <span class="variable">$i</span>&lt;=<span class="number">5</span>; <span class="variable">$i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;数字为 &quot;</span> . <span class="variable">$i</span> . PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>foreach</strong> - 根据数组中每个元素来循环代码块</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$x</span>=<span class="keyword">array</span>(<span class="string">&quot;Google&quot;</span>,<span class="string">&quot;Runoob&quot;</span>,<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$x</span> <span class="keyword">as</span> <span class="variable">$value</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$value</span> . PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="PHP-函数"><a href="#PHP-函数" class="headerlink" title="PHP 函数"></a>PHP 函数</h4><ul>
<li><p>创建 PHP 函数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Kai Jim Refsnes&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My name is &quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">writeName</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加参数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeName</span>(<span class="params"><span class="variable">$fname</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$fname</span> . <span class="string">&quot; Refsnes.&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My name is &quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">writeName</span>(<span class="string">&quot;Kai Jim&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My sister&#x27;s name is &quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">writeName</span>(<span class="string">&quot;Hege&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My brother&#x27;s name is &quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">writeName</span>(<span class="string">&quot;Stale&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"><span class="variable">$x</span>,<span class="variable">$y</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$total</span>=<span class="variable">$x</span>+<span class="variable">$y</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$total</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;1 + 16 = &quot;</span> . <span class="title function_ invoke__">add</span>(<span class="number">1</span>,<span class="number">16</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>变量函数 - 将函数赋值给变量，使变量作为函数名来调用的函数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;In foo()&lt;br /&gt;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"><span class="variable">$arg</span> = <span class="string">&#x27;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;In bar(); argument was &#x27;<span class="subst">$arg</span>&#x27;.&lt;br /&gt;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 echo 的包装函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echoit</span>(<span class="params"><span class="variable">$string</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$func</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable">$func</span>();        <span class="comment">// 调用 foo()</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$func</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="variable">$func</span>(<span class="string">&#x27;test&#x27;</span>);  <span class="comment">// 调用 bar()</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$func</span> = <span class="string">&#x27;echoit&#x27;</span>;</span><br><span class="line"><span class="variable">$func</span>(<span class="string">&#x27;test&#x27;</span>);  <span class="comment">// 调用 echoit()</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">// 也可以使用New关键字</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Variable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$name</span> = <span class="string">&#x27;Bar&#x27;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="variable">$name</span>(); <span class="comment">// 调用 Bar() 方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;This is Bar&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$foo</span> = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="variable">$funcname</span> = <span class="string">&quot;Variable&quot;</span>;</span><br><span class="line"><span class="variable">$foo</span>-&gt;<span class="variable">$funcname</span>();  <span class="comment">// 调用 $foo-&gt;Variable()</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="魔术常量"><a href="#魔术常量" class="headerlink" title="魔术常量"></a>魔术常量</h4><ul>
<li><p>__LINE__ - 文件中的当前行号。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;这是第 &quot; &#x27;</span>  . <span class="keyword">__LINE__</span> . <span class="string">&#x27; &quot; 行&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__FILE__ - 文件的完整路径和文件名。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;该文件位于 &quot; &#x27;</span>  . <span class="keyword">__FILE__</span> . <span class="string">&#x27; &quot; &#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__DIR__ - 文件所在的目录。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;该文件位于 &quot; &#x27;</span>  . <span class="keyword">__DIR__</span> . <span class="string">&#x27; &quot; &#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__FUNCTION__ - 函数名称（PHP 4.3.0 新加）自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写)</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span>  <span class="string">&#x27;函数名为：&#x27;</span> . <span class="keyword">__FUNCTION__</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__CLASS__ - 类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;类名为：&#x27;</span>  . <span class="keyword">__CLASS__</span> . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span>  <span class="string">&#x27;函数名为：&#x27;</span> . <span class="keyword">__FUNCTION__</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$t</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="variable">$t</span>-&gt;<span class="title function_ invoke__">_print</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__TRAIT__  - Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Hello &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">SayWorld</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">parent</span>::<span class="title function_ invoke__">sayHello</span>();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;World!&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHelloWorld</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">SayWorld</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$o</span> = <span class="keyword">new</span> <span class="title class_">MyHelloWorld</span>();</span><br><span class="line"><span class="variable">$o</span>-&gt;<span class="title function_ invoke__">sayHello</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__METHOD__ - 类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span>  <span class="string">&#x27;函数名为：&#x27;</span> . <span class="keyword">__METHOD__</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__NAMESPACE__ - 当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">MyProject</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;命名空间为：&quot;&#x27;</span>, <span class="keyword">__NAMESPACE__</span>, <span class="string">&#x27;&quot;&#x27;</span>; <span class="comment">// 输出 &quot;MyProject&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="PHP命名空间"><a href="#PHP命名空间" class="headerlink" title="PHP命名空间"></a>PHP命名空间</h4><ul>
<li>定义命名空间</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">MyProject</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">CONNECT_OK</span> = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span>  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">AnotherProject</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">CONNECT_OK</span> = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span>  &#125;</span><br><span class="line"><span class="meta">?&gt;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 成员变量 */</span></span><br><span class="line">  <span class="keyword">var</span> <span class="variable">$url</span>;</span><br><span class="line">  <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 成员函数 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setUrl</span>(<span class="params"><span class="variable">$par</span></span>)</span>&#123;</span><br><span class="line">     <span class="variable language_">$this</span>-&gt;url = <span class="variable">$par</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;url . PHP_EOL;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span>(<span class="params"><span class="variable">$par</span></span>)</span>&#123;</span><br><span class="line">     <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;title . PHP_EOL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">// 变量 $this 代表自身的对象。</span></span><br><span class="line"><span class="comment">// PHP_EOL 为换行符。</span></span><br></pre></td></tr></table></figure>

<h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$runoob</span> = <span class="keyword">new</span> <span class="title class_">Site</span>;</span><br><span class="line"><span class="variable">$taobao</span> = <span class="keyword">new</span> <span class="title class_">Site</span>;</span><br><span class="line"><span class="variable">$google</span> = <span class="keyword">new</span> <span class="title class_">Site</span>;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"> <span class="variable">$par1</span>, <span class="variable">$par2</span> </span>) </span>&#123;</span><br><span class="line">   <span class="variable language_">$this</span>-&gt;url = <span class="variable">$par1</span>;</span><br><span class="line">   <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="析构函数-void-destruct-void"><a href="#析构函数-void-destruct-void" class="headerlink" title="析构函数 - void __destruct ( void )"></a>析构函数 - void __destruct ( void )</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDestructableClass</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">print</span> <span class="string">&quot;构造函数\n&quot;</span>;</span><br><span class="line">       <span class="variable language_">$this</span>-&gt;name = <span class="string">&quot;MyDestructableClass&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">print</span> <span class="string">&quot;销毁 &quot;</span> . <span class="variable language_">$this</span>-&gt;name . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title class_">MyDestructableClass</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 代码部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;url . PHP_EOL;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;url;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;title . PHP_EOL;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;title;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/07/03/firstBlog/" title="firstBlog"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">firstBlog</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/fafafa.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">fafafa</div><div class="author-info__description">记录笔记日志</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/fafafabaobei@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%ADuni-app%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">有关小程序中uni-app框架常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#uniapp%E8%BF%9B%E8%A1%8C%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">uniapp进行条件编译的两种方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniapp-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6API"><span class="toc-number">1.2.</span> <span class="toc-text">uniapp 上传文件API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8"><span class="toc-number">1.3.</span> <span class="toc-text">监听页面滚动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E5%9B%BE%E7%89%87%E5%AE%BD%E5%BA%A6%E4%B8%8D%E5%8F%98%EF%BC%8C%E9%AB%98%E5%BA%A6%E8%87%AA%E5%8A%A8%E5%8F%98%E5%8C%96%EF%BC%8C%E4%BF%9D%E6%8C%81%E5%8E%9F%E5%9B%BE%E5%AE%BD%E9%AB%98%E4%B8%8D%E5%8F%98"><span class="toc-number">1.4.</span> <span class="toc-text">如何让图片宽度不变，高度自动变化，保持原图宽高不变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jquery%EF%BC%8Cvue%EF%BC%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%8Cuniapp%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">1.5.</span> <span class="toc-text">jquery，vue，小程序，uniapp本地数据存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">uniApp中如何进行页面跳转？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">uniApp中如何进行数据缓存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%92%8C%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">uniApp中如何实现下拉刷新和上拉加载更多？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">uniApp中如何获取用户地理位置信息？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">uniApp中如何获取设备信息？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95%E7%9A%84%E6%8F%90%E4%BA%A4%E5%92%8C%E9%AA%8C%E8%AF%81%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">uniApp中如何实现表单的提交和验证？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%99%BB%E5%BD%95%E6%8E%88%E6%9D%83%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">uniApp中如何实现页面的登录授权？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%88%86%E4%BA%AB%E5%88%B0%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">uniApp中如何实现页面的分享到朋友圈功能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">uniApp中如何实现图片预览功能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="toc-number">1.15.</span> <span class="toc-text">uniApp中如何实现页面间的数据传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8uniApp%E4%B8%AD%EF%BC%8C%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8C%85%E6%8B%AC%E5%BA%94%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%82"><span class="toc-number">1.16.</span> <span class="toc-text">在uniApp中，页面的生命周期包括应用生命周期和页面生命周期。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95-uni-getUserProfile-uni-login"><span class="toc-number">1.17.</span> <span class="toc-text">实现微信登录 - uni.getUserProfile() &#x2F; uni.login()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#button-open-type-%E5%B1%9E%E6%80%A7"><span class="toc-number">1.18.</span> <span class="toc-text">button open-type 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E5%92%8Ch5%E6%94%AF%E4%BB%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.19.</span> <span class="toc-text">小程序支付和h5支付有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniapp-request-%E5%B0%81%E8%A3%85"><span class="toc-number">1.20.</span> <span class="toc-text">uniapp request 封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniapp-%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3"><span class="toc-number">1.21.</span> <span class="toc-text">uniapp 跨域解决</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue"><span class="toc-number">2.</span> <span class="toc-text">vue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vue2%E5%92%8Cvue3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">vue2和vue3的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object-defineproperty%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text">object.defineproperty如何监听数组，为什么无法获取数组变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue-%E4%B8%AD%E4%BD%BF%E7%94%A8-data-%E5%8C%85%E8%A3%B9%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.3.</span> <span class="toc-text">Vue 中使用 data 包裹属性的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue2-%E7%BB%84%E4%BB%B6%E4%B8%ADdata%E6%98%AF%E5%87%BD%E6%95%B0%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">2.4.</span> <span class="toc-text">vue2 组件中data是函数不是对象为什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%BB%84%E4%BB%B6%E9%97%B4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.5.</span> <span class="toc-text">vue生命周期和组件间生命周期顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1"><span class="toc-number">2.6.</span> <span class="toc-text">vue如何定义路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E5%92%8Chistory-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.</span> <span class="toc-text">hash和history 路由模式区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-show%E5%92%8Cv-if%E5%8C%BA%E5%88%AB"><span class="toc-number">2.8.</span> <span class="toc-text">v-show和v-if区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.9.</span> <span class="toc-text">v-if和v-for的优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-for%E7%9A%84key%E4%BD%9C%E7%94%A8%EF%BC%8Cv-for%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E4%B8%AD%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8index%E4%BD%9C%E4%B8%BAkey"><span class="toc-number">2.10.</span> <span class="toc-text">v-for的key作用，v-for遍历数组中能否使用index作为key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.11.</span> <span class="toc-text">vue组件通信方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vuex-pinia"><span class="toc-number">2.12.</span> <span class="toc-text">vuex&#x2F; pinia</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pinia"><span class="toc-number">2.13.</span> <span class="toc-text">pinia</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">2.14.</span> <span class="toc-text">双向数据绑定原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-model-vue2%E4%B8%8Evue3%E5%88%86%E5%88%AB%E4%BD%9C%E7%94%A8%E5%9C%A8%E6%99%AE%E9%80%9A%E5%85%83%E7%B4%A0%E5%92%8C%E7%BB%84%E4%BB%B6%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.15.</span> <span class="toc-text">v-model - vue2与vue3分别作用在普通元素和组件元素的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextTick%E4%BD%9C%E7%94%A8"><span class="toc-number">2.16.</span> <span class="toc-text">nextTick作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E8%99%9A%E6%8B%9FDom"><span class="toc-number">2.17.</span> <span class="toc-text">vue虚拟Dom</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E8%99%9A%E6%8B%9FDom%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90"><span class="toc-number">2.18.</span> <span class="toc-text">vue虚拟Dom怎么生成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React"><span class="toc-number">3.</span> <span class="toc-text">React</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#react%E7%90%86%E8%A7%A3-%E5%92%8C-%E7%89%B9%E5%BE%81"><span class="toc-number">3.1.</span> <span class="toc-text">react理解 和 特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVC%E6%A1%86%E6%9E%B6%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.2.</span> <span class="toc-text">MVC框架主要问题是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flux%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.3.</span> <span class="toc-text">Flux是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFjsx"><span class="toc-number">3.4.</span> <span class="toc-text">什么是jsx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM"><span class="toc-number">3.5.</span> <span class="toc-text">虚拟DOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.</span> <span class="toc-text">React 工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9"><span class="toc-number">3.7.</span> <span class="toc-text">React有什么优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react%E4%B8%AD%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.8.</span> <span class="toc-text">react中类组件和函数组件的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.9.</span> <span class="toc-text">组件生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B7%9F%E8%B8%AA%E5%8A%9F%E8%83%BD%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="toc-number">3.10.</span> <span class="toc-text">如何跟踪功能组件的卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">3.11.</span> <span class="toc-text">react响应式原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#render%E5%87%BD%E6%95%B0%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%EF%BC%8C%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-number">3.12.</span> <span class="toc-text">render函数的渲染过程，解析流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useMemo%E5%92%8CuseCallback-%E5%8C%BA%E5%88%AB"><span class="toc-number">3.13.</span> <span class="toc-text">hooks - useMemo和useCallback 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useState%E5%92%8CuseRef-%E5%8C%BA%E5%88%AB"><span class="toc-number">3.14.</span> <span class="toc-text">hooks - useState和useRef 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useEffect%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9F%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%8F%AA%E4%BC%A0%E4%B8%80%E4%B8%AA%E5%92%8C%E7%A9%BA%E6%95%B0%E7%BB%84%EF%BC%8C%E4%B8%8D%E4%BC%A0%E4%BE%9D%E8%B5%96%E9%A1%B9%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.15.</span> <span class="toc-text">useEffect的两个参数？依赖项只传一个和空数组，不传依赖项的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useEffect%E7%9A%84return-%E5%87%BD%E6%95%B0%E5%9C%A8%E4%BE%9D%E8%B5%96%E9%A1%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="toc-number">3.16.</span> <span class="toc-text">useEffect的return 函数在依赖项不同的情况下，有何区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-Hooks%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0"><span class="toc-number">3.17.</span> <span class="toc-text">React Hooks底层原理，如何实现状态更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8-redux%E6%95%B0%E6%8D%AE%E4%B8%8D%E6%8C%81%E4%B9%85%E5%8C%96%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">3.18.</span> <span class="toc-text">怎么实现全局数据存储? redux数据不持久化怎么解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%A6%82%E4%BD%95%E8%AE%A9%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%8D%E6%B8%B2%E6%9F%93%EF%BC%8C%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8Chooks%E6%96%B9%E6%B3%95"><span class="toc-number">3.19.</span> <span class="toc-text">父组件渲染如何让子组件不渲染，类组件和hooks方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#state-%E7%8A%B6%E6%80%81-%E5%92%8Cprops-%E5%B1%9E%E6%80%A7-%E5%8C%BA%E5%88%AB"><span class="toc-number">3.20.</span> <span class="toc-text">state( 状态)和props( 属性)区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFprops%E9%80%8F%E4%BC%A0"><span class="toc-number">3.21.</span> <span class="toc-text">什么是props透传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReact-%E4%B8%8A%E4%B8%8B%E6%96%87-contest"><span class="toc-number">3.22.</span> <span class="toc-text">什么是React 上下文 - contest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">3.23.</span> <span class="toc-text">渲染数组元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8map-%E6%97%B6%E9%9C%80%E8%A6%81key"><span class="toc-number">3.24.</span> <span class="toc-text">为什么使用map() 时需要key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">3.25.</span> <span class="toc-text">受控组件和非受控组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%A7%BB%E9%99%A4%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">3.26.</span> <span class="toc-text">如何实现移除定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">3.27.</span> <span class="toc-text">react 组件通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useState%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">3.28.</span> <span class="toc-text">hooks - useState有什么特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useEffect%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">3.29.</span> <span class="toc-text">hooks - useEffect有什么特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useMemo%E7%94%A8%E9%80%94%EF%BC%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">3.30.</span> <span class="toc-text">hooks - useMemo用途？如何工作？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useCallback%E7%94%A8%E9%80%94%EF%BC%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">3.31.</span> <span class="toc-text">hooks - useCallback用途？如何工作？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useMemo%E5%92%8CuseCallback%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.32.</span> <span class="toc-text">hooks - useMemo和useCallback有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useContext%E7%94%A8%E9%80%94-%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.33.</span> <span class="toc-text">hooks - useContext用途? 如何工作?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useRef-%E7%94%A8%E9%80%94%EF%BC%9F%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.34.</span> <span class="toc-text">hooks - useRef 用途？作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReact-memo"><span class="toc-number">3.35.</span> <span class="toc-text">什么是React.memo()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReact-Fragment"><span class="toc-number">3.36.</span> <span class="toc-text">什么是React Fragment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B7%9F%E8%B8%AA%E5%BC%95%E7%94%A8%E5%8A%9F%E8%83%BD%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">3.37.</span> <span class="toc-text">如何跟踪引用功能组件中对象字段的变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AEDOM%E5%85%83%E7%B4%A0"><span class="toc-number">3.38.</span> <span class="toc-text">如何访问DOM元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%87%BA%E5%8F%91%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E8%80%83%E8%99%91%E4%BB%80%E4%B9%88"><span class="toc-number">3.39.</span> <span class="toc-text">react合成事件，为什么不使用浏览器原生事件，出发点是什么，考虑什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react18%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">3.40.</span> <span class="toc-text">react18新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-diff-%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.41.</span> <span class="toc-text">React diff 算法介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redux"><span class="toc-number">4.</span> <span class="toc-text">Redux</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedux"><span class="toc-number">4.1.</span> <span class="toc-text">什么是Redux</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redux%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">Redux有什么优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redux-%E9%81%B5%E5%BE%AA%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.3.</span> <span class="toc-text">Redux 遵循的三个原则是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9-%E2%80%9C%E5%8D%95%E4%B8%80%E4%BA%8B%E5%AE%9E%E6%9D%A5%E6%BA%90%E2%80%9D-%E6%9C%89%E4%BB%80%E4%B9%88%E7%90%86%E8%A7%A3"><span class="toc-number">4.4.</span> <span class="toc-text">对 “单一事实来源” 有什么理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA-Redux-%E7%BB%84%E4%BB%B6"><span class="toc-number">4.5.</span> <span class="toc-text">列出 Redux 组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-Redux-%E6%B5%81%E5%8A%A8"><span class="toc-number">4.6.</span> <span class="toc-text">数据如何通过 Redux 流动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Redux%E4%B8%AD%E5%AE%9A%E4%B9%89Action"><span class="toc-number">4.7.</span> <span class="toc-text">如何在Redux中定义Action</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8AReducer%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.8.</span> <span class="toc-text">解释Reducer的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Store%E5%9C%A8Redux%E4%B8%AD%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.9.</span> <span class="toc-text">Store在Redux中的意义是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redux%E4%B8%8EFlux%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-number">4.10.</span> <span class="toc-text">Redux与Flux有什么不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redux-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%8C%85%E6%8B%AC-Store%E3%80%81Action%E3%80%81Reducer-%E5%92%8C-Middleware%E3%80%82"><span class="toc-number">4.11.</span> <span class="toc-text">Redux 的核心概念包括 Store、Action、Reducer 和 Middleware。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack"><span class="toc-number">5.</span> <span class="toc-text">Webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Webpack%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">什么是 Webpack？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Webpack-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">Webpack 的核心概念有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack-%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">webpack 打包过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-Webpack-%E7%9A%84%E8%BE%93%E5%87%BA%E9%80%89%E9%A1%B9%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">如何配置 Webpack 的输出选项？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Loader%EF%BC%8C%E4%B8%BE%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">什么是 Loader，举几个常见的例子？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%92%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%9F"><span class="toc-number">5.6.</span> <span class="toc-text">什么是插件，如何使用它？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Webpack-%E4%B8%AD%E7%9A%84%E7%83%AD%E6%A8%A1%E5%9D%97%E6%9B%BF%E6%8D%A2%EF%BC%88Hot-Module-Replacement-HMR%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.7.</span> <span class="toc-text">Webpack 中的热模块替换（Hot Module Replacement, HMR）是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%EF%BC%9F"><span class="toc-number">5.8.</span> <span class="toc-text">如何实现代码分割？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-Webpack-%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E3%80%82"><span class="toc-number">5.9.</span> <span class="toc-text">解释一下 Webpack 的四个生命周期钩子。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%85%8D%E7%BD%AE-Webpack%EF%BC%9F"><span class="toc-number">5.10.</span> <span class="toc-text">如何在生产环境和开发环境中配置 Webpack？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96-Commonjs%EF%BC%8CAMD%EF%BC%8CCMD%EF%BC%8CUMD%EF%BC%8CES6-Module%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">5.11.</span> <span class="toc-text">模块化 Commonjs，AMD，CMD，UMD，ES6 Module分别有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack%E8%83%BD%E5%A4%84%E7%90%86%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%8D%E8%83%BD%E5%A4%84%E7%90%86%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6"><span class="toc-number">5.12.</span> <span class="toc-text">webpack能处理什么文件，不能处理什么文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack-%E5%A4%84%E7%90%86%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">5.13.</span> <span class="toc-text">webpack 处理性能优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPA%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">5.14.</span> <span class="toc-text">SPA首屏优化方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#html"><span class="toc-number">6.</span> <span class="toc-text">html</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3html%EF%BC%8Ccss%EF%BC%8Cjs"><span class="toc-number">6.1.</span> <span class="toc-text">如何理解html，css，js</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#html%E4%BB%A3%E7%A0%81%E7%AC%AC%E4%B8%80%E8%A1%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">html代码第一行有什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#html%E7%9A%84meta%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">html的meta属性有哪些，都是什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">隐藏一个元素有哪些方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8Ch5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">6.5.</span> <span class="toc-text">小程序和h5有什么区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css"><span class="toc-number">7.</span> <span class="toc-text">css</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.</span> <span class="toc-text">盒子模型介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css-%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">7.2.</span> <span class="toc-text">css 布局方式有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80"><span class="toc-number">7.3.</span> <span class="toc-text">讲一下弹性盒子布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E6%96%B9%E5%BC%8F"><span class="toc-number">7.4.</span> <span class="toc-text">css元素居中方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css%E5%9B%9E%E6%B5%81%EF%BC%8C%E9%87%8D%E7%BB%98%EF%BC%8C%E5%90%88%E5%B9%B6%E5%9B%BE%E5%B1%82%EF%BC%8CGPU-%E5%8A%A0%E9%80%9F"><span class="toc-number">7.5.</span> <span class="toc-text">css回流，重绘，合并图层，GPU 加速</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">7.6.</span> <span class="toc-text">关于适配问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFC%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">7.7.</span> <span class="toc-text">BFC实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9IFC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">7.8.</span> <span class="toc-text">对IFC的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2"><span class="toc-number">7.9.</span> <span class="toc-text">媒体查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%A8%E6%9E%B6%E5%B1%8F%E5%8E%9F%E7%90%86"><span class="toc-number">7.10.</span> <span class="toc-text">骨架屏原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E7%A9%BF%E9%80%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">7.11.</span> <span class="toc-text">鼠标穿透属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SCSS"><span class="toc-number">8.</span> <span class="toc-text">SCSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js"><span class="toc-number">9.</span> <span class="toc-text">js</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%82%A8%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="toc-number">9.1.</span> <span class="toc-text">说说js中的数据类型,基本数据类型和引用数据类型区别，以及存储上的差别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">9.2.</span> <span class="toc-text">隐式转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89%E5%92%8C-%EF%BC%88%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89"><span class="toc-number">9.3.</span> <span class="toc-text">&#x3D;&#x3D;（相等运算符）和 &#x3D;&#x3D;&#x3D;（严格相等运算符）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.</span> <span class="toc-text">数组方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%E5%92%8C%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">9.5.</span> <span class="toc-text">数组扁平化和数组去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forEach-%E5%92%8C-map-%E5%8C%BA%E5%88%AB"><span class="toc-number">9.6.</span> <span class="toc-text">forEach 和 map 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">9.7.</span> <span class="toc-text">字符串常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof%E5%92%8Cinstanceof-%E5%8C%BA%E5%88%AB"><span class="toc-number">9.8.</span> <span class="toc-text">typeof和instanceof 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#js%E5%8E%9F%E5%9E%8B%EF%BC%9F%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">9.9.</span> <span class="toc-text">js原型？原型链？有什么特点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">9.10.</span> <span class="toc-text">作用域和作用域链的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9this%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">9.11.</span> <span class="toc-text">谈谈对this的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call%E3%80%81apply-%E5%92%8C-bind-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.12.</span> <span class="toc-text">call、apply 和 bind 方法的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BF%AE%E6%94%B9this%E6%8C%87%E5%90%91%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.13.</span> <span class="toc-text">其他修改this指向的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ajax%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">9.14.</span> <span class="toc-text">ajax的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#axios%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">9.15.</span> <span class="toc-text">axios的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%9C%A8%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E5%86%85"><span class="toc-number">9.16.</span> <span class="toc-text">如何判断一个元素在可视区域内</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">9.17.</span> <span class="toc-text">函数柯里化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E2%80%A6in%E2%80%A6-%E5%92%8C-for%E2%80%A6of%E2%80%A6-%E5%8C%BA%E5%88%AB"><span class="toc-number">9.18.</span> <span class="toc-text">for…in… 和 for…of… 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#js%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.19.</span> <span class="toc-text">js事件模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">9.20.</span> <span class="toc-text">创建对象有哪些方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C"><span class="toc-number">9.21.</span> <span class="toc-text">new 操作符具体操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8prototype%E4%B8%AD"><span class="toc-number">9.22.</span> <span class="toc-text">什么数据存在对象中，什么数据存在prototype中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADa%E6%98%AF%E4%B8%8D%E6%98%AFb%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">9.23.</span> <span class="toc-text">如何判断a是不是b的实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB"><span class="toc-number">9.24.</span> <span class="toc-text">深拷贝和浅拷贝区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#json-stringify-%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%88%B0"><span class="toc-number">9.25.</span> <span class="toc-text">json.stringify() 是干什么的，什么时候会使用到</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%8C%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.26.</span> <span class="toc-text">防抖和节流，及应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E9%87%8F%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%BB%9A%E5%8A%A8"><span class="toc-number">9.27.</span> <span class="toc-text">大量加载数据怎么优化，怎么避免滚动条滚动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%97%E8%A1%A8%E8%99%9A%E6%8B%9F%E6%BB%9A%E5%8A%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.28.</span> <span class="toc-text">图片懒加载和列表虚拟滚动怎么实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">9.29.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%94%9Fjs%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.30.</span> <span class="toc-text">原生js创建自定义事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%8E%E4%B9%88%E5%81%9A%E9%A2%84%E8%A7%88"><span class="toc-number">9.31.</span> <span class="toc-text">文件上传怎么做预览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%A7%92%E4%BC%A0%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.32.</span> <span class="toc-text">文件秒传怎么实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E4%B8%8A%E4%BC%A0"><span class="toc-number">9.33.</span> <span class="toc-text">切片上传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA10g%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%88%86%E7%89%87%EF%BC%8C%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E5%90%88%E9%80%82%E7%9A%84%E5%88%86%E7%89%87%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%88%86%E7%89%87hash%E8%BF%87%E7%A8%8B%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-number">9.34.</span> <span class="toc-text">一个10g文件怎么进行分片，怎么确定合适的分片大小，分片hash过程怎么优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-number">9.35.</span> <span class="toc-text">断点续传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%8C%E4%B8%8B%E6%8B%89%E5%8A%A0%E8%BD%BD"><span class="toc-number">9.36.</span> <span class="toc-text">上拉刷新，下拉加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#web%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2"><span class="toc-number">9.37.</span> <span class="toc-text">web常见攻击方式，如何预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88"><span class="toc-number">9.38.</span> <span class="toc-text">js执行上下文和执行栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98"><span class="toc-number">9.39.</span> <span class="toc-text">函数缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">9.40.</span> <span class="toc-text">js数据结构的了解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DOM-BOM%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="toc-number">9.41.</span> <span class="toc-text">DOM&#x2F;BOM常见操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6"><span class="toc-number">9.42.</span> <span class="toc-text">事件循环机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">9.43.</span> <span class="toc-text">宏任务之间的优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%93%E5%AD%98"><span class="toc-number">9.44.</span> <span class="toc-text">服务端缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sql%E8%B0%83%E4%BC%98"><span class="toc-number">9.45.</span> <span class="toc-text">sql调优</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webworker%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E9%98%BB%E5%A1%9E%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8A%8Ajs%E5%86%85%E5%AE%B9%E6%94%BE%E5%88%B0webworker%E8%BF%90%E8%A1%8C"><span class="toc-number">9.46.</span> <span class="toc-text">webworker多线程可以避免阻塞，为什么不把js内容放到webworker运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSR%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">9.47.</span> <span class="toc-text">SSR服务端渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSR%E4%BC%9A%E5%AD%98%E5%9C%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%90%97"><span class="toc-number">9.48.</span> <span class="toc-text">SSR会存在跨域问题吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B"><span class="toc-number">9.49.</span> <span class="toc-text">JWT认证过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86"><span class="toc-number">9.50.</span> <span class="toc-text">数据加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8Bpromise"><span class="toc-number">9.51.</span> <span class="toc-text">讲解一下promise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#promise%E5%90%8E%E9%9D%A2%E5%A6%82%E6%9E%9C%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%80%BC%EF%BC%8C-then-%E6%80%8E%E4%B9%88%E4%BC%A0%E5%80%BC"><span class="toc-number">9.52.</span> <span class="toc-text">promise后面如果有多个值，.then() 怎么传值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async-await%E7%90%86%E8%A7%A3"><span class="toc-number">9.53.</span> <span class="toc-text">async await理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async-await%E6%AF%94promise%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF"><span class="toc-number">9.54.</span> <span class="toc-text">async await比promise有什么优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async-await%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">9.55.</span> <span class="toc-text">async await的底层原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#generator%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">9.56.</span> <span class="toc-text">generator的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pnpm%E8%BD%AF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%8C%BA%E5%88%AB"><span class="toc-number">9.57.</span> <span class="toc-text">pnpm软连接和硬链接区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pnpm-hoist%E6%9C%BA%E5%88%B6"><span class="toc-number">9.58.</span> <span class="toc-text">pnpm hoist机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pnpm%E5%8C%85%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%8C%E4%B8%89%E5%B1%82%E5%AF%BB%E5%9D%80"><span class="toc-number">9.59.</span> <span class="toc-text">pnpm包的结构，三层寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E4%BA%8B%E5%B9%BD%E7%81%B5%E4%BE%9D%E8%B5%96%EF%BC%8C%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">9.60.</span> <span class="toc-text">什么事幽灵依赖，会引发什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#package-A-%E5%92%8Cpackage-B-%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8C%85%EF%BC%8C%E5%8D%B4%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%9F%E4%B8%80%E7%89%88%E6%9C%AC"><span class="toc-number">9.61.</span> <span class="toc-text">package A 和package B 依赖同一个包，却不同版本，如何统一版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%EF%BC%8C%E9%87%8D%E6%8E%92"><span class="toc-number">9.62.</span> <span class="toc-text">关于浏览器渲染原理，重排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%BA%93%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.63.</span> <span class="toc-text">组件库怎么做，怎么实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%A1%86%E6%9E%B6%EF%BC%8C%E7%9B%B8%E6%AF%94%E5%8E%9F%E7%94%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">9.64.</span> <span class="toc-text">如何看待框架，相比原生解决了什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VDOM%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E7%9B%B8%E6%AF%94%E5%8E%9F%E7%94%9F%E5%AF%B9%E6%AF%94%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8VDOM"><span class="toc-number">9.65.</span> <span class="toc-text">VDOM是什么，相比原生对比为什么要使用VDOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AST%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.66.</span> <span class="toc-text">AST是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BST%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.67.</span> <span class="toc-text">BST是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8BST%E5%AE%9E%E7%8E%B0-%E5%8C%85%E6%8B%ACinsert%EF%BC%8Csearch%EF%BC%8Cdelete"><span class="toc-number">9.68.</span> <span class="toc-text">使用BST实现 包括insert，search，delete</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git"><span class="toc-number">10.</span> <span class="toc-text">git</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-Git-%E5%91%BD%E4%BB%A4"><span class="toc-number">10.1.</span> <span class="toc-text">常用 Git 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%92%A4%E9%94%80%E6%9B%B4%E6%94%B9%EF%BC%9F"><span class="toc-number">10.2.</span> <span class="toc-text">如何撤销更改？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9B%9E%E6%BB%9A%E4%BB%A3%E7%A0%81"><span class="toc-number">10.3.</span> <span class="toc-text">如何回滚代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF"><span class="toc-number">10.4.</span> <span class="toc-text">如何合并分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9Crebase%E2%80%9D%EF%BC%8C%E5%AE%83%E4%B8%8E%E2%80%9Cmerge%E2%80%9D%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">10.5.</span> <span class="toc-text">什么是“rebase”，它与“merge”有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81"><span class="toc-number">10.6.</span> <span class="toc-text">解决合并冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%BF%9D%E5%AD%98%E4%B8%B4%E6%97%B6%E5%8C%BA%E5%9F%9F"><span class="toc-number">10.7.</span> <span class="toc-text">将工作区保存临时区域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-number">11.</span> <span class="toc-text">网络协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">11.1.</span> <span class="toc-text">http 状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-HTTP-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-number">11.2.</span> <span class="toc-text">介绍 HTTP 的基本原理和工作过程。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">11.3.</span> <span class="toc-text">http长连接和短连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%83%E4%BB%AC%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.4.</span> <span class="toc-text">HTTP 请求方法有哪些？它们各自的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89%E3%80%82"><span class="toc-number">11.5.</span> <span class="toc-text">什么是状态码？举例说明几个常见的状态码及其含义。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8DHTTP-1-HTTP-2-%E5%92%8C-HTTP-3-%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">11.6.</span> <span class="toc-text">介绍HTTP&#x2F;1 , HTTP&#x2F;2 和 HTTP&#x2F;3 的特性和区别。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RESTful-%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">11.7.</span> <span class="toc-text">RESTful 架构风格包括哪些设计原则？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E5%92%8Chttps%E5%8C%BA%E5%88%AB"><span class="toc-number">11.8.</span> <span class="toc-text">http和https区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS-%E7%9B%B8%E5%AF%B9%E4%BA%8E-HTTP-%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%82"><span class="toc-number">11.9.</span> <span class="toc-text">HTTPS 相对于 HTTP 的优点和工作原理。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#https%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B-SSL-TLS"><span class="toc-number">11.10.</span> <span class="toc-text">https加密过程(SSL&#x2F; TLS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#https%E8%AF%81%E4%B9%A6%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%AF%A1%E6%94%B9%EF%BC%8C%E9%98%B2%E8%B0%83%E5%8C%85"><span class="toc-number">11.11.</span> <span class="toc-text">https证书如何防止篡改，防调包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSL-TLS-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-number">11.12.</span> <span class="toc-text">SSL&#x2F;TLS 握手过程包括哪些步骤？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get%E5%92%8Cpost%E5%8C%BA%E5%88%AB"><span class="toc-number">11.13.</span> <span class="toc-text">get和post区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-number">11.14.</span> <span class="toc-text">浏览器缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F%EF%BC%9Fcookie%EF%BC%8ClocalStorage%EF%BC%8Csessionstorage%EF%BC%8C%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E5%93%AA%EF%BC%8C%E5%8F%97%E4%B8%8D%E5%8F%97%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%88%B6%E7%BA%A6"><span class="toc-number">11.15.</span> <span class="toc-text">浏览器本地缓存方式？cookie，localStorage，sessionstorage，会把数据存在哪，受不受同源策略制约</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">11.16.</span> <span class="toc-text">跨域请求如何产生？如何解决跨域问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie-%EF%BC%8Csession%EF%BC%8Ctoken"><span class="toc-number">11.17.</span> <span class="toc-text">cookie ，session，token</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie-%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">11.18.</span> <span class="toc-text">cookie 常用属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Websocket-%E7%9B%B8%E5%AF%B9%E4%BA%8E%E4%BC%A0%E7%BB%9F-HTTP-%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="toc-number">11.19.</span> <span class="toc-text">Websocket 相对于传统 HTTP 请求有哪些优势？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Websocket-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-number">11.20.</span> <span class="toc-text">Websocket 建立连接的握手过程。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS-%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">11.21.</span> <span class="toc-text">DNS 解析流程是怎样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%E7%AD%89%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E3%80%82"><span class="toc-number">11.22.</span> <span class="toc-text">DNS 负载均衡、故障恢复等相关概念。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">11.23.</span> <span class="toc-text">OSI七层模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%82"><span class="toc-number">11.24.</span> <span class="toc-text">TCP 和 UDP 的区别及应用场景。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">11.25.</span> <span class="toc-text">TCP 三次握手四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E6%96%AD%E5%BC%80%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6%E3%80%82"><span class="toc-number">11.26.</span> <span class="toc-text">TCP 连接建立和断开过程，以及流量控制、拥塞控制机制。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP"><span class="toc-number">12.</span> <span class="toc-text">PHP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">12.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">12.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#print%E5%92%8Cecho%E5%8C%BA%E5%88%AB"><span class="toc-number">12.3.</span> <span class="toc-text">print和echo区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#php%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.4.</span> <span class="toc-text">php数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83"><span class="toc-number">12.5.</span> <span class="toc-text">数据类型比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">12.6.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#php%E5%B9%B6%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">12.7.</span> <span class="toc-text">php并置运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PHP-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">12.8.</span> <span class="toc-text">PHP 算术运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#php%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">12.9.</span> <span class="toc-text">php条件语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PHP-switch-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">12.10.</span> <span class="toc-text">PHP switch 条件语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PHP-%E6%95%B0%E7%BB%84"><span class="toc-number">12.11.</span> <span class="toc-text">PHP 数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PHP-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0"><span class="toc-number">12.12.</span> <span class="toc-text">PHP 数组排序函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PHP-%E5%BE%AA%E7%8E%AF-While-%E5%BE%AA%E7%8E%AF"><span class="toc-number">12.13.</span> <span class="toc-text">PHP 循环 - While 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PHP-%E5%87%BD%E6%95%B0"><span class="toc-number">12.14.</span> <span class="toc-text">PHP 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AD%94%E6%9C%AF%E5%B8%B8%E9%87%8F"><span class="toc-number">12.15.</span> <span class="toc-text">魔术常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PHP%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">12.16.</span> <span class="toc-text">PHP命名空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">12.17.</span> <span class="toc-text">定义类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="toc-number">12.18.</span> <span class="toc-text">创建实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">12.19.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-void-destruct-void"><span class="toc-number">12.20.</span> <span class="toc-text">析构函数 - void __destruct ( void )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">12.21.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">12.22.</span> <span class="toc-text">方法重写</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/15/react-rudex/" title="React-Redux"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React-Redux"/></a><div class="content"><a class="title" href="/2024/08/15/react-rudex/" title="React-Redux">React-Redux</a><time datetime="2024-08-15T04:23:35.000Z" title="发表于 2024-08-15 12:23:35">2024-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/15/react/" title="React"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React"/></a><div class="content"><a class="title" href="/2024/08/15/react/" title="React">React</a><time datetime="2024-08-15T04:23:23.000Z" title="发表于 2024-08-15 12:23:23">2024-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/11/react_hooks/" title="React Hocks"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React Hocks"/></a><div class="content"><a class="title" href="/2024/08/11/react_hooks/" title="React Hocks">React Hocks</a><time datetime="2024-08-11T12:36:05.000Z" title="发表于 2024-08-11 20:36:05">2024-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/08/js+vue/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/08/08/js+vue/" title="无题">无题</a><time datetime="2024-08-08T01:53:25.450Z" title="发表于 2024-08-08 09:53:25">2024-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/05/python%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" title="Python项目构建工具"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python项目构建工具"/></a><div class="content"><a class="title" href="/2024/08/05/python%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" title="Python项目构建工具">Python项目构建工具</a><time datetime="2024-08-05T04:23:41.000Z" title="发表于 2024-08-05 12:23:41">2024-08-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By fafafa</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.0.5/dist/lazyload.iife.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.innerHTML = `<pre class="mermaid-src" hidden>${ele.textContent}</pre>`
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.14.0-b3"></script></div></div></body></html>