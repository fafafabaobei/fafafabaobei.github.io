<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试 | fafafabaobei</title><meta name="author" content="fafafa"><meta name="copyright" content="fafafa"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="有关小程序中uni-app框架常见面试题uniapp 理解UniApp是基于Vue.js开发的跨平台应用框架，通过一套代码实现在多个小程序平台上运行，包括微信小程序、支付宝小程序、百度小程序、字节跳动小程序等。它结合了Vue.js的开发特性和生态系统，提供了一种高效、快速的开发方式 使用UniApp开发小程序有以下优势和特点 跨平台：一套代码可以在多个小程序平台上运行，大大减少了开发和维护的成本。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试">
<meta property="og:url" content="https://fafafabaobei.github.io/2021/07/01/%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="fafafabaobei">
<meta property="og:description" content="有关小程序中uni-app框架常见面试题uniapp 理解UniApp是基于Vue.js开发的跨平台应用框架，通过一套代码实现在多个小程序平台上运行，包括微信小程序、支付宝小程序、百度小程序、字节跳动小程序等。它结合了Vue.js的开发特性和生态系统，提供了一种高效、快速的开发方式 使用UniApp开发小程序有以下优势和特点 跨平台：一套代码可以在多个小程序平台上运行，大大减少了开发和维护的成本。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bkimg.cdn.bcebos.com/pic/79f0f736afc379310a5545200188a04543a98226bb2f?x-bce-process=image/format,f_auto/watermark,image_d2F0ZXIvYmFpa2UyNzI,g_7,xp_5,yp_5,P_20/resize,m_lfit,limit_1,h_1080">
<meta property="article:published_time" content="2021-07-01T11:47:04.000Z">
<meta property="article:modified_time" content="2021-07-01T11:47:04.000Z">
<meta property="article:author" content="fafafa">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bkimg.cdn.bcebos.com/pic/79f0f736afc379310a5545200188a04543a98226bb2f?x-bce-process=image/format,f_auto/watermark,image_d2F0ZXIvYmFpa2UyNzI,g_7,xp_5,yp_5,P_20/resize,m_lfit,limit_1,h_1080"><link rel="shortcut icon" href="/img/blog.png"><link rel="canonical" href="https://fafafabaobei.github.io/2021/07/01/%E9%9D%A2%E8%AF%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-01 19:47:04'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    btf.addGlobalFn('pjaxSend', () => { preloader.initLoading() }, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', () => { preloader.endLoading() }, 'preloader_end')
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/fafafa.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://bkimg.cdn.bcebos.com/pic/79f0f736afc379310a5545200188a04543a98226bb2f?x-bce-process=image/format,f_auto/watermark,image_d2F0ZXIvYmFpa2UyNzI,g_7,xp_5,yp_5,P_20/resize,m_lfit,limit_1,h_1080')"><nav id="nav"><span id="blog-info"><a href="/" title="fafafabaobei"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/blog.png" alt="Logo"/><span class="site-name">fafafabaobei</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">面试<a class="post-edit-link" href="null_posts/面试.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-01T11:47:04.000Z" title="发表于 2021-07-01 19:47:04">2021-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-01T11:47:04.000Z" title="更新于 2021-07-01 19:47:04">2021-07-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">72.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>243分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="有关小程序中uni-app框架常见面试题"><a href="#有关小程序中uni-app框架常见面试题" class="headerlink" title="有关小程序中uni-app框架常见面试题"></a>有关小程序中uni-app框架常见面试题</h3><h4 id="uniapp-理解"><a href="#uniapp-理解" class="headerlink" title="uniapp 理解"></a>uniapp 理解</h4><p>UniApp是基于Vue.js开发的跨平台应用框架，通过一套代码实现在多个小程序平台上运行，包括微信小程序、支付宝小程序、百度小程序、字节跳动小程序等。它结合了Vue.js的开发特性和生态系统，提供了一种高效、快速的开发方式</p>
<h4 id="使用UniApp开发小程序有以下优势和特点"><a href="#使用UniApp开发小程序有以下优势和特点" class="headerlink" title="使用UniApp开发小程序有以下优势和特点"></a>使用UniApp开发小程序有以下优势和特点</h4><ul>
<li>跨平台：一套代码可以在多个小程序平台上运行，大大减少了开发和维护的成本。</li>
<li>开发效率高：基于Vue.js开发，使用Vue.js的开发特性和生态系统，提供了高效的开发体验。</li>
<li>丰富的组件和插件库：UniApp提供了丰富的组件和插件库，方便快速搭建页面和实现各种功能。</li>
<li>快速迭代和更新：UniApp支持快速发布新版本和更新，加速应用的迭代速度。</li>
</ul>
<h4 id="uniapp适用场景"><a href="#uniapp适用场景" class="headerlink" title="uniapp适用场景"></a>uniapp适用场景</h4><ul>
<li>需要在多个小程序平台上发布和运行的项目；</li>
<li>对开发效率和代码复用性有要求的项目；</li>
<li>轻量级和快速迭代的小程序应用；</li>
</ul>
<h4 id="挑战和解决方法："><a href="#挑战和解决方法：" class="headerlink" title="挑战和解决方法："></a>挑战和解决方法：</h4><ul>
<li>平台差异：不同小程序平台有一些差异性，解决方法是使用条件编译，根据不同平台使用相应的API和样式。</li>
<li>性能优化：因为UniApp是基于编译的方式实现跨平台，对性能的优化需要充分了解不同平台的特点和处理器能力，使用合适的优化技巧。</li>
<li>第三方组件兼容性：一些第三方组件在不同平台上的兼容性可能存在问题，可以做一些适配性工作，或者寻找替代组件。</li>
</ul>
<h4 id="解决小程序平台差异的方法包括："><a href="#解决小程序平台差异的方法包括：" class="headerlink" title="解决小程序平台差异的方法包括："></a>解决小程序平台差异的方法包括：</h4><ul>
<li>使用条件编译，根据不同平台使用相应的API和样式。</li>
<li>在编译时对不同平台的代码进行适配，如处理底部栏、导航栏等不同平台的差异性。</li>
<li>使用平台特定的组件和插件、样式。</li>
</ul>
<h4 id="uniapp进行条件编译的两种方法"><a href="#uniapp进行条件编译的两种方法" class="headerlink" title="uniapp进行条件编译的两种方法"></a>uniapp进行条件编译的两种方法</h4><ol>
<li><strong>#ifdef</strong>：<ul>
<li>在 UniApp 中，<code>#ifdef</code> 指令用于检查当前代码运行的平台是否满足条件。如果条件为真，则编译下面的代码块；如果条件为假，则忽略下面的代码块。</li>
<li>语法：<code>#ifdef condition code_to_compile_if_true</code></li>
</ul>
</li>
<li><strong>#ifndef</strong>：<ul>
<li><code>#ifndef</code> 指令与 <code>#ifdef</code> 相反，在 UniApp 中用于检查当前代码运行的平台是否不满足条件。如果条件为假，则编译下面的代码块；如果条件为真，则忽略下面的代码块。</li>
<li>语法：<code>#ifndef condition code_to_compile_if_false</code></li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ifdef APP-PLUS  </span><br><span class="line">    console.log(&#x27;This code is running on a native app platform.&#x27;);  </span><br><span class="line">#else  </span><br><span class="line">    console.log(&#x27;This code is not running on a native app platform.&#x27;);  </span><br><span class="line">#endif  </span><br><span class="line"></span><br><span class="line">#ifndef H5  </span><br><span class="line">    console.log(&#x27;This code is not running on a H5 web platform.&#x27;);  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>



<h4 id="uniapp-上传文件API"><a href="#uniapp-上传文件API" class="headerlink" title="uniapp 上传文件API"></a>uniapp 上传文件API</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uni.<span class="title function_">uploadFile</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;https://&#x27;</span>,</span><br><span class="line">    <span class="attr">fileType</span>:<span class="string">&#x27;image&#x27;</span>,</span><br><span class="line">    <span class="attr">filePath</span>:<span class="string">&#x27;路径&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="监听页面滚动"><a href="#监听页面滚动" class="headerlink" title="监听页面滚动"></a>监听页面滚动</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uni.<span class="title function_">onPageScroll</span>()</span><br></pre></td></tr></table></figure>



<h4 id="如何让图片宽度不变，高度自动变化，保持原图宽高不变"><a href="#如何让图片宽度不变，高度自动变化，保持原图宽高不变" class="headerlink" title="如何让图片宽度不变，高度自动变化，保持原图宽高不变"></a>如何让图片宽度不变，高度自动变化，保持原图宽高不变</h4><p>给image 标签添加 mode&#x3D;‘widthFix’</p>
<ul>
<li><code>aspectFit</code>：保持长宽比缩放图片，使图片的长边能完全显示出来</li>
<li><code>aspectFill</code>：保持长宽比缩放图片，使图片的短边能完全覆盖容器</li>
<li><code>widthFix</code>：宽度不变，高度自动变化，保持原图宽高比不变</li>
<li><code>heightFix</code>：高度不变，宽度自动变化，保持原图宽高比不变</li>
<li><code>scaleToFill</code>：拉伸图片，使图片填满容器</li>
<li><code>top</code>：顶部对齐，不改变原始尺寸</li>
<li><code>bottom</code>：底部对齐，不改变原始尺寸</li>
<li><code>left</code>：左对齐，不改变原始尺寸</li>
<li><code>right</code>：右对齐，不改变原始尺寸</li>
<li><code>center</code>：居中，不改变原始尺寸</li>
<li><code>top left</code>：上左对齐，不改变原始尺寸</li>
<li><code>top right</code>：上右对齐，不改变原始尺寸</li>
<li><code>bottom left</code>：下左对齐，不改变原始尺寸</li>
<li><code>bottom right</code>：下右对齐，不改变原始尺寸</li>
</ul>
<h4 id="jquery，vue，小程序，uniapp本地数据存储"><a href="#jquery，vue，小程序，uniapp本地数据存储" class="headerlink" title="jquery，vue，小程序，uniapp本地数据存储"></a>jquery，vue，小程序，uniapp本地数据存储</h4><p><strong>jquery</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存： $.cookie(&#x27;key&#x27;, &#x27;value&#x27;)</span><br><span class="line">取： $.cookie(&#x27;key&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>vue</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存：localStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;)</span><br><span class="line">取：localStorage.getItem(&#x27;key&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>wx小程序</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存：wx.setStorage / wx.setStorageSync</span><br><span class="line">取：wx.getStorage / wx.getStorageSync</span><br></pre></td></tr></table></figure>

<p><strong>uniapp</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存：uni.setStorage(&#123;key:&quot;属性名&quot;, data:&quot;值&quot;&#125;)</span><br><span class="line">取：uni.getStorage(&#123;key:&quot;属性名&quot;&#125;)</span><br></pre></td></tr></table></figure>





<h4 id="uniApp中如何进行页面跳转？"><a href="#uniApp中如何进行页面跳转？" class="headerlink" title="uniApp中如何进行页面跳转？"></a>uniApp中如何进行页面跳转？</h4><ul>
<li>使用 <code>uni.navigateTo</code> 进行普通页面跳转：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uni.navigateTo(&#123;  </span><br><span class="line">  url: &#x27;pages/newPage/newPage&#x27;  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>uni.redirectTo</code> 进行页面重定向（替换当前页面）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uni.redirectTo(&#123;  </span><br><span class="line">  url: &#x27;pages/newPage/newPage&#x27;  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>uni.switchTab</code> 进行 Tab 切换：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uni.switchTab(&#123;  </span><br><span class="line">  url: &#x27;pages/tabBar/tabBar&#x27;  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>uni.reLaunch</code> 关闭所有页面并打开到应用内的某个页面：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uni.reLaunch(&#123;  </span><br><span class="line">  url: &#x27;pages/index/index&#x27;  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>



<h4 id="uniApp中小程序如何进行数据缓存？"><a href="#uniApp中小程序如何进行数据缓存？" class="headerlink" title="uniApp中小程序如何进行数据缓存？"></a>uniApp中小程序如何进行数据缓存？</h4><blockquote>
<p>小程序没有cookie，只有storage缓存</p>
</blockquote>
<ul>
<li>使用 <code>uni.setStorageSync</code> 将数据存储到本地缓存中：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 存储数据  </span><br><span class="line">uni.setStorageSync(&#x27;key&#x27;, &#x27;value&#x27;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>uni.getStorageSync</code> 从本地缓存中获取数据：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取数据  </span><br><span class="line">let data = uni.getStorageSync(&#x27;key&#x27;);  </span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何实现下拉刷新和上拉加载更多？-使用uniapp-生命周期函数"><a href="#uniApp中如何实现下拉刷新和上拉加载更多？-使用uniapp-生命周期函数" class="headerlink" title="uniApp中如何实现下拉刷新和上拉加载更多？ - 使用uniapp 生命周期函数"></a>uniApp中如何实现下拉刷新和上拉加载更多？ - 使用uniapp 生命周期函数</h4><ul>
<li>实现下拉刷新功能：</li>
</ul>
<p>在需要实现下拉刷新的页面中，添加 <code>onPullDownRefresh</code> 方法，并在该方法中编写下拉刷新的逻辑代码。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;  </span><br><span class="line">  onPullDownRefresh() &#123;  </span><br><span class="line">    // 下拉刷新逻辑代码  </span><br><span class="line">    console.log(&#x27;下拉刷新&#x27;);  </span><br><span class="line">    // 停止下拉刷新动画  </span><br><span class="line">    uni.stopPullDownRefresh();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们在 <code>onPullDownRefresh</code> 方法中编写了下拉刷新的逻辑代码，并使用 <code>uni.stopPullDownRefresh()</code> 方法停止下拉刷新动画。</p>
<ul>
<li>实现上拉加载更多功能：</li>
</ul>
<p>在需要实现上拉加载更多的页面中，添加 <code>onReachBottom</code> 方法，并在该方法中编写上拉加载更多的逻辑代码。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;  </span><br><span class="line">  onReachBottom() &#123;  </span><br><span class="line">    // 上拉加载更多逻辑代码  </span><br><span class="line">    console.log(&#x27;上拉加载更多&#x27;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>需要注意的是，为了实现上拉加载更多功能，你需要在页面中添加一个 <code>scroll-view</code> 组件，并在该组件上绑定 <code>scrolltolower</code> 事件。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;scroll-view scroll-y=&quot;true&quot; style=&quot;height: 100%;&quot; @scrolltolower=&quot;onReachBottom&quot;&gt;  </span><br><span class="line">  &lt;!-- 页面内容 --&gt;  </span><br><span class="line">&lt;/scroll-view&gt;  </span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何获取用户地理位置信息？"><a href="#uniApp中如何获取用户地理位置信息？" class="headerlink" title="uniApp中如何获取用户地理位置信息？"></a>uniApp中如何获取用户地理位置信息？</h4><ul>
<li>使用uni.getLocation</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uni.getLocation(&#123;  </span><br><span class="line">  type: &#x27;gcj02&#x27;, // 返回坐标类型  </span><br><span class="line">  altitude: true, // 是否返回高度信息  </span><br><span class="line">  success: function (res) &#123;  </span><br><span class="line">    console.log(&#x27;当前位置的经度：&#x27; + res.longitude);  </span><br><span class="line">    console.log(&#x27;当前位置的纬度：&#x27; + res.latitude);  </span><br><span class="line">    console.log(&#x27;当前位置的海拔：&#x27; + res.altitude);  </span><br><span class="line">  &#125;,  </span><br><span class="line">  fail: function (error) &#123;  </span><br><span class="line">    console.log(&#x27;获取地理位置失败：&#x27; + error.message);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何获取设备信息？"><a href="#uniApp中如何获取设备信息？" class="headerlink" title="uniApp中如何获取设备信息？"></a>uniApp中如何获取设备信息？</h4><ul>
<li>使用uni.getSystemInfo</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uni.getSystemInfo(&#123;  </span><br><span class="line"> success: function (res) &#123;  </span><br><span class="line"> console.log(&#x27;设备型号：&#x27; + res.model);  </span><br><span class="line"> console.log(&#x27;设备像素比：&#x27; + res.pixelRatio);  </span><br><span class="line"> console.log(&#x27;屏幕宽度：&#x27; + res.windowWidth);  </span><br><span class="line"> console.log(&#x27;屏幕高度：&#x27; + res.windowHeight);  </span><br><span class="line"> // 其他设备信息...  </span><br><span class="line"> &#125;,  </span><br><span class="line"> fail: function (error) &#123;  </span><br><span class="line"> console.log(&#x27;获取设备信息失败：&#x27; + error.message);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何实现表单的提交和验证？"><a href="#uniApp中如何实现表单的提交和验证？" class="headerlink" title="uniApp中如何实现表单的提交和验证？"></a>uniApp中如何实现表单的提交和验证？</h4><ul>
<li>先将需要的正则匹配封装好，通过阻止<code>&lt;form&gt;</code>表的默认提交功能，先对数据进行正则匹配，成功后在进行提交</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;form @submit=&quot;submitForm&quot;&gt;  </span><br><span class="line">      &lt;input v-model=&quot;formData.username&quot; type=&quot;text&quot; placeholder=&quot;用户名&quot; /&gt;  </span><br><span class="line">      &lt;input v-model=&quot;formData.password&quot; type=&quot;password&quot; placeholder=&quot;密码&quot; /&gt;  </span><br><span class="line">      &lt;button formType=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt; </span><br><span class="line"></span><br><span class="line">&lt;script&gt;  </span><br><span class="line">export default &#123;  </span><br><span class="line">  data() &#123;  </span><br><span class="line">    return &#123;  </span><br><span class="line">      formData: &#123;  </span><br><span class="line">        username: &#x27;&#x27;,  </span><br><span class="line">        password: &#x27;&#x27;  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  methods &#123;  </span><br><span class="line">    submitForm(e) &#123;  </span><br><span class="line">      e.mp.preventDefault(); // 阻止默认行为  </span><br><span class="line">      // 进行表单验证逻辑，并处理提交操作  </span><br><span class="line">      // 可以在这里编写验证逻辑，例如检查用户名和密码是否符合规则等  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何实现页面的登录授权？"><a href="#uniApp中如何实现页面的登录授权？" class="headerlink" title="uniApp中如何实现页面的登录授权？"></a>uniApp中如何实现页面的登录授权？</h4><ul>
<li><strong>用户登录页面设计</strong>：首先需要设计一个用户登录页面，包括输入用户名、密码等登录信息的表单元素。</li>
<li><strong>登录逻辑处理</strong>：在uniApp中，你可以通过调用后端接口来进行用户登录验证。一般情况下，用户在登录页面输入用户名和密码后，通过点击登录按钮触发相应的登录方法。</li>
<li><strong>登录状态管理</strong>：一旦用户成功登录，通常会将用户的登录状态保存在本地，比如使用 <code>uni.setStorageSync</code> 方法将用户信息存储在本地缓存中。</li>
<li><strong>权限控制</strong>：在需要授权的页面或操作中，可以通过判断用户的登录状态来确定是否具有权限进行相关操作。如果用户未登录或登录状态过期，则可以跳转至登录页面进行重新登录。</li>
</ul>
<h4 id="uniApp中如何实现页面的分享到朋友圈功能？"><a href="#uniApp中如何实现页面的分享到朋友圈功能？" class="headerlink" title="uniApp中如何实现页面的分享到朋友圈功能？"></a>uniApp中如何实现页面的分享到朋友圈功能？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">shareToTimeline</span>(<span class="params"></span>) &#123;  </span><br><span class="line"> uni.<span class="title function_">share</span>(&#123;  </span><br><span class="line">  <span class="attr">provider</span>: <span class="string">&#x27;weixin&#x27;</span>,  </span><br><span class="line">  <span class="attr">scene</span>: <span class="string">&#x27;WXSenceTimeline&#x27;</span>, <span class="comment">// 表示分享到朋友圈  </span></span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;image&#x27;</span>,  </span><br><span class="line">  <span class="attr">imageUrl</span>: <span class="string">&#x27;/static/share-image.jpg&#x27;</span>, <span class="comment">// 分享的图片地址，需替换为真实图片地址  </span></span><br><span class="line">  <span class="title function_">success</span>(<span class="params">res</span>) &#123;  </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;分享成功&#x27;</span>);  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="title function_">fail</span>(<span class="params">err</span>) &#123;  </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;分享失败&#x27;</span>, err);  </span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;);  </span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何实现图片预览功能？"><a href="#uniApp中如何实现图片预览功能？" class="headerlink" title="uniApp中如何实现图片预览功能？"></a>uniApp中如何实现图片预览功能？</h4><ul>
<li>可以使用 <code>uni.previewImage</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;image src=&quot;/static/image.jpg&quot; @click=&quot;previewImage&quot; /&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;  </span><br><span class="line">export default &#123;  </span><br><span class="line">  methods: &#123;  </span><br><span class="line">    previewImage() &#123;  </span><br><span class="line">      uni.previewImage(&#123;  </span><br><span class="line">        urls: [&#x27;/static/image.jpg&#x27;], // 需要预览的图片链接列表，可以是本地路径或网络路径  </span><br><span class="line">        current: &#x27;/static/image.jpg&#x27;, // 当前显示的图片链接，可选  </span><br><span class="line">        success() &#123;  </span><br><span class="line">          console.log(&#x27;预览图片成功&#x27;);  </span><br><span class="line">        &#125;,  </span><br><span class="line">        fail(err) &#123;  </span><br><span class="line">          console.log(&#x27;预览图片失败&#x27;, err);  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="uniApp中如何实现页面间的数据传递"><a href="#uniApp中如何实现页面间的数据传递" class="headerlink" title="uniApp中如何实现页面间的数据传递"></a>uniApp中如何实现页面间的数据传递</h4><p>在uniApp中，你可以通过多种方式实现页面间的数据传递，以下是一些常用的方法：   </p>
<ul>
<li><strong>使用URL参数传递数据</strong>：在跳转页面时，可以通过URL参数将数据传递给目标页面。在源页面使用<code>uni.navigateTo</code>或<code>uni.redirectTo</code>等跳转方法时，可以在URL中携带参数，在目标页面通过<code>this.$route.query</code>或<code>this.$mp.query</code>来获取参数。   </li>
<li><strong>使用全局变量</strong>：可以在<code>App.vue</code>中定义全局变量，然后在各个页面中通过<code>this.$store.state.xxx</code>来访问和修改全局变量的数值。   </li>
<li><strong>使用Vuex状态管理</strong>：如果应用较为复杂，推荐使用Vuex进行状态管理。在需要传递数据的页面中，通过提交mutation或dispatch action的方式来改变状态，在目标页面通过计算属性或getter来获取状态。 </li>
<li>. <strong>使用本地缓存</strong>：可以使用<code>uni.setStorageSync</code>和<code>uni.getStorageSync</code>等方法将数据存储在本地缓存中，在不同页面中读取和修改这些数据</li>
<li><strong>事件总线（Event Bus）</strong>：创建一个Vue实例作为事件总线，通过该实例的emit和on方法来实现不同组件间的通信。</li>
</ul>
<h4 id="在uniApp中，页面的生命周期包括应用生命周期和页面生命周期。"><a href="#在uniApp中，页面的生命周期包括应用生命周期和页面生命周期。" class="headerlink" title="在uniApp中，页面的生命周期包括应用生命周期和页面生命周期。"></a>在uniApp中，页面的生命周期包括应用生命周期和页面生命周期。</h4><ul>
<li><p><strong>应用生命周期</strong>：  </p>
<ul>
<li>. <code>onLaunch</code>：应用初始化时触发，全局只触发一次。</li>
<li>. <code>onShow</code>：应用启动、从后台进入前台或重新进入应用时触发</li>
<li>. <code>onHide</code>：应用从前台进入后台时触发</li>
<li>. <code>onError</code>：应用发生脚本错误或 API 调用失败时触发</li>
<li>. <code>onUniNViewMessage</code>：监听来自原生 页面发送到 uni-page 的消息</li>
</ul>
</li>
<li><p><strong>页面生命周期</strong>：</p>
</li>
<li><p>. <code>onLoad</code>：页面加载时触发</p>
</li>
<li><p>. <code>onShow</code>：页面显示&#x2F;切入前台时触发</p>
</li>
<li><p>. <code>onReady</code>：页面初次渲染完成时触发</p>
</li>
<li><p><code>onHide</code>：页面隐藏&#x2F;切入后台时触发</p>
</li>
<li><p><code>onUnload</code>：页面卸载时触发</p>
</li>
<li><p><code>onPullDownRefresh</code>：下拉时触发</p>
</li>
<li><p>. <code>onReachBottom</code>：上拉触底触发</p>
</li>
<li><p>. <code>onShareAppMessage</code>：用户点击转发时触发</p>
</li>
<li><p>. <code>onPageScroll</code>：页面滚动时触发</p>
</li>
<li><p>. <code>onResize</code>：页面尺寸改变时触发</p>
</li>
</ul>
<h4 id="实现微信登录-uni-getUserProfile-uni-login"><a href="#实现微信登录-uni-getUserProfile-uni-login" class="headerlink" title="实现微信登录 - uni.getUserProfile() &#x2F; uni.login()"></a>实现微信登录 - uni.getUserProfile() &#x2F; uni.login()</h4><ul>
<li><strong>引入uni-app的登录插件</strong>：uni-app提供了一个名为<code>uni-login</code>的插件，可以方便地实现微信登录功能。你可以在uni-app的插件市场中搜索并安装该插件。</li>
<li><strong>配置插件参数</strong>：在插件安装完成后，你需要在<code>manifest.json</code>文件中配置插件的参数。将微信开放平台注册的AppID填入<code>uni-login</code>插件的配置中。</li>
<li><strong>调用登录方法</strong>：在需要进行微信登录的页面中，你可以调用<code>uni.login</code>方法来触发微信登录操作。该方法会返回一个包含登录凭证的对象。</li>
<li><strong>获取用户信息</strong>：登录成功后，你可以使用<code>uni.getUserInfo</code>方法来获取用户的基本信息，如昵称、头像等。该方法也会返回一个包含用户信息的对象。</li>
<li><strong>处理登录回调</strong>：在登录成功后，你可以将登录凭证发送到后端服务器进行验证，并根据验证结果进行相应的操作，如保存用户信息、跳转到主页等。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uni.<span class="title function_">login</span>(&#123;  </span><br><span class="line">        <span class="attr">provider</span>: <span class="string">&#x27;weixin&#x27;</span>,  </span><br><span class="line">        <span class="title function_">success</span>(<span class="params">res</span>) &#123;  </span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登录凭证：&#x27;</span>, res.<span class="property">code</span>);  </span><br><span class="line">          <span class="comment">// 将登录凭证发送到后端服务器进行验证  </span></span><br><span class="line">          <span class="comment">// 处理登录回调  </span></span><br><span class="line">        &#125;,  </span><br><span class="line">        <span class="title function_">fail</span>(<span class="params">err</span>) &#123;  </span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登录失败&#x27;</span>, err);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line"><span class="keyword">const</span> user = uni.<span class="title function_">getUserInfo</span>()</span><br></pre></td></tr></table></figure>



<h4 id="button-open-type-属性"><a href="#button-open-type-属性" class="headerlink" title="button open-type 属性"></a>button open-type 属性</h4><p>在uniApp中，<code>button</code>组件的<code>open-type</code>属性用于指定按钮的开放类型，决定了按钮的行为。常用的<code>open-type</code>属性值包括：  </p>
<ul>
<li><code>getUserInfo</code>：触发获取用户信息的行为，用户点击按钮后会弹出授权询问框，询问用户是否授权小程序获取用户信息。   </li>
<li><code>getPhoneNumber</code>：触发获取用户手机号的行为，用户点击按钮后会弹出授权询问框，询问用户是否授权小程序获取用户手机号。   </li>
<li><code>contact</code>：触发客服消息会话，打开客服会话界面。</li>
<li><code>share</code>：触发小程序分享功能，打开分享界面。</li>
<li><code>launchApp</code>：打开APP内部页面或小程序。</li>
</ul>
<h4 id="小程序支付和h5支付有什么区别"><a href="#小程序支付和h5支付有什么区别" class="headerlink" title="小程序支付和h5支付有什么区别"></a>小程序支付和h5支付有什么区别</h4><ul>
<li><strong>小程序支付</strong>：小程序支付是指在微信小程序中进行的支付操作。开发者可以通过调用微信提供的 <code>wx.requestPayment</code> 接口来实现在小程序内进行支付。对于小程序支付，通常需要使用微信提供的商户号和证书来进行交易。</li>
<li><strong>H5 支付</strong>：H5 支付是指在移动浏览器中进行的网页端支付操作。H5 支付通常使用传统的网页形式接入各个第三方平台（如微信、支付宝等）提供的接口，用户通过浏览器完成整个交易过程。</li>
</ul>
<h4 id="uniapp-request-封装"><a href="#uniapp-request-封装" class="headerlink" title="uniapp request 封装"></a>uniapp request 封装</h4><blockquote>
<p>在UniApp中可以使用封装好的网络请求库如<code>uni.request</code>来进行网络请求。通过调用相应的API方法，可以发送HTTP请求并处理返回的数据。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">	<span class="comment">// 在类初始化上加上baseUrl属性, 添加请求根路径</span></span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">baseUrl</span> = <span class="string">&#x27;http://159.75.169.224:7300/pz&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取用户信息</span></span><br><span class="line">	<span class="title function_">getUserInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">// 调用登录api</span></span><br><span class="line">		uni.<span class="title function_">login</span>(&#123;</span><br><span class="line">			<span class="attr">success</span>: <span class="function">(<span class="params">res</span>)=&gt;</span> &#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">				<span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">					<span class="attr">url</span>: <span class="string">&#x27;/auth/wxLogin&#x27;</span>,</span><br><span class="line">					<span class="attr">data</span>: &#123;</span><br><span class="line">						<span class="attr">code</span>: res.<span class="property">code</span></span><br><span class="line">					&#125;,</span><br><span class="line">					<span class="attr">success</span>: <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">						<span class="comment">// console.log(&#x27;login_success_res&#x27;,res)</span></span><br><span class="line">					&#125;,</span><br><span class="line">					<span class="attr">fail</span>: <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">						<span class="comment">// console.log(&#x27;login_fail_res&#x27;,res)</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 请求封装</span></span><br><span class="line">	<span class="title function_">request</span>(<span class="params">option=&#123;</span></span><br><span class="line"><span class="params">		showLoading: <span class="literal">false</span></span></span><br><span class="line"><span class="params">	&#125;</span>)&#123;</span><br><span class="line">		<span class="comment">// 判断是否有url</span></span><br><span class="line">		<span class="keyword">if</span>(!option.<span class="property">url</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(option.<span class="property">showLoading</span>)&#123;</span><br><span class="line">			<span class="title function_">showLoading</span>()</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		uni.<span class="title function_">request</span>(&#123;</span><br><span class="line">			<span class="attr">url</span>: <span class="variable language_">this</span>.<span class="property">baseUrl</span> + option.<span class="property">url</span>,</span><br><span class="line">			<span class="comment">// https://apifox.com/apidoc/shared-50a14ca5-c1d1-47ca-99f0-315ecfa52706</span></span><br><span class="line">			<span class="comment">// http://159.75.169.224:7300/pz</span></span><br><span class="line">			<span class="comment">// option.data参数由外部传入</span></span><br><span class="line">			<span class="attr">data</span>: option.<span class="property">data</span> ? option.<span class="property">data</span> : &#123;&#125;,</span><br><span class="line">			<span class="attr">header</span>: option.<span class="property">header</span> ? option.<span class="property">header</span> : &#123;&#125;,</span><br><span class="line">			<span class="attr">method</span>: option.<span class="property">method</span> ? option.<span class="property">method</span> : <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">			<span class="comment">// 请求接口成功处理</span></span><br><span class="line">			<span class="attr">success</span>:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">				uni.<span class="title function_">hideLoading</span>()</span><br><span class="line">				<span class="comment">// 后端返回异常</span></span><br><span class="line">				<span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">code</span> != <span class="number">10000</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>(option.<span class="property">fail</span> &amp;&amp; <span class="keyword">typeof</span> option.<span class="property">fail</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">						option.<span class="title function_">fail</span>(res.<span class="property">data</span>)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">if</span>(option.<span class="property">success</span> &amp;&amp; <span class="keyword">typeof</span> option.<span class="property">success</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">						option.<span class="title function_">success</span>(res.<span class="property">data</span>)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="comment">// 失败处理</span></span><br><span class="line">			<span class="attr">fail</span>:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">				uni.<span class="title function_">hideLoading</span>()</span><br><span class="line">				option.<span class="title function_">fail</span>(res.<span class="property">data</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 接口请求前添加loading效果,不能放在接口请求中，防止有接口并发，添加多个loading，单独封装，loading有仅只有一个loading效果</span></span><br><span class="line">	<span class="title function_">showLoading</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="comment">// 将状态记录缓存</span></span><br><span class="line">		<span class="keyword">const</span> isShowLoading = uni.<span class="title function_">getStorageSync</span>(<span class="string">&#x27;isShowLoading&#x27;</span>)</span><br><span class="line">		<span class="comment">// 让loading有仅只有一个loading效果</span></span><br><span class="line">		<span class="keyword">if</span>(isShowLoading)&#123;</span><br><span class="line">			uni.<span class="title function_">hideLoading</span>()</span><br><span class="line">			uni.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;isShowLoading&#x27;</span>,<span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		uni.<span class="title function_">showLoading</span>(&#123;</span><br><span class="line">			<span class="attr">title</span>: <span class="string">&#x27;加载中...&#x27;</span>,</span><br><span class="line">			<span class="attr">complete</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">				uni.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;isShowLoading&#x27;</span>,<span class="literal">true</span>)</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">fail</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">				uni.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;isShowLoading&#x27;</span>,<span class="literal">false</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Utils</span>()</span><br></pre></td></tr></table></figure>



<h4 id="uniapp-跨域解决"><a href="#uniapp-跨域解决" class="headerlink" title="uniapp 跨域解决"></a>uniapp 跨域解决</h4><ul>
<li>代理 - h5使用vite.config.js 设置代理，小程序可以在小程序的 app.json 文件中，可以配置小程序的域名白名单，允许小程序访问指定的接口域名，还可以使用小程序特有的 API 来请求数据，如 wx.request, wx.uploadFile 等。</li>
<li>使用内置浏览器</li>
</ul>
<h4 id="UniApp是一个基于Vue-js开发跨平台应用的框架，它可以通过一套代码实现在多个平台上运行，包括小程序、H5、App等。UniApp具有的特点和优势包括："><a href="#UniApp是一个基于Vue-js开发跨平台应用的框架，它可以通过一套代码实现在多个平台上运行，包括小程序、H5、App等。UniApp具有的特点和优势包括：" class="headerlink" title="UniApp是一个基于Vue.js开发跨平台应用的框架，它可以通过一套代码实现在多个平台上运行，包括小程序、H5、App等。UniApp具有的特点和优势包括："></a>UniApp是一个基于Vue.js开发跨平台应用的框架，它可以通过一套代码实现在多个平台上运行，包括小程序、H5、App等。UniApp具有的特点和优势包括：</h4><ul>
<li>跨平台：一套代码编写多端运行，提高开发效率和代码复用性。</li>
<li>性能优越：底层基于原生渲染，性能接近原生应用。</li>
<li>开发便捷：使用Vue.js开发，具备Vue.js的开发特性和生态系统。</li>
<li>社区活跃：拥有庞大的开发者社区和丰富的第三方组件库支持。</li>
</ul>
<h4 id="UniApp的跨平台原理"><a href="#UniApp的跨平台原理" class="headerlink" title="UniApp的跨平台原理"></a>UniApp的跨平台原理</h4><p>UniApp的跨平台原理是基于编译的方式实现的。通过将Vue.js的代码编译为各个平台所需的代码，然后在不同平台的渲染引擎中运行。UniApp根据不同的平台生成相应的代码，使其能够在小程序、H5、App等多个平台上运行。</p>
<h4 id="打包和发布UniApp项目"><a href="#打包和发布UniApp项目" class="headerlink" title="打包和发布UniApp项目"></a>打包和发布UniApp项目</h4><p>打包和发布UniApp项目可以使用HBuilder X进行操作。在HBuilder X中选择相应的菜单和配置项来进行打包和发布，根据不同平台和发布渠道选择相应的选项和配置参数。</p>
<h4 id="申请发布小程序的流程"><a href="#申请发布小程序的流程" class="headerlink" title="申请发布小程序的流程"></a>申请发布小程序的流程</h4><ol>
<li><strong>开发小程序：</strong> 首先，您需要开发和完善小程序的功能和页面。可以使用开发工具进行调试和预览，确保小程序的功能和体验符合要求。</li>
<li><strong>注册账号：</strong> 您需要在微信小程序官网上注册开发者账号，需要提供相关资料进行实名认证和注册。注册成功后，您可以登录小程序后台进行后续操作。</li>
<li><strong>完善信息：</strong> 进入小程序后台，完善小程序的基本信息，包括小程序名称、图标、描述、类目等。确保信息准确、完整且符合微信的规定。</li>
<li><strong>提交审核：</strong> 在小程序后台提交小程序审核申请，上传小程序代码包、填写版本更新内容等信息。审核会对小程序进行功能、界面、内容等方面的审核。</li>
<li><strong>等待审核：</strong> 提交审核后，需等待微信小程序官方进行审核。审核周期一般为1-7个工作日，具体时间根据审核工作量而定。</li>
<li><strong>审核结果：</strong> 审核通过后，您会收到审批通过的消息，可以在小程序后台进行发布和上线；若审核未通过，需根据反馈修改问题并重新提交审核。</li>
<li><strong>相关域名</strong>:  <strong>服务器域名</strong>+ <strong>业务域名(h5项目根目录下加上效验文件)</strong> + <strong>uploadFile合法域名</strong> + <strong>downloadFile合法域名</strong></li>
<li><strong>提交代码</strong></li>
<li><strong>发布上线：</strong> 审核通过后，您可以在小程序后台进行版本发布上线操作。发布后，用户可以在微信中搜索和使用您的小程序了。</li>
</ol>
<h4 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h4><ol>
<li>可以在UniApp的<code>App.vue</code>文件中通过<code>&lt;style&gt;</code>标签编写全局样式，也可以在<code>common</code>目录下的样式文件中定义全局样式。通过在<code>manifest.json</code>中的<code>globalStyle</code>字段配置全局样式文件。</li>
<li>配置文件</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MyUniApp&quot;</span><span class="punctuation">,</span> <span class="comment">// 小程序名称  </span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A UniApp mini program&quot;</span><span class="punctuation">,</span> <span class="comment">// 小程序描述  </span></span><br><span class="line">  <span class="attr">&quot;appid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wx1234567890&quot;</span><span class="punctuation">,</span> <span class="comment">// 小程序的AppID  </span></span><br><span class="line">  <span class="attr">&quot;versionName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span> <span class="comment">// 版本名称  </span></span><br><span class="line">  <span class="attr">&quot;versionCode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span> <span class="comment">// 版本号  </span></span><br><span class="line">  <span class="attr">&quot;provider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WeChat&quot;</span><span class="punctuation">,</span> <span class="comment">// 提供商，即小程序平台  </span></span><br><span class="line">  <span class="attr">&quot;uni&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// UniApp 特定配置  </span></span><br><span class="line">    <span class="attr">&quot;webpackChain&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// 自定义Webpack配置  </span></span><br><span class="line">    <span class="attr">&quot;mainfestVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span> <span class="comment">//Mainfest 版本  </span></span><br><span class="line">    <span class="attr">&quot;optimizeMainPackage&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span> <span class="comment">// 是否进行主包优化  </span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 小程序页面配置  </span></span><br><span class="line">    <span class="punctuation">&#123;</span>  </span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/index/index&quot;</span><span class="punctuation">,</span> <span class="comment">// 页面路径  </span></span><br><span class="line">      <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 页面样式配置  </span></span><br><span class="line">        <span class="attr">&quot;app-plus&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  </span><br><span class="line">          <span class="attr">&quot;navigationBarTitleText&quot;</span><span class="punctuation">:</span> <span class="string">&quot;首页&quot;</span><span class="punctuation">,</span> <span class="comment">// 在App端显示的页面标题  </span></span><br><span class="line">          <span class="attr">&quot;navigationStyle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;custom&quot;</span> <span class="comment">// 页面导航栏样式，custom表示自定义导航栏  </span></span><br><span class="line">        <span class="punctuation">&#125;</span>  </span><br><span class="line">      <span class="punctuation">&#125;</span>  </span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="punctuation">&#123;</span>  </span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/detail/detail&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  </span><br><span class="line">        <span class="attr">&quot;app-plus&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  </span><br><span class="line">          <span class="attr">&quot;navigationBarTitleText&quot;</span><span class="punctuation">:</span> <span class="string">&quot;详情页&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">          <span class="attr">&quot;navigationStyle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;custom&quot;</span>  </span><br><span class="line">        <span class="punctuation">&#125;</span>  </span><br><span class="line">      <span class="punctuation">&#125;</span>  </span><br><span class="line">    <span class="punctuation">&#125;</span>  </span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;tabBar&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 底部TabBar配置  </span></span><br><span class="line">    <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#666666&quot;</span><span class="punctuation">,</span> <span class="comment">// 未选中文字颜色  </span></span><br><span class="line">    <span class="attr">&quot;selectedColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#3cc51f&quot;</span><span class="punctuation">,</span> <span class="comment">// 选中文字颜色  </span></span><br><span class="line">    <span class="attr">&quot;backgroundColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ffffff&quot;</span><span class="punctuation">,</span> <span class="comment">// 背景颜色  </span></span><br><span class="line">    <span class="attr">&quot;borderStyle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span> <span class="comment">// 边框样式  </span></span><br><span class="line">    <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// TabBar 列表  </span></span><br><span class="line">      <span class="punctuation">&#123;</span>  </span><br><span class="line">        <span class="attr">&quot;pagePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/index/index&quot;</span><span class="punctuation">,</span> <span class="comment">// 页面路径  </span></span><br><span class="line">        <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;首页&quot;</span><span class="punctuation">,</span> <span class="comment">// Tab文字  </span></span><br><span class="line">        <span class="attr">&quot;iconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/tabbar/home.png&quot;</span><span class="punctuation">,</span> <span class="comment">// 未选中图标路径  </span></span><br><span class="line">        <span class="attr">&quot;selectedIconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/tabbar/home_active.png&quot;</span> <span class="comment">// 选中图标路径  </span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="punctuation">&#123;</span>  </span><br><span class="line">        <span class="attr">&quot;pagePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/cart/cart&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">        <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;购物车&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">        <span class="attr">&quot;iconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/tabbar/cart.png&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">        <span class="attr">&quot;selectedIconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/tabbar/cart_active.png&quot;</span>  </span><br><span class="line">      <span class="punctuation">&#125;</span>  </span><br><span class="line">    <span class="punctuation">]</span>  </span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;networkTimeout&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 网络请求超时时间配置  </span></span><br><span class="line">    <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="number">10000</span><span class="punctuation">,</span> <span class="comment">// 请求超时时间  </span></span><br><span class="line">    <span class="attr">&quot;connectSocket&quot;</span><span class="punctuation">:</span> <span class="number">10000</span><span class="punctuation">,</span> <span class="comment">// 连接 WebSocket 超时时间  </span></span><br><span class="line">    <span class="attr">&quot;uploadFile&quot;</span><span class="punctuation">:</span> <span class="number">10000</span><span class="punctuation">,</span> <span class="comment">// 上传文件超时时间  </span></span><br><span class="line">    <span class="attr">&quot;downloadFile&quot;</span><span class="punctuation">:</span> <span class="number">10000</span> <span class="comment">// 下载文件超时时间  </span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;permission&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 小程序权限配置  </span></span><br><span class="line">    <span class="attr">&quot;scope.userLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 用户地理位置权限  </span></span><br><span class="line">      <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;您的位置信息将用于定位服务&quot;</span>  </span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;scope.userInfo&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 用户个人信息权限  </span></span><br><span class="line">      <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;您的个人信息将用于展示&quot;</span>  </span><br><span class="line">    <span class="punctuation">&#125;</span>  </span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;sitemapLocation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sitemap.json&quot;</span> <span class="comment">// 小程序sitemap配置文件路径  </span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><h4 id="vue2和vue3的区别"><a href="#vue2和vue3的区别" class="headerlink" title="vue2和vue3的区别"></a>vue2和vue3的区别</h4><ol>
<li><p><strong>性能优化</strong>：</p>
<ul>
<li>Vue 3 重写了虚拟 DOM 渲染器，引入了更高效的编译器和静态提升等技术，以提高整体性能。</li>
<li>使用 Proxy 替代 Object.defineProperty 实现数据响应式，从而提供更快速和更直观的响应式系统。</li>
</ul>
</li>
<li><p><strong>Composition API</strong>：</p>
<ul>
<li>在 Vue 3 中引入了 Composition API，利用使用hook的方式引入vue API</li>
</ul>
</li>
<li><p><strong>Teleport 组件</strong>：</p>
<ul>
<li>引入了 Teleport 组件，在代码中可以方便地挂载子组件到任意 DOM 节点上。</li>
</ul>
</li>
<li><p><strong>Fragment 标签</strong>：</p>
<ul>
<li>引入了 Fragment 标签（<code>&lt;template&gt;</code> 上添加 <code>v-if</code>、<code>v-for</code> 等指令），使得模板中可以直接使用无需额外包裹根元素。</li>
</ul>
</li>
<li><p><strong>Tree-shaking 支持</strong>：</p>
<ul>
<li>对于常见打包工具如 webpack、rollup 等有很好支持，在构建时能够进行更全面有效的 Tree-shaking。</li>
</ul>
</li>
<li><p><strong>ts 支持</strong>：</p>
<ul>
<li>在 Vue 3 中使用 TypeScript 结合组合式API可以让开发者享受到更强大、便捷和安全性方面有所提升。</li>
</ul>
</li>
</ol>
<h4 id="object-defineproperty如何监听基本数据类型，对象属性，数组，为什么无法获取数组变化"><a href="#object-defineproperty如何监听基本数据类型，对象属性，数组，为什么无法获取数组变化" class="headerlink" title="object.defineproperty如何监听基本数据类型，对象属性，数组，为什么无法获取数组变化"></a>object.defineproperty如何监听基本数据类型，对象属性，数组，为什么无法获取数组变化</h4><ul>
<li><strong>Object.defineProperty 监听基本数据类型</strong>：通过包装对象的方式来对基本数据类型进行监听，因为基本数据类型并不是对象，无法直接使用 <code>Object.defineProperty</code> 来进行属性定义。</li>
<li><strong>Object.defineProperty 监听对象属性</strong>：给对象的属性添加getter 和 setter 函数，当给定的对象的属性被访问或修改时，可以触发相应的 getter 和 setter 函数。</li>
<li><strong>Object.defineProperty 监听数组</strong>：使用 <code>Object.defineProperty</code> 监听数组时，会为数组的索引属性设置 <code>get</code> 和 <code>set</code> 方法来实现监听数组元素的读取和修改操作。</li>
<li><strong>无法获取数组变化原因</strong>：操作数组时，并不会触发属性的 <code>set</code> 方法。因为修改的实际上是数组的内部结构，而不是修改数组对象的属性，无法被拦截监听到</li>
<li><strong>解决方法</strong>：为了监听数组的变化，Vue专门设计用于监听数组响应式操作的方法，如 <code>$set</code>、<code>$delete</code>，这些方法可以拦截数组的操作。vue3使用 <code>Proxy</code> 可以更方便地监听数组的变化，因为它可以直接拦截数组的操作，而不需要为数组的每个索引属性都设置 <code>get</code> 和 <code>set</code> 方法</li>
</ul>
<h4 id="Vue-中使用-data-包裹属性的原因"><a href="#Vue-中使用-data-包裹属性的原因" class="headerlink" title="Vue 中使用 data 包裹属性的原因"></a><strong>Vue 中使用 data 包裹属性的原因</strong></h4><ol>
<li><strong>数据响应式</strong>：将数据定义在 <code>data</code> 对象中可以使这些数据变成响应式的。当数据发生变化时，Vue 能够检测到并自动更新相关的视图，从而实现数据和视图的同步更新。</li>
<li><strong>组件作用域</strong>：将数据放在 <code>data</code> 对象中可以确保这些数据只在当前组件的作用域内有效，避免了数据命名冲突</li>
<li><strong>方便管理</strong>：通过将所有数据都放在 <code>data</code> 对象中，可以更好地组织和管理组件内部的数据，使代码结构更清晰、易读和易维护。</li>
<li><strong>Vue 实例化时合并处理</strong>：Vue 在实例化组件时会将 <code>data</code> 对象进行合并处理，确保组件能够正确访问到其中定义的数据。</li>
</ol>
<h4 id="组件中data是函数不是对象为什么"><a href="#组件中data是函数不是对象为什么" class="headerlink" title="组件中data是函数不是对象为什么"></a>组件中data是函数不是对象为什么</h4><p>组件data是函数，vue实例data既可以是对象也可以是函数；</p>
<p>组件中的 <code>data</code> 选项通常是一个函数而不是一个对象。这是因为 Vue 在实例化组件时会将组件的配置选项进行合并处理，如果 <code>data</code> 是一个对象，那么所有该组件实例共享同一份数据对象，可能会导致数据互相影响。</p>
<h4 id="vue生命周期和组件间生命周期顺序"><a href="#vue生命周期和组件间生命周期顺序" class="headerlink" title="vue生命周期和组件间生命周期顺序"></a>vue生命周期和组件间生命周期顺序</h4><p><strong>Vue 2 生命周期</strong></p>
<p>Vue 2 的组件生命周期钩子如下：</p>
<ol>
<li><strong>beforeCreate</strong>：实例被创建，数据观测和事件配置尚未开始。</li>
<li><strong>created</strong>：实例已完成创建，数据观测和事件配置已完成，$el 还未挂载。</li>
<li><strong>beforeMount</strong>：在挂载开始之前被调用，相关的 render 函数首次被调用。</li>
<li><strong>mounted</strong>：实例被挂载到 DOM 上，此时可以进行 DOM 操作。</li>
<li><strong>beforeUpdate</strong>：数据变化后，组件重新渲染之前被调用。</li>
<li><strong>updated</strong>：组件重新渲染后被调用。</li>
<li><strong>beforeDestroy</strong>：组件实例销毁之前被调用，可以进行清理工作。</li>
<li><strong>destroyed</strong>：组件实例被销毁后调用，再也不可使用。</li>
</ol>
<p><strong>Vue 3 生命周期</strong></p>
<p>Vue 3 对生命周期钩子的命名方式进行了调整，同时引入了 Composition API。Vue 3 的组件生命周期钩子如下：</p>
<ol>
<li><strong>setup</strong></li>
<li><strong>beforeMount</strong>：同 Vue 2。</li>
<li><strong>mounted</strong>：同 Vue 2。</li>
<li><strong>beforeUpdate</strong>：同 Vue 2。</li>
<li><strong>updated</strong>：同 Vue 2。</li>
<li><strong>beforeUnmount</strong>：对应 Vue 2 的 <code>beforeDestroy</code>，组件实例销毁之前调用。</li>
<li><strong>unmounted</strong>：对应 Vue 2 的 <code>destroyed</code>，组件实例被销毁后调用。</li>
</ol>
<p><strong>组件间的生命周期顺序</strong></p>
<ol>
<li>父组件<ul>
<li><code>beforeCreate</code></li>
<li><code>created</code></li>
<li><code>beforeMount</code></li>
<li>子组件<ul>
<li><code>beforeCreate</code></li>
<li><code>created</code></li>
<li><code>beforeMount</code></li>
<li><code>mounted</code></li>
</ul>
</li>
<li><code>mounted</code></li>
</ul>
</li>
<li>父组件更新时<ul>
<li><code>beforeUpdate</code></li>
<li>子组件<ul>
<li><code>beforeUpdate</code></li>
<li><code>updated</code></li>
</ul>
</li>
<li><code>updated</code></li>
</ul>
</li>
<li>父组件销毁时<ul>
<li><code>beforeUnmount</code></li>
<li>子组件<ul>
<li><code>beforeUnmount</code></li>
<li><code>unmounted</code></li>
</ul>
</li>
<li><code>unmounted</code></li>
</ul>
</li>
</ol>
<h4 id="computed和watch的区别和应用场景"><a href="#computed和watch的区别和应用场景" class="headerlink" title="computed和watch的区别和应用场景"></a>computed和watch的区别和应用场景</h4><blockquote>
<p>computed和watch都是用来监听数据变化并执行相应操作的功能<br>computed适合用于计算衍生数据，而watch适合用于观察和响应数据的变化，执行比较复杂的逻辑操作。</p>
</blockquote>
<ol>
<li>computed - 计算属性：<ul>
<li>computed是Vue.js中的计算属性，它会根据依赖的数据动态地生成新的数值。</li>
<li>computed属性是基于它的依赖进行<strong>缓存</strong>的，只有依赖的数据发生改变时，computed属性才会重新计算。</li>
<li>computed适合用于基于已有的数据计算出新的数据的场景，如数据的转换、筛选、排序等操作。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例  </span></span><br><span class="line"><span class="attr">computed</span>: &#123;  </span><br><span class="line">  <span class="title function_">fullName</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>watch - 监听器：<ul>
<li>watch用于观察和响应Vue实例上的数据变动，当数据变化时执行相应的操作。</li>
<li>watch可以监听某个特定数据的变化，执行一些异步或复杂逻辑，并且可以对数据的变化进行深度监听。</li>
<li>watch适合用于在数据变化时执行异步操作，或者对数据的变化进行更细粒度的控制。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例  </span></span><br><span class="line"><span class="attr">watch</span>: &#123;  </span><br><span class="line">  <span class="title function_">firstName</span>(<span class="params">newVal, oldVal</span>) &#123;  </span><br><span class="line">    <span class="comment">// Do something when firstName changes  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="vue如何定义路由"><a href="#vue如何定义路由" class="headerlink" title="vue如何定义路由"></a>vue如何定义路由</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home.vue&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About.vue&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [  </span><br><span class="line">  &#123;  </span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,  </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span>,  </span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Home</span>,  </span><br><span class="line">  &#125;,  </span><br><span class="line">  &#123;  </span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,  </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;About&#x27;</span>,  </span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">About</span>,  </span><br><span class="line">  &#125;,  </span><br><span class="line">];  </span><br><span class="line"><span class="comment">// 通过createRouter创建路由实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;  </span><br><span class="line">    <span class="comment">// 设置路由模式  History 模式</span></span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),  </span><br><span class="line">    <span class="comment">// 设置 hash模式</span></span><br><span class="line">  <span class="comment">//history: createWebHashHistory(),</span></span><br><span class="line">  routes,  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>

<h4 id="hash和history-路由模式区别"><a href="#hash和history-路由模式区别" class="headerlink" title="hash和history 路由模式区别"></a>hash和history 路由模式区别</h4><p><strong>URL 结构</strong></p>
<ul>
<li><p><strong>Hash 模式</strong>：</p>
<ul>
<li><p>URL 中包含一个<code>#</code>符号，后面跟着路由路径。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/#/about  </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>#</code> 符号后面的部分被称为 “hash”，它不会被浏览器发送到服务器。</p>
</li>
</ul>
</li>
<li><p><strong>History 模式</strong>：</p>
<ul>
<li><p>URL 中没有<code>#</code>符号，而是使用常规的路由路径。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/about  </span><br></pre></td></tr></table></figure>
</li>
<li><p>这种方式更符合 RESTful 风格的 URL。</p>
</li>
</ul>
</li>
</ul>
<p><strong>浏览器支持</strong></p>
<ul>
<li>Hash 模式<ul>
<li>兼容所有浏览器，包括较老的版本，因为它使用了简易的 URL 结构。</li>
</ul>
</li>
<li>History 模式<ul>
<li>需要现代浏览器的支持（大部分现代浏览器都支持 HTML5 的 History API）。老旧浏览器可能不支持。</li>
</ul>
</li>
</ul>
<p><strong>服务器部署</strong></p>
<ul>
<li><strong>Hash 模式</strong>：<ul>
<li>不需要特别的服务器配置，因为所有哈希路由都在前端处理，服务器只需提供初始的 HTML 文件。</li>
</ul>
</li>
<li><strong>History 模式</strong>：<ul>
<li>需要服务器配置以确保所有路由都指向同一个 HTML 文件。这通常涉及到重定向规则，保证用户访问的 URL 返回的是应用的前端代码。否则会出现404</li>
</ul>
</li>
</ul>
<p><strong>并发处理</strong></p>
<ul>
<li><strong>Hash 模式</strong>：<ul>
<li>当 URL 改变时，浏览器只是改变了 hash 部分，这不会导致页面重新加载。</li>
</ul>
</li>
<li><strong>History 模式</strong>：<ul>
<li>URL 的变化会导致浏览器的状态变化，前进、后退按钮的处理也需要依赖于 History API。</li>
</ul>
</li>
</ul>
<h4 id="v-show和v-if区别"><a href="#v-show和v-if区别" class="headerlink" title="v-show和v-if区别"></a>v-show和v-if区别</h4><ol>
<li>v-show是通过CSS的display属性来控制元素的显示和隐藏，而v-if是通过DOM操作来添加或删除元素来实现的。v-show的初始渲染比v-if快</li>
<li>v-show适用于频繁切换显示和隐藏的元素，因为它只是简单地切换CSS属性，不会引起DOM的重新渲染。而v-if适用于不经常切换的元素，因为它会在DOM中添加或删除元素，会引起DOM的重新渲染。</li>
<li>如果当前组件在 created 中存在接口的调用，不销毁组件，重新获取，就会获取到错误的数据，通常建议使用v-if而不是v-show。</li>
<li>v-show不支持<template>元素，而v-if可以作用在<template>元素上使用。</template></template></li>
<li><strong>当组件需要在指定时机创建，在指定时机销毁时，需要使用 v-if。而 当组件仅需要创建一次时，则可以使用 v-show。</strong></li>
</ol>
<h4 id="v-if和v-for的优先级"><a href="#v-if和v-for的优先级" class="headerlink" title="v-if和v-for的优先级"></a>v-if和v-for的优先级</h4><p>vue2：v-for的优先级高于v-if。会先确保在循环渲染列表时能够完全渲染，再进行条件判断条件判断</p>
<p>vue3：在 vue3 中 v-if 的优先级要高于 v-for，当v-if的条件为false时，Vue 3会跳过整个v-for循环，不会对列表中的每个元素进行渲染</p>
<h4 id="v-for的key作用，v-for遍历数组中能否使用index作为key"><a href="#v-for的key作用，v-for遍历数组中能否使用index作为key" class="headerlink" title="v-for的key作用，v-for遍历数组中能否使用index作为key"></a>v-for的key作用，v-for遍历数组中能否使用index作为key</h4><p>可以，但不推荐，可能会引发一下问题</p>
<ol>
<li>当数组数据发生变化时，可能会导致不必要的重新渲染。</li>
<li>如果数组中的元素位置发生变化，可能会导致错误的DOM元素被更新。</li>
<li>不利于Vue正确地跟踪每个元素的状态和身份。</li>
</ol>
<h4 id="vue组件通信方式"><a href="#vue组件通信方式" class="headerlink" title="vue组件通信方式"></a>vue组件通信方式</h4><p> <strong>父子组件通信</strong></p>
<ul>
<li><strong>Props</strong>：<ul>
<li>父组件通过 <code>props</code> 向子组件传递数据。</li>
</ul>
</li>
<li><strong>$emit</strong>：<ul>
<li>子组件通过 <code>$emit</code> 向父组件发送事件和数据。</li>
</ul>
</li>
<li><strong>Slots</strong>：<ul>
<li>用于在父组件中定义内容，以便在子组件中使用。</li>
<li>适合需要灵活插槽内容的场景。</li>
</ul>
</li>
</ul>
<p><strong>兄弟组件通信</strong></p>
<ul>
<li><strong>通过父组件</strong>：<ul>
<li>兄弟组件通过共同的父组件进行通信，父组件接收子组件的事件并再次传递给另一个子组件。</li>
</ul>
</li>
<li><strong>Event Bus</strong>：<ul>
<li>可以创建一个事件总线（Event Bus）用于非父子关系组件之间的通信。</li>
</ul>
</li>
</ul>
<p><strong>Provide&#x2F;Inject</strong></p>
<ul>
<li>用于祖先组件与后代组件之间的通信。</li>
<li>适合深层嵌套组件的场景。</li>
</ul>
<h4 id="vuex-pinia"><a href="#vuex-pinia" class="headerlink" title="vuex&#x2F; pinia"></a>vuex&#x2F; pinia</h4><ul>
<li>用于跨多个组件的复杂状态管理。</li>
<li>适合中大型应用程序。</li>
</ul>
<h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue - router"></a>vue - router</h3><h4 id="vue-router-底层原理"><a href="#vue-router-底层原理" class="headerlink" title="vue-router 底层原理"></a>vue-router 底层原理</h4><blockquote>
<p>Vue Router是Vue.js官方提供的路由管理器，用于实现单页应用（SPA）的路由功能。</p>
</blockquote>
<p>它的底层原理主要涉及路由注册、路由匹配及导航等几个关键部分：</p>
<ol>
<li>路由注册：<ul>
<li>Vue Router通过调用<code>Vue.use()</code>方法来注册插件，将其安装到Vue实例上。在安装过程中，它会创建一个Router实例并注入到Vue根实例的options属性中，使得每个组件实例都可以通过this.<em>o<strong>pt</strong>i<strong>o</strong>n**s</em>属性中，使得每个组件实例都可以通过<em>t<strong>hi</strong>s</em>.router访问到Router实例。</li>
</ul>
</li>
<li>路由匹配：<ul>
<li>Vue Router通过创建一个路由映射表来实现路由匹配功能。这个映射表定义了路由路径与相应组件的对应关系。</li>
<li>在创建Router实例时，可以通过配置选项（如routes）来定义映射表。映射表可以使用路由配置对象来表示，每个配置对象包含了路径（path）和组件（component）的对应关系。</li>
<li>在路由匹配过程中，Vue Router会根据当前URL路径匹配映射表中的路径匹配规则，并确定要渲染的组件。</li>
</ul>
</li>
<li>导航：<ul>
<li>导航是指用户在浏览器中输入URL、点击链接或调用编程式导航时触发的路由跳转行为。</li>
<li>在导航时，Vue Router会根据当前URL路径匹配到的路由规则，找到匹配的组件，并调用它们进行渲染。</li>
<li>在导航期间，Vue Router还提供了一些导航守卫（navigation guards）的机制，允许开发人员在导航的不同阶段（如路由切换前后）执行一些特定逻辑。</li>
</ul>
</li>
</ol>
<h4 id="Vue-Router是什么？它解决了什么问题？"><a href="#Vue-Router是什么？它解决了什么问题？" class="headerlink" title="Vue Router是什么？它解决了什么问题？"></a>Vue Router是什么？它解决了什么问题？</h4><ul>
<li>Vue Router是Vue官方提供的路由管理器，用于实现单页应用的路由功能。它通过提供路由映射、路由切换、导航守卫等机制，帮助开发者实现页面之间的跳转和组件的动态渲染，从而构建SPA应用。</li>
</ul>
<h4 id="Vue-Router中的路由模式有哪些？它们有什么区别？"><a href="#Vue-Router中的路由模式有哪些？它们有什么区别？" class="headerlink" title="Vue Router中的路由模式有哪些？它们有什么区别？"></a>Vue Router中的路由模式有哪些？它们有什么区别？</h4><ul>
<li>Vue Router有两种常见的路由模式：hash模式和history模式。</li>
<li>在hash模式下，URL中的哈希值（#）用于标识不同的路由，这种模式兼容性好，但URL中会有一个#号。</li>
<li>在history模式下，使用浏览器的原生History API来管理路由，URL更加友好，但在不支持HTML5 History API的浏览器中需要做额外处理。</li>
</ul>
<h4 id="Vue-Router的路由导航守卫有哪些？它们的作用是什么？"><a href="#Vue-Router的路由导航守卫有哪些？它们的作用是什么？" class="headerlink" title="Vue Router的路由导航守卫有哪些？它们的作用是什么？"></a>Vue Router的路由导航守卫有哪些？它们的作用是什么？</h4><ul>
<li>Vue Router提供了三个导航守卫：beforeEach、beforeRouteEnter和beforeRouteLeave。</li>
<li>beforeEach用于全局前置守卫，可以在路由切换之前执行一些逻辑操作，如验证登录状态。</li>
<li>beforeRouteEnter在路由渲染组件之前执行，可以访问组件实例，但无法获取组件的this对象。</li>
<li>beforeRouteLeave在路由离开组件之前执行，可以阻止离开或询问用户是否确定离开。</li>
</ul>
<h4 id="如何实现动态路由？"><a href="#如何实现动态路由？" class="headerlink" title="如何实现动态路由？"></a>如何实现动态路由？</h4><ul>
<li>在Vue Router中，可以通过使用动态路径参数来实现动态路由。例如，在路由配置中，使用冒号（:）来定义动态参数。</li>
<li>例如：<code>&#123; path: &#39;/user/:id&#39;, component: User &#125;</code>，其中:id是一个动态参数，可以匹配&#x2F;user&#x2F;1、&#x2F;user&#x2F;2等路径。</li>
</ul>
<h4 id="如何在Vue组件中进行路由跳转？"><a href="#如何在Vue组件中进行路由跳转？" class="headerlink" title="如何在Vue组件中进行路由跳转？"></a>如何在Vue组件中进行路由跳转？</h4><ul>
<li>在Vue组件中，可以使用<code>this.$router.push()</code>方法进行路由跳转。</li>
<li>例如：<code>this.$router.push(&#39;/home&#39;)</code>，跳转到名为home的路由。</li>
</ul>
<h4 id="Vue-Router中怎样实现路由懒加载（按需加载）？"><a href="#Vue-Router中怎样实现路由懒加载（按需加载）？" class="headerlink" title="Vue Router中怎样实现路由懒加载（按需加载）？"></a>Vue Router中怎样实现路由懒加载（按需加载）？</h4><ul>
<li>Vue Router可以通过使用Webpack的动态import语法实现路由懒加载。</li>
<li>通过在路由配置中使用<code>component: () =&gt; import(&#39;@/views/Home&#39;)</code>来实现按需加载。</li>
</ul>
<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><h4 id="vuex状态持久化解决方案"><a href="#vuex状态持久化解决方案" class="headerlink" title="vuex状态持久化解决方案"></a>vuex状态持久化解决方案</h4><ol>
<li>利用本地存储</li>
<li>安装一个vuex的插件 vuex-persistedstate</li>
</ol>
<h4 id="vuex的设计与实现"><a href="#vuex的设计与实现" class="headerlink" title="vuex的设计与实现"></a>vuex的设计与实现</h4><p>它通过存储、管理和同步应用的所有组件的状态来管理数据。</p>
<p>Vuex的设计主要包括以下几个核心概念：</p>
<ol>
<li>State（状态）</li>
<li>Mutations（变化）</li>
<li>Actions（操作）</li>
<li>Getters（获取器）</li>
</ol>
<h3 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h3><p><strong>创建Pinia实例</strong> - Vue.js应用程序的入口文件（通常是<code>main.js</code>）中，创建一个Pinia实例并将其添加到Vue应用程序中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>  </span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)  </span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()  </span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(pinia)  </span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>定义状态</strong> - 可以使用<code>defineStore</code>函数定义状态。创建一个新的<code>.js</code>文件，例如<code>counter.js</code>，并在其中定义一个计数器状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./counter.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, &#123;  </span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;  </span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>  </span><br><span class="line">  &#125;),  </span><br><span class="line">  <span class="attr">actions</span>: &#123;  </span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;  </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="title function_">decrement</span>(<span class="params"></span>) &#123;  </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>--  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>在组件中使用状态</strong> - 可以使用<code>useStore</code>函数来访问和使用Pinia中定义的状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;div&gt;  </span><br><span class="line">    &lt;p&gt;Count: &#123;&#123; counter.count &#125;&#125;&lt;/p&gt;  </span><br><span class="line">    &lt;button @click=&quot;counter.increment()&quot;&gt;Increment&lt;/button&gt;  </span><br><span class="line">    &lt;button @click=&quot;counter.decrement()&quot;&gt;Decrement&lt;/button&gt;  </span><br><span class="line">  &lt;/div&gt;  </span><br><span class="line">&lt;/template&gt;  </span><br><span class="line"></span><br><span class="line">&lt;script&gt;  </span><br><span class="line">import &#123; useCounterStore &#125; from &#x27;./counter.js&#x27;  </span><br><span class="line"></span><br><span class="line">export default &#123;  </span><br><span class="line">  setup() &#123;  </span><br><span class="line">    const counter = useCounterStore()  </span><br><span class="line"></span><br><span class="line">    return &#123;  </span><br><span class="line">      counter  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="双向数据绑定原理"><a href="#双向数据绑定原理" class="headerlink" title="双向数据绑定原理"></a>双向数据绑定原理</h4><p>在 Vue 2 中，双向数据绑定是通过 Object.defineProperty() 方法对数据对象的属性进行劫持实现的。当数据对象被创建时，Vue 2 会递归地将对象的属性转换为 getter 和 setter，并在属性被访问或修改时触发更新</p>
<p>在 Vue 3 中，采用了 Proxy 对象替代了 Object.defineProperty()。</p>
<h4 id="v-model-vue2与vue3分别作用在普通元素和组件元素的区别"><a href="#v-model-vue2与vue3分别作用在普通元素和组件元素的区别" class="headerlink" title="v-model - vue2与vue3分别作用在普通元素和组件元素的区别"></a>v-model - vue2与vue3分别作用在普通元素和组件元素的区别</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 当作用于普通元素时，v-model在vue2与vue3没有什么区别</span><br><span class="line"><span class="tag">&lt;<span class="name">inpuy</span> <span class="attr">v-model</span>=<span class="string">&quot;a&quot;</span> /&gt;</span></span><br><span class="line">// 等价于</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;a&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;(e)=&gt;&#123;a=e.target.value&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">// 当v-model 用于自定义组件键上时</span><br><span class="line">// vue2</span><br><span class="line"><span class="tag">&lt;<span class="name">son</span> <span class="attr">v-model</span>=<span class="string">&quot;a&quot;</span>/&gt;</span></span><br><span class="line">//等价于</span><br><span class="line"><span class="tag">&lt;<span class="name">son</span> <span class="attr">:value</span>=<span class="string">&quot;a&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;(a)=&gt;&#123;a=e&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">// vue3</span><br><span class="line"><span class="tag">&lt;<span class="name">son</span> <span class="attr">v-model</span>=<span class="string">&quot;a&quot;</span>/&gt;</span></span><br><span class="line">//等价于</span><br><span class="line"><span class="tag">&lt;<span class="name">son</span> <span class="attr">:modelValue</span>=<span class="string">&quot;a&quot;</span> @<span class="attr">update:modelValue</span>=<span class="string">&quot;(e)=&gt;&#123;a=e&#125;&quot;</span>/&gt;</span></span><br><span class="line">// 子组件可以直接用defindprops接受modelValue</span><br><span class="line">// 全称为</span><br><span class="line"><span class="tag">&lt;<span class="name">son</span> <span class="attr">v-model:modelValue</span>=<span class="string">&quot;a&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="nextTick作用"><a href="#nextTick作用" class="headerlink" title="nextTick作用"></a>nextTick作用</h4><p><code>nextTick</code> 是 Vue 中的一个异步方法，它的作用是在 DOM 更新之后执行回调函数。<code>nextTick</code> 方法接受一个回调函数作为参数，并在 DOM 更新完成后执行该回调函数。因为在页面渲染后执行，可以在vue中获取到最新的DOM元素</p>
<h4 id="虚拟Dom"><a href="#虚拟Dom" class="headerlink" title="虚拟Dom"></a>虚拟Dom</h4><p>虚拟 DOM 是一个轻量级的 JavaScript 对象树，它是对真实 DOM 的抽象表示。当数据发生变化时，Vue 会通过比较新旧虚拟 DOM 树的差异，然后只更新需要变化的部分</p>
<h4 id="虚拟Dom怎么生成"><a href="#虚拟Dom怎么生成" class="headerlink" title="虚拟Dom怎么生成"></a>虚拟Dom怎么生成</h4><p>Vue 的虚拟 DOM 是通过模板编译器（Template Compiler）生成的。模板编译器会将模板解析成抽象语法树（AST），然后将 AST 转换为渲染函数（Render Function），最终生成虚拟 DOM。</p>
<h4 id="前端大量数据展示"><a href="#前端大量数据展示" class="headerlink" title="前端大量数据展示"></a>前端大量数据展示</h4><p><strong>常见解决策略和技术</strong></p>
<ol>
<li>分页</li>
<li>虚拟滚动</li>
<li>按需加载</li>
<li>数据压缩</li>
<li>服务端过滤和排序</li>
<li>前端缓存</li>
<li>数据预取</li>
<li>web workers</li>
<li>数据懒加载</li>
<li>DOM优化</li>
</ol>
<h4 id="vue-项目SPA单页面-SEO优化"><a href="#vue-项目SPA单页面-SEO优化" class="headerlink" title="vue  项目SPA单页面 SEO优化"></a>vue  项目SPA单页面 SEO优化</h4><p>单页面应用打包后会只有一个index.html。vue通过实例绑定在index.html的app根组件。通过路由的方式渲染不同内容。搜索引擎是拿不到详细信息。导致vue单页面应用很难在SEO上下很大功夫</p>
<ol>
<li><strong>SSR服务端渲染</strong> - vue的ssr框架nuxt</li>
<li><strong>预渲染</strong> - Vue CLI 插件 <code>prerender-spa-plugin</code> 来预渲染应用程序的静态 HTML 页面。这个插件会在构建过程中访问应用程序的每个路由，并将生成的 HTML 文件保存在 dist 目录下，使得搜索引擎能够直接查看到页面内容。</li>
<li><strong>设置页面元信息：</strong> 在 Vue 组件中使用 <code>vue-meta</code> 插件设置页面的 title、meta description 等元信息，以便搜索引擎正确抓取并展示页面内容</li>
<li><strong>设置站点地图</strong></li>
</ol>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><h4 id="react理解-和-特征"><a href="#react理解-和-特征" class="headerlink" title="react理解 和 特征"></a>react理解 和 特征</h4><p>​	<strong>理解</strong></p>
<ul>
<li>react是构建用户界面的js库，提供了UI层面的解决方案</li>
<li>遵循组件设计，声明式编程，函数式编程概念</li>
<li>使用虚拟DOM来操纵实际DOM，减少性能开支</li>
<li>react将界面分割成独立小块，每一块为一个组件，通过组件嵌套组合构成整个页面</li>
</ul>
<p>​	<strong>特性</strong></p>
<ul>
<li>JSX语法</li>
<li>单项数据流</li>
<li>虚拟DOM</li>
<li>声明式编程，函数式编程</li>
<li>组件化</li>
</ul>
<h4 id="MVC和MVVM"><a href="#MVC和MVVM" class="headerlink" title="MVC和MVVM"></a>MVC和MVVM</h4><p>MVC是一种经典的软件架构模式，将应用程序划分为三个组件：模型（Model）、视图（View）和控制器（Controller）。其中，模型负责存储和处理数据，视图负责展示数据，而控制器负责处理用户交互，更新模型和视图之间的关系。<br>数据流的通常方向是单向的，即控制器更新模型的数据，并将更新后的数据传递给视图进行展示。</p>
<p>用户交互 -&gt; 控制器 -&gt; 视图 &amp; 模型 (模型的改变并不会自动触发视图更改，当模型数据发生变化后，如果需要通知控制器更新视图)</p>
<p>MVVM是一种衍生于MVC的软件架构模式，将应用程序划分为三个组件：模型（Model）、视图（View）和视图模型（ViewModel）。其中，视图模型负责管理视图所需要的所有数据和行为，并通过数据绑定将模型中的数据绑定到视图中。<br>在MVVM中，数据流的通常方向是双向的，即视图模型可以将用户的输入直接更新到模型中，并且模型中的数据的变化也可以自动更新到视图上。</p>
<p>用户交互 -&gt; 控制器 -&gt; 模型 -&gt; 视图 (更改了模型会自动同步到视图)</p>
<h4 id="Flux是什么"><a href="#Flux是什么" class="headerlink" title="Flux是什么"></a>Flux是什么</h4><h4 id="什么是jsx"><a href="#什么是jsx" class="headerlink" title="什么是jsx"></a>什么是jsx</h4><p>一种语言的扩展，简化了代码的开发。它利用了js语法和html标签相结合的语法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用react createElement创建元素</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> reactElement = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">	h3,</span><br><span class="line">    &#123;<span class="attr">className</span>:<span class="string">&#x27;name_vale&#x27;</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;Element Value&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//jsx 语法</span></span><br><span class="line"><span class="keyword">const</span> reactElement = (</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">className</span>=<span class="string">&#x27;name_value&#x27;</span>&gt;</span>Element Value<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h4 id="react引入css方式"><a href="#react引入css方式" class="headerlink" title="react引入css方式"></a>react引入css方式</h4><ol>
<li>使用普通的 CSS 文件：<ul>
<li>创建一个 CSS 文件，例如 <code>styles.css</code>。</li>
<li>在需要引入 CSS 的组件中使用 <code>import</code> 语句引入 CSS 文件：<code>import &#39;./styles.css&#39;;</code></li>
<li>React 会将该 CSS 文件添加到页面中，并应用于引入它的组件。</li>
</ul>
</li>
<li>使用 CSS 模块化：<ul>
<li>在需要引入 CSS 的组件中创建一个 CSS 文件，例如 <code>styles.module.css</code>。</li>
<li>在组件中使用 <code>import</code> 语句引入 CSS 文件：<code>import styles from &#39;./styles.module.css&#39;;</code></li>
<li>在 JSX 中使用引入的 CSS 类名：<code>&lt;div className=&#123;styles.container&#125;&gt;Hello, React!&lt;/div&gt;</code></li>
<li>React 会为每个组件生成一个独特的 CSS 类名，以确保样式的隔离性和可重用性。</li>
</ul>
</li>
<li>使用 CSS-in-JS 库：<ul>
<li>CSS-in-JS 是一种将 CSS 写入 JavaScript 文件的方法，通过 JavaScript 中的对象来定义样式。</li>
<li>有许多流行的 CSS-in-JS 库可供选择，例如 Styled Components、Emotion、Material-UI 等。</li>
<li>使用选定的 CSS-in-JS 库，将样式与组件逻辑相关联，然后将样式应用到组件</li>
</ul>
</li>
</ol>
<h4 id="怎么实现react组件间过渡动画"><a href="#怎么实现react组件间过渡动画" class="headerlink" title="怎么实现react组件间过渡动画"></a>怎么实现react组件间过渡动画</h4><ol>
<li>css代码：例如 <code>transition</code> 属性来处理渐变过渡或 <code>transform</code> 属性来处理平移过渡。</li>
<li>使用 React 动画库：如 React Transition Group、React Spring、Framer Motion</li>
</ol>
<h4 id="React-工作原理"><a href="#React-工作原理" class="headerlink" title="React 工作原理"></a>React 工作原理</h4><p>React会创建一个虚拟DOM。 当一个组件的状态改变时，React首先会通过Diff算法来标记虚拟DOM中的改变，第二步是调节，会用diff的结构来更新DOM</p>
<h4 id="react-事件机制"><a href="#react-事件机制" class="headerlink" title="react 事件机制"></a>react 事件机制</h4><p>在React中，事件机制与原生的DOM事件机制有所不同。React事件系统是基于合成事件（SyntheticEvent）的，它是React封装的一种跨浏览器的事件系统，提供了一套统一的事件接口以解决不同浏览器之间的兼容性问题。</p>
<p>React事件机制的一些特点包括：</p>
<ol>
<li>事件绑定：React使用驼峰命名的事件名称来绑定事件处理函数，例如<code>onClick</code>、<code>onChange</code>等。</li>
<li>合成事件对象：React封装的合成事件对象<code>SyntheticEvent</code>对原生事件对象进行了封装，提供了与原生事件相同的属性和方法，同时提供了跨浏览器的兼容性。</li>
<li>事件代理：React通过事件代理的方式处理事件，将所有事件监听器注册在顶层容器上，然后通过事件冒泡机制来分发事件，这样可以提高性能并减少内存占用。</li>
<li>事件处理函数：事件处理函数在React中通常作为组件的方法来定义，需要谨慎处理函数内部的<code>this</code>指向，可以使用箭头函数或者在构造函数中绑定<code>this</code>来避免出现错误。</li>
<li>阻止事件冒泡和默认行为：可以通过合成事件对象的<code>stopPropagation()</code>方法来阻止事件冒泡，通过<code>preventDefault()</code>方法来阻止事件的默认行为。</li>
</ol>
<p>React事件机制相比原生浏览器事件有更好的跨浏览器兼容性，提供了更统一的事件接口，并且采用事件代理的方式来提高性能。</p>
<h4 id="react-绑定事件的方式有哪些，有什么区别"><a href="#react-绑定事件的方式有哪些，有什么区别" class="headerlink" title="react 绑定事件的方式有哪些，有什么区别"></a>react 绑定事件的方式有哪些，有什么区别</h4><ol>
<li>直接在JSX中使用箭头函数绑定事件处理函数：<br>这种方式会导致每次渲染时都会创建一个新的函数，可能会影响性能。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;Click me&lt;/button&gt;  </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在构造函数中绑定this并将方法作为实例方法：<br>通过在构造函数中绑定this，确保事件处理函数中的this指向组件实例，避免每次渲染都创建新的函数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;  </span><br><span class="line">  super(props);  </span><br><span class="line">  this.handleClick = this.handleClick.bind(this);  </span><br><span class="line">&#125;  </span><br><span class="line">function handleClick()&#123;</span><br><span class="line">    //click</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;  </span><br><span class="line">  return &lt;button onClick=&#123;this.handleClick&#125;&gt;Click me&lt;/button&gt;;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在类的属性上使用实验性语法public class fields绑定实例方法：<br>使用箭头函数作为类的属性可以直接绑定this，不需要在构造函数中单独绑定。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    handleClick = () =&gt; &#123;  </span><br><span class="line">  	// handle click  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">    render() &#123;  </span><br><span class="line">      return &lt;button onClick=&#123;this.handleClick&#125;&gt;Click me&lt;/button&gt;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用bind方法绑定this并传递参数：<br>可以使用<code>bind</code>方法将参数传递给事件处理函数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleClick(param) &#123;  </span><br><span class="line">  // handle click with param  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">render() &#123;  </span><br><span class="line">  return &lt;button onClick=&#123;this.handleClick.bind(this, param)&#125;&gt;Click me&lt;/button&gt;;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>





<h4 id="React有什么优点"><a href="#React有什么优点" class="headerlink" title="React有什么优点"></a>React有什么优点</h4><ul>
<li>模版引入JSX语法，使得组件的代码更加可读，也更容易看懂组件布局和组件间的引用</li>
<li>支持服务端渲染，对SEO和性能进行改进</li>
<li>React 只关注View层，所以可以和其他任何框架一起使用</li>
</ul>
<h4 id="react中类组件和函数组件的理解"><a href="#react中类组件和函数组件的理解" class="headerlink" title="react中类组件和函数组件的理解"></a>react中类组件和函数组件的理解</h4><p>​	<strong>类组件</strong></p>
<ol>
<li><strong>定义方式</strong></li>
</ol>
<ul>
<li>使用 ES6 的类语法定义，需继承自 <code>React.Component</code>。</li>
<li>通常具有生命周期方法（如 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code> 等）。</li>
<li>需要使用 <code>this</code> 关键字来访问和管理组件的状态和方法</li>
<li>类组件调用方式需要对组件进行实例化，调用render方法</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;  </span><br><span class="line">    <span class="variable language_">super</span>(props);  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  increment = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);  </span><br><span class="line">  &#125;;  </span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> (  </span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">    );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>状态管理</strong><ul>
<li><strong>类组件</strong>使用 <code>state</code> 对象来管理组件的状态，并通过 <code>this.setState</code> 方法来更新状态。</li>
</ul>
</li>
<li><strong>生命周期方法</strong><ul>
<li><strong>类组件</strong>有完整的生命周期方法，可以在特定的阶段执行某些代码（如在组件挂载、更新和卸载时）。</li>
</ul>
</li>
</ol>
<p><strong>函数式组件</strong></p>
<ol>
<li><strong>定义方式</strong></li>
</ol>
<ul>
<li>使用 JavaScript 函数定义，通常是无状态的。</li>
<li>从 React 16.8 开始，函数组件可以使用 <code>Hooks</code>（如 <code>useState</code> 和 <code>useEffect</code>）来管理状态和副作用。</li>
<li>不需要使用 <code>this</code> 关键字</li>
<li>函数式组件调用即执行函数</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyFunctionComponent</span> = (<span class="params"></span>) =&gt; &#123;  </span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;  </span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);  </span><br><span class="line">  &#125;;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">  );  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>状态管理</strong><ul>
<li><strong>函数组件</strong>使用 <code>useState</code> Hook 来管理状态，更加灵活和简洁。</li>
</ul>
</li>
<li><strong>生命周期方法</strong><ul>
<li><strong>函数组件</strong>没有生命周期方法，但可以使用 <code>useEffect</code> Hook 来实现相同的效果，基于依赖数组控制副作用的执行时机。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>区别</th>
<th>函数组件</th>
<th>类组件</th>
</tr>
</thead>
<tbody><tr>
<td>是否有this</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>是否有生命周期</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>是否有状态state</td>
<td>没有</td>
<td>有</td>
</tr>
</tbody></table>
<h4 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h4><p>React组件生命周期可以分为3个阶段 ：(初始化 -)挂载 - 更新 - 销毁( - 错误捕获)</p>
<div class="tabs" id="unique-name"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="unique-name-1">挂载( Mounting)</button><button type="button" class="tab " data-href="unique-name-2">更新( Updating)</button><button type="button" class="tab " data-href="unique-name-3">卸载( Unmounting)</button><button type="button" class="tab " data-href="unique-name-4">错误边界 (componentDidCatch)</button></ul><div class="tab-contents"><div class="tab-item-content active" id="unique-name-1"><p>组件实例化并插入DOM的过程<br>这个阶段包括以下生命周期：</p>
<ul>
<li>constructor()</li>
<li>static getDerivedStateFromProps()</li>
<li>render()</li>
<li><strong>componentDidMount()</strong></li>
</ul>
<p><strong>挂载阶段 - 详细</strong></p>
<ol>
<li>constructor()<ul>
<li>构造函数，在组件创建时调用，用于初始化状态和绑定事件处理函数</li>
<li>在构造函数中调用super(props) 来调用父类的构造函数，并将props传递给父类</li>
<li>初始化组件的状态可以通过 this,stat &#x3D; { } 实现</li>
</ul>
</li>
<li>static getDerivedStateFromProps()<ul>
<li>当组件接收新的porps时调用，在渲染之前执行。</li>
<li>用于根据新的props计算并更新组件的状态</li>
<li>应返回一个对象来更新状态，或者返回null来表示不需要更新状态</li>
</ul>
</li>
<li>render()<ul>
<li>必须得生命周期方法，用于渲染组件模板</li>
<li>返回一个React元素，秒数组件的输出</li>
<li>不能再这个方法中修改组件的状态或这行副作用操作，会导致死循环</li>
</ul>
</li>
<li>componentDidMount()<ul>
<li>在组件初始化渲染之后立即调用</li>
<li>通常执行一些初始化操作，例如网络请求，获取初始数据</li>
<li>这个方法只会在组件生命周期中调用一次</li>
</ul>
</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;<span class="title class_">Component</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>)</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;constructor&#x27;</span>)</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">props, state</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(getDerivedStateFromProps)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组件挂载后执行的代码</span></span><br><span class="line">    <span class="title function_">conponentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;conponentDidMount&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;render&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>挂载阶段生命周期<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数组件代替</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyFunctionComponent</span> = (<span class="params">&#123; someValue &#125;</span>) =&gt; &#123;  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 组件更新后执行的代码  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component updated&#x27;</span>);  </span><br><span class="line">  &#125;, [someValue]); <span class="comment">// 将某个值作为依赖，依赖项变化时执行  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="unique-name-2"><p>组件props或state发生变化，导致组件重新渲染的过程<br>这个阶段包括以下生命周期：</p>
<ul>
<li>static getDerivedStateFromProps()</li>
<li>shouldComponentUpdata()</li>
<li>render()</li>
<li>getSnapshotBeforeUpdate()</li>
<li>componentDidUpdate()</li>
</ul>
<p><strong>更新阶段生命周期 - 详细</strong></p>
<ol>
<li>shouldComponentUpdate(nextProps, nextState)<ul>
<li>在组件接收到新的props或者state时调用，在渲染之前执行</li>
<li>可以根据最新的props或者state决定是否需要重新渲染组件</li>
<li>默认返回true，表示组件将会重新渲染，可以通过返回false来阻止重新渲染</li>
</ul>
</li>
<li>render()<ul>
<li>必须得生命周期方法，用于渲染组件模板</li>
<li>返回一个React元素，秒数组件的输出</li>
<li>不能再这个方法中修改组件的状态或这行副作用操作，会导致死循环</li>
</ul>
</li>
<li>getSnapshotBeforeUpdate(prevProps, prevState)<ul>
<li>在最新的渲染输出被提交到DOM之前调用</li>
<li>用于获取更新前的DOM快照或执行一些DOM操作</li>
<li>返回值将作为componentDidUpdate方法的第三个参数</li>
</ul>
</li>
<li>conponentDidUpdate(prevProps, prevState, snapshot)<ul>
<li>在更新组件更新完成后立即调用</li>
<li>通常用于执行一些副作用操作，比如更新后的DOM操作，网络请求</li>
<li>可以访问到更新之前的props，state。以及getSnapshotBeforeUpdate返回值</li>
</ul>
</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;<span class="title class_">Component</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;constructor&#x27;</span>)</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;shouldComponentUpdate&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, prevState</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getSnapshotBeforeUpdate&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组件更新后执行的代码</span></span><br><span class="line">    <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentUpdate&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>更新生命周期<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>this.state.count += 1&#125;&gt;修改state<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数组件代替</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyFunctionComponent</span> = (<span class="params">&#123; someValue &#125;</span>) =&gt; &#123;  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 组件更新后执行的代码  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component updated&#x27;</span>);  </span><br><span class="line">  &#125;, [someValue]); <span class="comment">// 将某个值作为依赖，依赖项变化时执行  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="unique-name-3"><p>组件从DOM中移除的过程<br>这个阶段包括以下生命周期：</p>
<ul>
<li>componentWillUnmount()</li>
</ul>
<p><strong>卸载生命周期 - 详细</strong></p>
<ol>
<li>componentWillUnmount()<ul>
<li>在组件即将被销毁并从DOM中移除之前调用</li>
<li>用于执行一些清理工作，比如取消订阅，清除定时器，监听器等</li>
<li>在这个方法中不能调用setState，因为组件即将被销毁</li>
</ul>
</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;<span class="title class_">Component</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(constructor)</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组件卸载前执行的代码</span></span><br><span class="line">    <span class="title function_">componentWillUnnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ComponentWillUnmount&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>销毁组件生命周期<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数式组件代替</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyFunctionComponent</span> = (<span class="params"></span>) =&gt; &#123;  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 清理函数，在组件卸载前执行  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component will unmount&#x27;</span>);  </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;, []); <span class="comment">// 空数组将会在每次渲染后执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="unique-name-4"><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;  </span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;  </span><br><span class="line">    <span class="comment">// 处理错误  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error caught:&quot;</span>, error);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数组件本身不能实现错误边界，但可以利用类组件来包装。</p>
</blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>





<h4 id="如何跟踪功能组件的卸载"><a href="#如何跟踪功能组件的卸载" class="headerlink" title="如何跟踪功能组件的卸载"></a>如何跟踪功能组件的卸载</h4><p>在函数式组件中，useEffect可以返回一个清理函数，可以在清理函数中定义要清楚理的资源。在DOM组件删除之前调用，清理设置，防止内存泄漏。例如计时器，订阅，监听事件</p>
<h4 id="react响应式原理"><a href="#react响应式原理" class="headerlink" title="react响应式原理"></a>react响应式原理</h4><p>React的响应式原理是基于虚拟DOM和diffing算法，通过组件化、单向数据流等特性实现了响应式更新用户界面的能力。</p>
<ol>
<li>Virtual DOM：React使用虚拟DOM（Virtual DOM）来描述UI的状态，通过对比虚拟DOM的前后状态的差异，能够高效地更新真实DOM。通过创建虚拟DOM，React可以在内存中快速构建UI结构，减少了直接操作真实DOM带来的性能开销。</li>
<li>diffing算法：React使用一种称为“reconciliation”（协调）的算法来比较前后两个版本的虚拟DOM树的差异，并且只更新真实DOM中发生变化的部分。这样可以避免不必要的DOM操作，提高页面性能。</li>
<li>组件化开发：React将UI拆分为组件，每个组件都有自己的状态（state）和属性（props）。当组件的状态或属性发生变化时，React会自动重新渲染该组件，从而实现了响应式更新。</li>
<li>单向数据流：React采用单向数据流的设计思想，父组件通过props向子组件传递数据，子组件通过回调函数将数据传递回父组件，使得数据变化时只需更新相关组件，避免了数据流混乱和难以追踪的问题。</li>
</ol>
<h4 id="render函数的理解和渲染过程"><a href="#render函数的理解和渲染过程" class="headerlink" title="render函数的理解和渲染过程"></a>render函数的理解和渲染过程</h4><p>React的render函数是React组件的一个方法，它负责渲染组件的UI，并返回一个React元素（element）或一组元素。每次组件的状态或属性发生变化时，React会重新调用render函数来生成新的虚拟DOM树，并且通过diffing算法来对比前后两个虚拟DOM树的差异。</p>
<p>React的render函数的渲染过程：</p>
<ol>
<li>组件的render函数被调用：当React组件需要重新渲染时，React会调用组件的render函数。render函数应该返回一个React元素或一组元素。</li>
<li>创建虚拟DOM（Virtual DOM）：render函数内部会创建一个虚拟DOM树，用来描述UI的状态。</li>
<li>diffing算法比较前后两个虚拟DOM的差异：React会将前后两个虚拟DOM进行比较，找出两个虚拟DOM之间的差异，并且记录下这些差异。</li>
<li>更新真实DOM：根据记录的差异，React会根据需要的操作来更新真实DOM。这些操作可能包括插入新的节点、移动节点、删除节点等。</li>
<li>提交更新：最后，React会将变化后的DOM提交给浏览器进行渲染。</li>
</ol>
<h4 id="hooks-useMemo和useCallback-区别"><a href="#hooks-useMemo和useCallback-区别" class="headerlink" title="hooks - useMemo和useCallback 区别"></a>hooks - useMemo和useCallback 区别</h4><ol>
<li><p>useMemo：</p>
<ul>
<li><p>useMemo用于优化性能，可以缓存计算结果，避免重复计算。</p>
</li>
<li><p>语法：const memoizedValue &#x3D; useMemo(() &#x3D;&gt; computeExpensiveValue(a, b), [a, b]);</p>
</li>
<li><p>useMemo接受一个函数作为第一个参数，这个函数返回一个值，还接受一个依赖数组作为第二个参数。只有依赖数组中的某些值发生变化时，才会重新计算值，并且把值缓存起来。</p>
</li>
<li><p>适用场景：当有一些计算比较昂贵，但又不希望每次渲染都重新计算时，可以使用useMemo。</p>
</li>
</ul>
</li>
<li><p>useCallback：</p>
<ul>
<li><p>useCallback用于优化性能，可以缓存一个函数，避免在每次渲染时都创建新的函数。</p>
</li>
<li><p>语法：const memoizedCallback &#x3D; useCallback(() &#x3D;&gt; { doSomething(a, b); }, [a, b]);</p>
</li>
<li><p>useCallback接受一个函数作为第一个参数，还接受一个依赖数组作为第二个参数。只有依赖数组中的某些值发生变化时，才会返回同一个函数实例，否则会返回新的函数实例。</p>
</li>
<li><p>适用场景：当需要把一个回调函数传递给子组件时，并且该回调函数依赖了一些值，为了避免每次渲染都创建新的回调函数，可以使用useCallback。</p>
</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>useMemo用于缓存计算结果，避免重复计算，适用于缓存变量或复杂的计算操作。</li>
<li>useCallback用于缓存函数，避免在每次渲染时都创建新的函数，适用于传递给子组件的回调函数。</li>
</ul>
</li>
</ol>
<h4 id="hooks-useState和useRef-区别"><a href="#hooks-useState和useRef-区别" class="headerlink" title="hooks - useState和useRef 区别"></a>hooks - useState和useRef 区别</h4><ol>
<li><p>useState：</p>
<ul>
<li><p>useState用于在函数组件中保存和更新状态。</p>
</li>
<li><p>语法：const [state, setState] &#x3D; useState(initialState);</p>
</li>
<li><p>useState接受一个初始状态值作为参数，并返回一个数组，包含当前的状态值和一个用于更新状态值的函数。</p>
</li>
<li><p>每次调用函数组件时，useState都会返回一个新的state和setState，通过调用setState可以改变状态值，并触发组件的重新渲染。</p>
</li>
<li><p>适用场景：适用于保存和更新与组件渲染相关的状态值，例如表单输入的值、组件的可见性等。</p>
</li>
</ul>
</li>
<li><p>useRef：</p>
<ul>
<li><p>useRef用于在函数组件中保存和访问变量，类似于在类组件中使用实例变量。</p>
</li>
<li><p>语法：const refContainer &#x3D; useRef(initialValue);</p>
</li>
<li><p>useRef接受一个初始值作为参数，并返回一个ref对象，该对象的.current属性指向初始值。</p>
</li>
<li><p>不同于useState，在调用ref对象的.current属性时，不会触发组件的重新渲染。</p>
</li>
<li><p>适用场景：适用于保存和访问需要在组件的多个渲染之间保持稳定的值，例如定时器的引用、获取DOM元素的引用等。</p>
</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li><p>useState用于保存和更新与组件渲染相关的状态值，通过setState触发重新渲染。</p>
</li>
<li><p>useRef用于保存和访问需要在组件的多个渲染之间保持稳定的值，不会触发重新渲染。</p>
</li>
</ul>
</li>
</ol>
<h4 id="useEffect依赖项只传一个依赖项或空数组或不传依赖项的区别"><a href="#useEffect依赖项只传一个依赖项或空数组或不传依赖项的区别" class="headerlink" title="useEffect依赖项只传一个依赖项或空数组或不传依赖项的区别"></a>useEffect依赖项只传一个依赖项或空数组或不传依赖项的区别</h4><ol>
<li>传递一个依赖项：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;  </span><br><span class="line">  // effect函数，副作用操作  </span><br><span class="line">&#125;, [dependency]);  </span><br></pre></td></tr></table></figure>

<ul>
<li>当依赖项发生变化时，effect函数会被调用，即只有在依赖项变化时，effect会执行。</li>
<li>这种情况下，effect函数只会在依赖项发生变化时执行一次。</li>
</ul>
<ol start="2">
<li>传递空数组：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;  </span><br><span class="line">  // effect函数，副作用操作  </span><br><span class="line">&#125;, []);  </span><br></pre></td></tr></table></figure>

<ul>
<li>当传递空数组作为依赖项时，effect函数只会在组件挂载时执行一次，类似于componentDidMount生命周期方法。</li>
<li>这种情况下，effect函数只会在初始化渲染时执行一次。</li>
</ul>
<ol start="3">
<li>不传递依赖项：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;  </span><br><span class="line">  // effect函数，副作用操作  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>当不传递依赖项时，effect函数会在每次组件渲染时都执行。</li>
<li>这种情况下，无论什么状态发生变化，effect函数都会执行。</li>
</ul>
<h4 id="useEffect的return-函数在依赖项不同的情况下，有何区别"><a href="#useEffect的return-函数在依赖项不同的情况下，有何区别" class="headerlink" title="useEffect的return 函数在依赖项不同的情况下，有何区别"></a>useEffect的return 函数在依赖项不同的情况下，有何区别</h4><ol>
<li>当依赖项发生改变：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;  </span><br><span class="line">  // effect函数，副作用操作  </span><br><span class="line"></span><br><span class="line">  return () =&gt; &#123;  </span><br><span class="line">    // 返回函数，用于清理副作用操作  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;, [dependency]);  </span><br></pre></td></tr></table></figure>

<ul>
<li>当依赖项发生改变时，先执行之前返回的函数，然后再执行更新后的effect函数。</li>
<li>这样做的好处是，在依赖项发生改变后，先执行清理函数，再重新进行副作用操作。</li>
</ul>
<ol start="2">
<li>当依赖项为空数组：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;  </span><br><span class="line">  // effect函数，副作用操作  </span><br><span class="line"></span><br><span class="line">  return () =&gt; &#123;  </span><br><span class="line">    // 返回函数，用于清理副作用操作  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;, []);  </span><br></pre></td></tr></table></figure>

<ul>
<li>当依赖项为空数组时，仅在组件被销毁时才会执行返回的函数，类似于componentWillUnmount生命周期方法。</li>
<li>这种情况下，返回的函数只会在组件卸载时执行一次。</li>
</ul>
<ol start="3">
<li>未传递依赖项：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;  </span><br><span class="line">  // effect函数，副作用操作  </span><br><span class="line"></span><br><span class="line">  return () =&gt; &#123;  </span><br><span class="line">    // 返回函数，用于清理副作用操作  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>当没有传递依赖项时，每次组件重新渲染时都会先执行之前返回的函数，然后再执行更新后的effect函数。</li>
<li>这表示返回的函数会在每次effect函数调用之前执行。</li>
</ul>
<h4 id="React-Hooks底层原理，如何实现状态更新"><a href="#React-Hooks底层原理，如何实现状态更新" class="headerlink" title="React Hooks底层原理，如何实现状态更新"></a>React Hooks底层原理，如何实现状态更新</h4><p>React Hooks是React 16.8引入的一项新特性，使函数组件能够拥有类似于类组件中state和生命周期方法的能力。</p>
<ol>
<li><p>类组件：</p>
<ul>
<li><p>在类组件中，状态更新是通过调度器（Scheduler）和渲染器（Renderer）之间的交互完成的。调度器负责管理何时执行或中断更新，并决定何时运行副作用。调度器会根据一定的优先级策略，安排哪些更新需要进行，以确保性能和优化。</p>
</li>
<li><p>调度器会触发进行协调阶段，比较新旧虚拟DOM，找出需要更新的部分，然后触发重新渲染阶段。在重新渲染阶段，渲染器会负责将更新后的虚拟DOM转换为实际的DOM，并更新到页面上。</p>
</li>
</ul>
</li>
<li><p>函数组件（使用Hooks）：</p>
<ul>
<li><p>在函数组件中，React使用Fiber架构来进行组件的协调和渲染。Fiber是一种链表数据结构，用于表示组件的工作单元以及记录组件的状态、副作用和子节点。每个组件对应一个Fiber节点，通过这些Fiber节点组成链表，来进行高效的更新和调度。</p>
</li>
<li><p>当触发状态更新时，React以类似协程的方式对Fiber链表进行遍历和更新，以保证更新的优先级和顺序。React会通过Fiber节点的优先级处理，决定哪些更新要先执行，哪些更新可以延后执行，以提高用户界面的响应性和性能。</p>
</li>
</ul>
</li>
</ol>
<h4 id="怎么实现全局数据存储"><a href="#怎么实现全局数据存储" class="headerlink" title="怎么实现全局数据存储?"></a>怎么实现全局数据存储?</h4><p>要实现全局数据存储，可以使用一些常用的方法，如React的Context API或第三方库( Redux，MobX)</p>
<ol>
<li>使用React的Context API：<ul>
<li>React的Context API允许我们创建一个全局的上下文对象，用于在组件树中共享数据。通过在Provider组件中提供值，可以使所有后代组件都能够访问到这些数据。</li>
<li>在创建全局数据存储时，可以使用Context API创建一个Context对象，并将需要共享的数据放在Provider组件的value属性中。然后，使用Consumer或useContext钩子在组件中获取该数据。</li>
</ul>
</li>
<li>使用Redux：<ul>
<li>Redux是一个流行的状态管理库，通过单一的状态树（Store）来管理整个应用的状态。通过Redux的createStore函数创建一个全局Store，然后在需要共享数据的组件中使用Provider组件将其包裹。</li>
<li>使用Redux Persist可以将Redux中的数据持久化存储到本地存储中，例如LocalStorage或AsyncStorage。Redux Persist提供了一个Store增强器，使得数据可以在刷新页面或重新加载应用后被还原。</li>
</ul>
</li>
</ol>
<p>同<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=vuex&spm=1001.2101.3001.7020">vuex</a>一样，redux中的状态会在刷新浏览器后状态又恢复到初始状态，有些数据想在浏览器刷新后仍然是在最新的状态，不会丢失，就需要借助一些插件实现。</p>
<h4 id="父组件渲染如何让子组件不渲染，类组件和hooks方法"><a href="#父组件渲染如何让子组件不渲染，类组件和hooks方法" class="headerlink" title="父组件渲染如何让子组件不渲染，类组件和hooks方法"></a>父组件渲染如何让子组件不渲染，类组件和hooks方法</h4><p><strong>类组件</strong></p>
<ul>
<li><p><strong>条件渲染</strong>：在父组件的 <code>render</code> 方法中使用条件语句，根据特定条件决定是否渲染子组件。例如，可以使用 <code>if</code> 语句或三元表达式来控制子组件的渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ParentComponent extends React.Component &#123;  </span><br><span class="line">  render() &#123;  </span><br><span class="line">    const shouldRenderChild = // 根据某个条件判断是否渲染子组件  </span><br><span class="line">    return (  </span><br><span class="line">      &lt;div&gt;  </span><br><span class="line">        &#123;shouldRenderChild &amp;&amp; &lt;ChildComponent /&gt;&#125;  </span><br><span class="line">      &lt;/div&gt;  </span><br><span class="line">    );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过 props 控制</strong>：将一个布尔类型的 prop 传递给子组件，根据该 prop 的值决定子组件是否进行渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ParentComponent extends React.Component &#123;  </span><br><span class="line">  render() &#123;  </span><br><span class="line">    const shouldRenderChild = // 根据某个条件判断是否渲染子组件  </span><br><span class="line">    return (  </span><br><span class="line">      &lt;div&gt;  </span><br><span class="line">        &lt;ChildComponent shouldRender=&#123;shouldRenderChild&#125; /&gt;  </span><br><span class="line">      &lt;/div&gt;  </span><br><span class="line">    );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class ChildComponent extends React.Component &#123;  </span><br><span class="line">  render() &#123;  </span><br><span class="line">    if (!this.props.shouldRender) &#123;  </span><br><span class="line">      return null; // 不渲染子组件  </span><br><span class="line">    &#125;  </span><br><span class="line">    return (  </span><br><span class="line">      // 子组件的渲染内容  </span><br><span class="line">    );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>函数组件</strong></p>
<ul>
<li><strong>条件渲染</strong>：在函数组件中使用条件语句，根据特定条件决定是否返回子组件的 JSX。例如，可以使用 <code>if</code> 语句或三元表达式来控制子组件的渲染。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function ParentComponent() &#123;  </span><br><span class="line">  const shouldRenderChild = // 根据某个条件判断是否渲染子组件  </span><br><span class="line">  return (  </span><br><span class="line">    &lt;div&gt;  </span><br><span class="line">      &#123;shouldRenderChild &amp;&amp; &lt;ChildComponent /&gt;&#125;  </span><br><span class="line">    &lt;/div&gt;  </span><br><span class="line">  );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>通过 props 控制</strong>：将一个布尔类型的 prop 传递给子组件，根据该 prop 的值决定是否返回子组件的 JSX。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function ParentComponent() &#123;  </span><br><span class="line">  const shouldRenderChild = // 根据某个条件判断是否渲染子组件  </span><br><span class="line">  return (  </span><br><span class="line">    &lt;div&gt;  </span><br><span class="line">      &lt;ChildComponent shouldRender=&#123;shouldRenderChild&#125; /&gt;  </span><br><span class="line">    &lt;/div&gt;  </span><br><span class="line">  );  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">function ChildComponent(&#123; shouldRender &#125;) &#123;  </span><br><span class="line">  if (!shouldRender) &#123;  </span><br><span class="line">    return null; // 不渲染子组件  </span><br><span class="line">  &#125;  </span><br><span class="line">  return (  </span><br><span class="line">    // 子组件的渲染内容  </span><br><span class="line">  );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>





<h4 id="state-状态-和props-属性-区别"><a href="#state-状态-和props-属性-区别" class="headerlink" title="state( 状态)和props( 属性)区别"></a>state( 状态)和props( 属性)区别</h4><p>一个组件状态可以由两个参数决定：内部数据state，外部数据props</p>
<p>state：是一种数据结构，用于组件挂载时所需数据的默认值。由内部定义，组件初始化时定义，需要通过setState进行修改<br>props：是组件的配置。一般由父组件或兄弟组件进行传递，在组件内部是不能被修改的，</p>
<h4 id="super-和-super-props"><a href="#super-和-super-props" class="headerlink" title="super() 和 super(props)"></a>super() 和 super(props)</h4><p><code>super()</code>和<code>super(props)</code>都是用于在子类的构造函数中调用父类的构造函数。</p>
<ol>
<li><code>super()</code>: 在子类的构造函数中调用<code>super()</code>，表示调用父类的构造函数，并将父类的属性和方法继承到子类中。这样子类可以使用父类的属性和方法，实现代码的复用。</li>
<li><code>super(props)</code>: <code>super(props)</code>在子类的构造函数中表示调用父类的构造函数，并将子类的props传递给父类。这在使用props的情况下非常有用，可以确保在子类中使用props之前，父类的构造函数已经接收到了相应的props。</li>
</ol>
<p>在React中，当子类继承自<code>React.Component</code>时，通常会在子类的构造函数中调用<code>super(props)</code>，以确保正确地初始化父类。这样可以在子类中使用<code>this.props</code>来访问传递给组件的属性。</p>
<h4 id="什么是props透传"><a href="#什么是props透传" class="headerlink" title="什么是props透传"></a>什么是props透传</h4><p>props透传指的是通过多层嵌套的组件传递props的一个过程。为了方便开发和维护。一层一层传递props，不现实。<br>所以可以使用其他模式：使用上下文(Context&#x2F; useContext) 或状态管理库(Redux) )来代替porps透传。这种些方法不需要每个组件传递props</p>
<h4 id="什么是React-上下文-contest"><a href="#什么是React-上下文-contest" class="headerlink" title="什么是React 上下文 - contest"></a>什么是React 上下文 - contest</h4><p>react contest 是一项功能，它提供一种在组件数中传递数据的方法，而无需再每一层手动传递。它允许创建一个全局状态。被包裹的任何子孙组件都能访问该状态</p>
<p>Context API 由三部分组成：</p>
<ol>
<li>createContext：创建上下文</li>
<li>Context.provider 该组件用于为上下文提供值，被该标签包裹的子组件可以获取value的值</li>
<li>Context.Consumer 或useContext hooks: 获取从上下文中传递的值。</li>
</ol>
<h4 id="渲染数组元素"><a href="#渲染数组元素" class="headerlink" title="渲染数组元素"></a>渲染数组元素</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Reacr</span> <span class="keyword">from</span> <span class="string">&#x27;reacr&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">listElement</span>:<span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> list  = [</span><br><span class="line">        <span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;py&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;ts&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        	<span class="tag">&lt;<span class="name">ul</span>&gt;</span> &#123;list.map((item, index, array)=&gt;<span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span> )&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="为什么使用map-时需要key"><a href="#为什么使用map-时需要key" class="headerlink" title="为什么使用map() 时需要key"></a>为什么使用map() 时需要key</h4><p>可以帮助React确定元素的更改，添加，或移动等操作。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Reacr</span> <span class="keyword">from</span> <span class="string">&#x27;reacr&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">listElement</span>:<span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> list  = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">        	<span class="attr">lang</span>: <span class="string">&#x27;js&#x27;</span></span><br><span class="line">    	&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">lang</span>: <span class="string">&#x27;py&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">       	&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">lang</span>: <span class="string">&#x27;ts&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        	<span class="tag">&lt;<span class="name">ul</span>&gt;</span> &#123;list.map((item, index, array)=&gt;(</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">item.id</span>&#125;`&#125;&gt;</span>&#123;item.lang&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span> )&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h4><p><strong>受控组件</strong></p>
<p>受控组件是指在组件的状态与表单元素的值之间存在严格的联系的组件。</p>
<ul>
<li>表单元素的值由组件状态控制。</li>
<li>通过事件处理程序（如 <code>onChange</code>）更新状态。</li>
<li>组件对输入值的控制使得表单具有更强的可预测性和可控性。</li>
</ul>
<p><strong>非受控组件</strong></p>
<p>非受控组件是指组件的状态不通过 React 的状态来管理，而是使用 React 的 <code>ref</code> 来直接访问 DOM 元素的值。</p>
<ul>
<li>表单元素的值直接在 DOM 中存储，而不是节点状态。</li>
<li>可以通过 <code>ref</code> 来访问和获取输入值。</li>
<li>更适合于表单逻辑较简单的场景或不需要对每次输入进行实时验证的情况。</li>
</ul>
<h4 id="如何实现移除定时器"><a href="#如何实现移除定时器" class="headerlink" title="如何实现移除定时器"></a>如何实现移除定时器</h4><p>在 React 中，移除定时器通常需要在组件卸载时进行操作。在类组件中你可以利用 React 提供的生命周期方法 <code>componentWillUnmount</code> 来实现移除定时器的功能。在函数组件中可以利用useEffect hooks 的回调函数进行移除</p>
<h4 id="react-组件通信"><a href="#react-组件通信" class="headerlink" title="react 组件通信"></a>react 组件通信</h4><p><strong>父子组件通信</strong></p>
<ul>
<li><strong>Props：</strong><ul>
<li>父组件通过 <code>props</code> 向子组件传递数据。</li>
</ul>
</li>
<li><strong>回调函数</strong>：<ul>
<li>子组件通过调用父组件传递的回调函数来向父组件传递数据。</li>
</ul>
</li>
</ul>
<p><strong>兄弟组件通信</strong></p>
<ul>
<li><strong>通过父组件</strong>：<ul>
<li>兄弟组件通过共同的父组件进行通信，即父组件管理兄弟组件的状态。</li>
</ul>
</li>
<li><strong>Context API</strong><ul>
<li>用于跨组件传递数据，而不需要通过每一级组件传递 props。</li>
</ul>
</li>
</ul>
<p><strong>Event Emitters</strong></p>
<ul>
<li>可以使用事件发射器模式来实现组件间的通信，尽管这在 React 中不太常见，通常还是倾向于使用 React 的内建机制。</li>
</ul>
<p><strong>Refs</strong></p>
<ul>
<li>通过 <code>ref</code> 可以直接访问子组件的实例方法或属性，但这种方式不太符合 React 的数据流理念，需谨慎使用。</li>
</ul>
<p><strong>React hooks</strong> (自定义 hooks)</p>
<ul>
<li>创建自定义 hooks 以共享逻辑和状态。</li>
</ul>
<h4 id="hooks-useState有什么特点"><a href="#hooks-useState有什么特点" class="headerlink" title="hooks - useState有什么特点"></a>hooks - useState有什么特点</h4><p>useState 返回一个状态值和一个更新函数</p>
<p>在初始化渲染期间，返回的状态与初始匹配。使用更新函数进行状态更新时，采用新状态值作为参数，进行异步更新，重新渲染不会触发useState API。更新函数还可以接受函数返回值的方式。</p>
<p>react18，将所有事件都进行批处理，即多次setState会被合并为1次执行，提高了性能，在数据层，将多个状态更新合并成一次处理（在视图层，将多次渲染合并成一次渲染）</p>
<h4 id="hooks-useEffect有什么特点"><a href="#hooks-useEffect有什么特点" class="headerlink" title="hooks - useEffect有什么特点"></a>hooks - useEffect有什么特点</h4><p>useEffect钩子允许在功能组件中执行副作用，，例如数据获取、订阅、手动操作 DOM 等。它使你能够在函数组件中处理这些副作用，同时保留组件的声明式架构。</p>
<ul>
<li>第一个参数是一个函数，执行副作用的代码。</li>
<li>第二个参数是一个数组，指定了依赖项。只有当依赖项发生变化时，副作用才会重新执行。</li>
</ul>
<p><strong>作用的执行时机</strong></p>
<p><code>useEffect</code> 在组件的生命周期中执行的时机如下：</p>
<ul>
<li><strong>组件挂载时</strong>：当组件首次渲染到 UI 上时。</li>
<li><strong>依赖项变化时</strong>：如果指定了依赖项数组，当数组中的某个值发生变化时，<code>useEffect</code> 会重新执行。</li>
<li><strong>组件卸载时</strong>：如果提供了清理函数，它会在组件卸载或依赖项变化时调用。</li>
</ul>
<p><strong>依赖数组</strong></p>
<p>当依赖数组为空时，<code>useEffect</code> 只在组件挂载时执行一次，类似于 class 组件的 <code>componentDidMount</code>。<br>如果依赖数组中包含状态或 props，副作用将在组件挂载和依赖项变化时执行。<br>如果不提供依赖数组，<code>useEffect</code> 将在每次渲染后执行，这可能导致性能问题。</p>
<h4 id="hooks-useMemo用途？如何工作？"><a href="#hooks-useMemo用途？如何工作？" class="headerlink" title="hooks - useMemo用途？如何工作？"></a>hooks - useMemo用途？如何工作？</h4><p>用于缓存计算结构。useMemo仅在任何依赖项的值发生变化时，才会重新计算记忆值。这种优化可以帮助一些复杂，消耗性能较高的计算<br>第一个参数，接受一个执行计算的回调<br>第二个参数，接受依赖关系数组，只有至少一个依赖关系发生变化时，才会触发重新执行</p>
<h4 id="hooks-useCallback用途？如何工作？"><a href="#hooks-useCallback用途？如何工作？" class="headerlink" title="hooks - useCallback用途？如何工作？"></a>hooks - useCallback用途？如何工作？</h4><h4 id="hooks-useMemo和useCallback有什么区别"><a href="#hooks-useMemo和useCallback有什么区别" class="headerlink" title="hooks - useMemo和useCallback有什么区别"></a>hooks - useMemo和useCallback有什么区别</h4><ol>
<li>useMemo： 用于缓存计算结果，而useCallback用于缓存函数本身</li>
<li>useMemo： 如果依赖项未更改，则缓存计算值并在后续渲染时返回该值</li>
<li>useCallback：缓存函数本身并返回相同实例，出非依赖项更改</li>
</ol>
<h4 id="hooks-useContext用途-如何工作"><a href="#hooks-useContext用途-如何工作" class="headerlink" title="hooks - useContext用途? 如何工作?"></a>hooks - useContext用途? 如何工作?</h4><p>React应用程序中，数据是从父组件到子组件传递。如果较深层的组件需要使用到该porps，就会嵌套很多层props，过程过于繁琐。而Context上下文，提供了在组件之间共享数据的方法，无需明确的传递props到每一层。<br>当上下文值发生改变时，useContext组件总是会重新渲染。</p>
<h4 id="hooks-useRef-用途？作用？"><a href="#hooks-useRef-用途？作用？" class="headerlink" title="hooks - useRef 用途？作用？"></a>hooks - useRef 用途？作用？</h4><p>useRef返回一个可以修改的ref对象，即一个属性。该对象当前值有传递的参数进行初始化。返回对象将在整个组件生命周期中持续存在。</p>
<h4 id="什么是React-memo"><a href="#什么是React-memo" class="headerlink" title="什么是React.memo()"></a>什么是React.memo()</h4><p>React.memo() 是一个高阶组件。如果组件总是不变，渲染相同内容。可以在某些情况下将其封装在React.mome() 中调用，避免重新渲染以提高性能。如果React.memo() 组件中使用了useState，useReducer，useContext，那么当状态或上下文发生变化时，也会重新渲染</p>
<h4 id="什么是React-Fragment"><a href="#什么是React-Fragment" class="headerlink" title="什么是React Fragment"></a>什么是React Fragment</h4><p>从组件返回多个元素是React常见做法。片段允许形成子元素列表，而无需再DOM中创建不必要的节点</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">frag</span>(<span class="params"></span>)&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son1</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son2</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"></span><br><span class="line">    &lt;!-- or --&gt;</span><br><span class="line">    &lt;<span class="title class_">React</span>.<span class="property">Fragment</span>&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Son1</span>/&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Son2</span>/&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="如何跟踪引用功能组件中对象字段的变化"><a href="#如何跟踪引用功能组件中对象字段的变化" class="headerlink" title="如何跟踪引用功能组件中对象字段的变化"></a>如何跟踪引用功能组件中对象字段的变化</h4><p>使用useEffect钩子，将对象字段作为依赖数组传递，每次渲染后会重新获取对象字段</p>
<h4 id="如何访问DOM元素"><a href="#如何访问DOM元素" class="headerlink" title="如何访问DOM元素"></a>如何访问DOM元素</h4><p>使用 React.createRef() 或 useRef(), 之后通过ref.current 获取元素属性</p>
<p><strong>Redux 或其他状态管理库</strong></p>
<ul>
<li>用于管理应用程序的全局状态，并在不同组件之间进行通信。</li>
<li>适合中大型应用程序，具有复杂状态管理需求</li>
</ul>
<h4 id="react合成事件，为什么不使用浏览器原生事件，出发点是什么，考虑什么"><a href="#react合成事件，为什么不使用浏览器原生事件，出发点是什么，考虑什么" class="headerlink" title="react合成事件，为什么不使用浏览器原生事件，出发点是什么，考虑什么"></a>react合成事件，为什么不使用浏览器原生事件，出发点是什么，考虑什么</h4><ol>
<li><p><strong>跨浏览器兼容性</strong>：</p>
<ul>
<li>不同浏览器对事件的实现和行为可能存在差异。通过合成事件，React 确保了在所有主流浏览器中事件处理的一致性，简化了开发者的工作。</li>
</ul>
</li>
<li><p><strong>性能优化</strong>：</p>
<ul>
<li>合成事件在 React 内部通过池化（event pooling）机制来管理事件。即在事件处理后，合成事件对象会被重用，减少了内存的分配和垃圾回收，提高了性能。</li>
</ul>
</li>
<li><p><strong>统一的 API</strong>：</p>
<ul>
<li>使用合成事件，React 提供了一个统一的事件处理接口，所有事件在 React 中的行为和属性是一致的。这对于开发者来说，提升了代码的可读性和可维护性。</li>
</ul>
</li>
<li><p><strong>事件生命周期管理</strong>：</p>
<ul>
<li>React 能够更好地控制事件的生命周期。这允许 React 在组件的卸载和更新过程中做出更智能的管理，避免了潜在的内存泄漏问题。</li>
</ul>
</li>
<li><p><strong>与 React 生态系统的集成</strong>：</p>
<ul>
<li>合成事件使得事件处理和 React 的整体运行机制能够更紧密地集成。比如，React 能够在事件处理过程中进行一系列优化、调度和协调操作。</li>
</ul>
</li>
<li><p><strong>简化处理逻辑</strong>：</p>
<ul>
<li>合成事件的 API 被设计得更易用，尤其是在处理高阶组件和函数组件时。合成事件使得这些情况的事件处理变得更简单。</li>
</ul>
</li>
<li><p><strong>支持新的功能</strong>：</p>
<ul>
<li>通过合成事件，React 能够更灵活地支持一些新的功能，比如暂停和恢复事件的处理，或在切换到并发模式时更好地处理事件。</li>
</ul>
</li>
</ol>
<h4 id="react18新特性"><a href="#react18新特性" class="headerlink" title="react18新特性"></a>react18新特性</h4><ul>
<li><strong>去掉了对IE浏览器的支持</strong></li>
<li><strong>事件自动批处理（Automatic Batching）</strong>：React 18 中的自动批处理允许多个状态更新被智能地合并在一起，从而减少组件的重新渲染次数。这意味着即使在异步代码中，多个状态更新也会自动批处理，提高性能。</li>
<li><strong>开始并发模式（Concurrent Rendering）</strong>：React 18 引入了并发特性，使得渲染可以被中断，以便于高优先级的更新。这样可以确保用户界面在处理复杂更新时保持响应性。</li>
<li><strong><code>Suspense</code> 组件的增强</strong>：React 18 扩展了 <code>Suspense</code> 的功能，使其不仅可以用于数据加载，还可以与并发特性结合使用。允许开发者在异步数据加载时更优雅地控制加载状态。</li>
<li><strong><code>useTransition</code> Hook</strong>：新增 <code>useTransition</code> API 来标记状态更新为过渡更新。这使得开发者可以在需要时为用户界面保留流畅性和响应性，尤其是在使用状态更新时。</li>
<li><strong><code>useDeferredValue</code> Hook</strong>：这个 Hook 允许开发者将一个状态值的更新延后一段时间，从而优化用户界面的响应。在输入框中输入文字时，可以实现更平滑的体验。</li>
<li><strong><code>startTransition</code> API</strong>：这个 API 允许开发者将某些更新标记为不紧急的，从而让 React 更加智能地管理其渲染优先级。</li>
<li><strong>全新的 <code>createRoot</code> API</strong>：React 18 引入了 <code>createRoot</code> 方法，用于挂载 React 应用的新根实例。这是采用并发特性的新推荐方式。</li>
<li><strong><code>Concurrent Features</code>的支持</strong>：React 18 允许开发者通过 <code>use</code> 和 <code>Suspense</code> 结合使用小的惰性加载逻辑，提高应用的数据获取效率和界面的可交互性。</li>
<li><strong>新特性的无缝过渡</strong>：React 18 支持在现有代码中逐步过渡到新特性，降低了更新的复杂性。</li>
</ul>
<h4 id="React-diff-算法介绍"><a href="#React-diff-算法介绍" class="headerlink" title="React diff 算法介绍"></a>React diff 算法介绍</h4><ol>
<li><strong>虚拟 DOM</strong></li>
</ol>
<p>在 React 中，每个组件都有一个对应的虚拟 DOM 树。当状态改变时，React 会重新构建新的虚拟 DOM 树。这个虚拟 DOM 是一个轻量级的 JavaScript 对象，它包含了整个真实 DOM 树的映射关系。</p>
<ol start="2">
<li><strong>Diff 算法</strong></li>
</ol>
<p>在重新构建新的虚拟DOM树后，React 使用 diff 算法来比较新旧两棵虚拟 DOM 树，并找出最小操作来更新实际的页面DOM树。</p>
<ul>
<li>属性和事件处理函数变化</li>
</ul>
<p>如果节点类型相同（比如都是 <code>div</code> 元素），但属性或事件处理函数发生了变化，则需要更新该节点上相应属性或事件处理函数。</p>
<ul>
<li>组件类型变化</li>
</ul>
<p>如果节点由组件A变成了另一个不同类型的组件B，则旧节点需要被销毁并且新节点需要创建。</p>
<ul>
<li>列表元素遍历</li>
</ul>
<p>Diff算法会遍历列表元素，准确找出哪些地方增加、删除、移动或更新了列表中的子元素。</p>
<ol start="3">
<li><p>Diff 策略</p>
<p>在进行Diff算法时，React采用以下策略：</p>
<ul>
<li><strong>深度优先遍历</strong>：React使用深度优先策略来递归比较两棵虚拟DOM树。</li>
<li><strong>双端比较</strong>：从头部和尾部同时开始比较子元素列表，在某些情况下可以大幅减少移动操作次数。</li>
<li><strong>Key属性</strong>：当为列表渲染添加唯一key属性时（通常使用数据中唯一ID），可以帮助React识别具体哪些项目被添加、删除、移动或更新。</li>
<li><strong>批量执行</strong>：将多次修改合并为一次性修改以提高性能。</li>
</ul>
</li>
</ol>
<h4 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h4><p>React Fiber 是 React 库核心算法的重写版本。React Fiber 的引入使React更适合于处理大型、复杂应用程序，并提供更灵活、更高效的渲染方式。</p>
<p>React Fiber 的关键特性包括：</p>
<ol>
<li>增量渲染：React Fiber 允许React将渲染工作分割为称为 fibers 的较小单元。这使得React能够优先安排和调度高优先级更新，从而实现更流畅的用户界面和更好的性能。</li>
<li>时间切片：时间切片是React Fiber中的一项功能，用于在多个渲染任务之间进行时间切片划分，以确保长时间运行的任务不会阻止用户界面响应。</li>
</ol>
<h3 id="React-router"><a href="#React-router" class="headerlink" title="React-router"></a>React-router</h3><h4 id="React-Router-是什么？"><a href="#React-Router-是什么？" class="headerlink" title="React Router 是什么？"></a>React Router 是什么？</h4><p>React Router 是基于 React 的官方路由库，用于在单页应用程序中管理页面导航和路由。</p>
<h4 id="React-Router-的主要特点是什么？"><a href="#React-Router-的主要特点是什么？" class="headerlink" title="React Router 的主要特点是什么？"></a>React Router 的主要特点是什么？</h4><p>React Router 的主要特点包括：声明式路由配置、嵌套路由支持、参数传递和查询参数处理、动态路由匹配、历史记录管理等。</p>
<h4 id="React-Router-的核心组件是哪些？"><a href="#React-Router-的核心组件是哪些？" class="headerlink" title="React Router 的核心组件是哪些？"></a>React Router 的核心组件是哪些？</h4><p>React Router 的核心组件包括：BrowserRouter、HashRouter、Route、Switch、Link、NavLink等。</p>
<h4 id="BrowserRouter-和-HashRouter-有什么区别？"><a href="#BrowserRouter-和-HashRouter-有什么区别？" class="headerlink" title="BrowserRouter 和 HashRouter 有什么区别？"></a>BrowserRouter 和 HashRouter 有什么区别？</h4><p>BrowserRouter 使用 HTML5 History API，不带有 # 符号，URL 更加可读性高；HashRouter 使用 URL 中的哈希值实现路由，URL 带有 # 符号，支持在不同浏览器和服务器环境中运行。</p>
<h4 id="如何在代码中定义路由？"><a href="#如何在代码中定义路由？" class="headerlink" title="如何在代码中定义路由？"></a>如何在代码中定义路由？</h4><p>使用 Route 组件来定义路由规则。将组件与路由路径相关联，以便在 URL 匹配时呈现相应的组件。</p>
<h4 id="如何在-React-Router-中传递参数？"><a href="#如何在-React-Router-中传递参数？" class="headerlink" title="如何在 React Router 中传递参数？"></a>如何在 React Router 中传递参数？</h4><p>可以在路由路径中使用占位符定义参数，并在组件内部通过 props.match.params 来访问它们。</p>
<h4 id="如何导航到另一个路由？"><a href="#如何导航到另一个路由？" class="headerlink" title="如何导航到另一个路由？"></a>如何导航到另一个路由？</h4><p>可以使用 Link 或 NavLink 组件，在点击时导航到另一个路由，并携带相关参数。</p>
<h4 id="如何在-React-Router-中使用重定向？"><a href="#如何在-React-Router-中使用重定向？" class="headerlink" title="如何在 React Router 中使用重定向？"></a>如何在 React Router 中使用重定向？</h4><p>可以使用 Redirect 组件来进行路由重定向。通过指定 from 和 to 属性，设置重定向的源路由和目标路由。</p>
<h4 id="如何在-React-Router-中处理嵌套路由？"><a href="#如何在-React-Router-中处理嵌套路由？" class="headerlink" title="如何在 React Router 中处理嵌套路由？"></a>如何在 React Router 中处理嵌套路由？</h4><p>可以使用嵌套的 Route 组件结合嵌套的路由路径来处理嵌套路由。</p>
<h4 id="React-Router-提供哪些导航守卫功能？"><a href="#React-Router-提供哪些导航守卫功能？" class="headerlink" title="React Router 提供哪些导航守卫功能？"></a>React Router 提供哪些导航守卫功能？</h4><p>React Router 提供了三个导航守卫组件：BrowserRouter、HashRouter 和 MemoryRouter。它们可以用于在路由切换前执行某些操作，如权限验证或日志记录。</p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><h4 id="什么是Redux"><a href="#什么是Redux" class="headerlink" title="什么是Redux"></a>什么是Redux</h4><p>Redux 是一个用于管理 JavaScript 应用程序状态的可预测状态容器。它可以帮助我们在应用程序中更有效地管理数据流，使状态更新变得可预测且易于调试。</p>
<h4 id="Redux有什么优点"><a href="#Redux有什么优点" class="headerlink" title="Redux有什么优点"></a>Redux有什么优点</h4><p>Redux 的优点包括：统一的数据流管理、可预测的状态变化、易于调试和跟踪、方便的中间件扩展、与 React 结合紧密、适用于复杂应用等。</p>
<h4 id="Redux-遵循的三个原则是什么"><a href="#Redux-遵循的三个原则是什么" class="headerlink" title="Redux 遵循的三个原则是什么"></a>Redux 遵循的三个原则是什么</h4><p>Redux 遵循的三个原则是：</p>
<ul>
<li>单一数据源：应用程序中的状态被存储在一个单一的 JavaScript 对象中，称为 state。</li>
<li>状态只读：状态是只读的，唯一改变状态的方式是派发一个 action。</li>
<li>纯函数修改：使用纯函数（reducers）来描述状态的变化，根据旧的 state 和 action 来返回一个新的 state。</li>
</ul>
<h4 id="对-“单一事实来源”-有什么理解"><a href="#对-“单一事实来源”-有什么理解" class="headerlink" title="对 “单一事实来源” 有什么理解"></a>对 “单一事实来源” 有什么理解</h4><p>这指的是 Redux 应用中的 state 被存储在一个单一对象树中。应用的所有组件共享此状态单一来源，并且只能通过派发 actions 来改变这个状态。这样可以使得应用程序的状态和行为更加容易追踪和管理。</p>
<h4 id="列出-Redux-组件"><a href="#列出-Redux-组件" class="headerlink" title="列出 Redux 组件"></a>列出 Redux 组件</h4><p>常见的 Redux 组件有 Action、Reducer、Store 以及 Middleware。</p>
<h4 id="数据如何通过-Redux-流动"><a href="#数据如何通过-Redux-流动" class="headerlink" title="数据如何通过 Redux 流动"></a>数据如何通过 Redux 流动</h4><p>数据通过 Redux 流动的方式是：组件派发 action，action 被发送到 reducer，reducer 处理 action 并更新 state，state 的更新通过订阅机制反馈到组件。</p>
<h4 id="如何在Redux中定义Action"><a href="#如何在Redux中定义Action" class="headerlink" title="如何在Redux中定义Action"></a>如何在Redux中定义Action</h4><p>在 Redux 中，Action 是一个包含 type 属性的普通对象，用于描述某个事件的动作类型。定义 Action 通常包括创建一个 action 构造函数，返回一个包含 type 属性的对象。</p>
<h4 id="解释Reducer的作用"><a href="#解释Reducer的作用" class="headerlink" title="解释Reducer的作用"></a>解释Reducer的作用</h4><p>Reducer 是一个纯函数，接收旧的 state 和 action，返回一个新的 state。Reducer 描述了应用程序状态的变化逻辑，根据传入的 action 来更新 state。</p>
<h4 id="Store在Redux中的意义是什么"><a href="#Store在Redux中的意义是什么" class="headerlink" title="Store在Redux中的意义是什么"></a>Store在Redux中的意义是什么</h4><p>Store 是 Redux 应用中存储 state 的地方。它是一个包含整个应用程序状态树的对象，并负责维护和更新状态。通过 createStore 方法创建 Store，并可以使用 dispatch 方法派发 actions、订阅 state 的变化等。</p>
<h4 id="Redux与Flux有什么不同"><a href="#Redux与Flux有什么不同" class="headerlink" title="Redux与Flux有什么不同"></a>Redux与Flux有什么不同</h4><p>Redux 与 Flux 的主要不同之处在于数据流的单向性和状态管理的差异。Redux 通过 reducer 来管理状态变化，强调单一数据源，并提供了数据的不可变性。而 Flux 则是一种设计模式，可以有不同的实现方式，通常包含多个 Store，且数据流向复杂一些。</p>
<h4 id="Redux-的核心概念包括-Store、Action、Reducer-和-Middleware。"><a href="#Redux-的核心概念包括-Store、Action、Reducer-和-Middleware。" class="headerlink" title="Redux 的核心概念包括 Store、Action、Reducer 和 Middleware。"></a>Redux 的核心概念包括 Store、Action、Reducer 和 Middleware。</h4><ol>
<li>Store</li>
</ol>
<p>Redux 中的 Store 是单一状态树，存储着整个应用的状态。可以通过 <code>createStore</code> 函数来创建一个 Store。</p>
<ol start="2">
<li>Action</li>
</ol>
<p>Action 是一个包含描述动作类型和负载数据的简单对象。它要求使用纯函数形式来描述对应操作，通常由 action creator 函数来创建。</p>
<ol start="3">
<li>Reducer</li>
</ol>
<p>Reducer 是一个纯函数，它接收先前的状态和 action，并返回新的状态。Reducer 定义了如何更新应用程序中相关部分的状态。</p>
<ol start="4">
<li>Dispatch</li>
</ol>
<p>Dispatch 是 store 对象提供的方法，用于触发 action 的执行并更新应用程序中相应部分的状态。</p>
<ol start="5">
<li>Middleware</li>
</ol>
<p>Middleware 允许你扩展 Redux 功能，在 action 触发到达 reducer 前进行额外处理或拦截操作。比如日志记录、异步操作等都可以通过 middleware 来实现。</p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol>
<li><strong>组件发起 Action</strong>：组件调用 <code>dispatch</code> 方法发送一个 action 到 store。</li>
<li><strong>Store 分发 Action</strong>：store 接收到 action 后将其传递给 reducer 进行处理。</li>
<li><strong>Reducer 更新 State</strong>：reducer 根据接收到的action类型以及负载数据来计算出新的 state。</li>
<li><strong>Store 更新订阅者</strong>：store 的 state 更新后会通知所有订阅者（比如 React 组件），从而重新渲染页面以反映最新 state。</li>
</ol>
<h4 id="redux数据不持久化怎么解决"><a href="#redux数据不持久化怎么解决" class="headerlink" title="redux数据不持久化怎么解决"></a>redux数据不持久化怎么解决</h4><ol>
<li>使用浏览器本地存储(localStorage&#x2F;sessionStorage)：您可以将需要持久化的状态数据存储在浏览器的本地存储中，这样即使用户刷新或关闭浏览器，数据仍然会保留在本地存储中。您可以在应用初始化时从本地存储中读取数据，并在 Redux store 中重新加载数据。</li>
<li>使用第三方插件<code>redux-persist </code>插件来实现Redux状态的持久化</li>
</ol>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><h4 id="什么是-Webpack？"><a href="#什么是-Webpack？" class="headerlink" title="什么是 Webpack？"></a>什么是 Webpack？</h4><p>Webpack 是一个前端构建工具，它将不同类型的资源（JavaScript、CSS、图片等）视为模块，通过分析模块间的依赖关系，将它们打包成一个或多个静态文件，以提高Web应用的加载速度和性能。</p>
<h4 id="Webpack-的核心概念有哪些？"><a href="#Webpack-的核心概念有哪些？" class="headerlink" title="Webpack 的核心概念有哪些？"></a>Webpack 的核心概念有哪些？</h4><ul>
<li><strong>入口（Entry）</strong>：指示 Webpack 从哪里开始构建依赖图，入口文件是应用的起点。</li>
<li><strong>输出（Output）</strong>：定义 Webpack 打包后的文件存放位置和命名规则。</li>
<li><strong>加载器（Loader）</strong>：允许 Webpack 处理非 JavaScript 文件（比如 CSS、图片、类型脚本等），将这些文件转换为模块。</li>
<li><strong>插件（Plugin）</strong>：可以扩展 Webpack 的功能，用于执行范围更广的任务，如代码压缩、提取 CSS 等。</li>
<li><strong>模块（Module）</strong>：Webpack 将文件视为模块，通过依赖管理实现模块化。</li>
</ul>
<h4 id="webpack-打包过程"><a href="#webpack-打包过程" class="headerlink" title="webpack 打包过程"></a>webpack 打包过程</h4><ol>
<li><strong>解析入口文件</strong>：Webpack从入口文件开始，通过解析入口文件中的依赖关系来构建应用程序的依赖图。Webpack支持多种模块类型，包括CommonJS、ES6模块、AMD等。</li>
<li><strong>加载模块</strong>：Webpack使用加载器（Loader）来处理不同类型的模块。加载器可以将模块转换为Webpack可识别的模块格式，并且可以在加载模块时执行一些额外的操作，如代码转换、压缩等。</li>
<li><strong>生成代码块</strong>：Webpack将所有模块打包成一个或多个代码块（Chunk）。代码块是一组相关的模块，它们被组合在一起以便于加载和执行。Webpack使用代码分割（Code Splitting）技术来将代码块拆分成更小的块，以便于并行加载和执行。</li>
<li><strong>代码块转换为资源文件</strong>：Webpack将代码块转换为静态资源文件，如JavaScript文件、CSS文件、图片等。Webpack使用插件（Plugin）来处理资源文件，如压缩、优化等。</li>
<li><strong>输出打包文件</strong>：最后，Webpack将所有资源文件打包成一个或多个输出文件。输出文件可以是单个JavaScript文件、多个JavaScript文件、CSS文件、图片等。Webpack使用输出配置（Output Configuration）来指定输出文件的名称、路径等。</li>
</ol>
<h4 id="如何配置-Webpack-的输出选项？"><a href="#如何配置-Webpack-的输出选项？" class="headerlink" title="如何配置 Webpack 的输出选项？"></a>如何配置 Webpack 的输出选项？</h4><p>在 <code>webpack.config.js</code> 中可以这样配置输出选项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;  </span><br><span class="line">    <span class="attr">output</span>: &#123;  </span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,  </span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),  </span><br><span class="line">    &#125;,  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>



<h4 id="什么是-Loader，举几个常见的例子？"><a href="#什么是-Loader，举几个常见的例子？" class="headerlink" title="什么是 Loader，举几个常见的例子？"></a>什么是 Loader，举几个常见的例子？</h4><p>Loader 是用于将不同类型的文件转换为模块的工具。常见的 Loader 包括：</p>
<ul>
<li><code>babel-loader</code>：将 ES6&#x2F;ES7 等语法转换为 ES5。</li>
<li><code>css-loader</code>：使 Webpack 能够理解 <code>@import</code> 和 <code>url()</code>。</li>
<li><code>style-loader</code>：将 CSS 插入 <code>&lt;script&gt;</code> 标签中。</li>
<li><code>file-loader</code>：处理文件和图像，返回 URL。</li>
</ul>
<h4 id="什么是插件，如何使用它？"><a href="#什么是插件，如何使用它？" class="headerlink" title="什么是插件，如何使用它？"></a>什么是插件，如何使用它？</h4><p>插件是用于扩展 Webpack 功能的插件。可以用来进行文件优化、代码压缩等。使用方式通常是在 <code>webpack.config.js</code> 中的 <code>plugins</code> 数组中引入。例如，使用 <code>HtmlWebpackPlugin</code> 插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);  </span><br><span class="line"></span><br><span class="line">module.exports = &#123;  </span><br><span class="line">    plugins: [  </span><br><span class="line">        new HtmlWebpackPlugin(&#123;  </span><br><span class="line">            template: &#x27;src/index.html&#x27;,  </span><br><span class="line">        &#125;),  </span><br><span class="line">    ],  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>



<h4 id="Webpack-中的热模块替换（Hot-Module-Replacement-HMR）是什么？"><a href="#Webpack-中的热模块替换（Hot-Module-Replacement-HMR）是什么？" class="headerlink" title="Webpack 中的热模块替换（Hot Module Replacement, HMR）是什么？"></a>Webpack 中的热模块替换（Hot Module Replacement, HMR）是什么？</h4><p>HMR 是一种在运行时更新已被修改的模块，而不需要完全刷新页面的技术。这样可以大大提高开发效率。启用 HMR 通常需要配置 devServer，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;  </span><br><span class="line">    hot: true,  </span><br><span class="line">&#125;,  </span><br></pre></td></tr></table></figure>



<h4 id="如何实现代码分割？"><a href="#如何实现代码分割？" class="headerlink" title="如何实现代码分割？"></a>如何实现代码分割？</h4><p>代码分割可以通过使用动态导入（<code>import()</code>）来实现，Webpack 会自动将模块拆分成多个文件。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import(/* webpackChunkName: &quot;my-chunk-name&quot; */ &#x27;./my-module&#x27;)  </span><br><span class="line">    .then(module =&gt; &#123;  </span><br><span class="line">        // 使用模块  </span><br><span class="line">    &#125;);  </span><br></pre></td></tr></table></figure>



<h4 id="解释一下-Webpack-的四个生命周期钩子。"><a href="#解释一下-Webpack-的四个生命周期钩子。" class="headerlink" title="解释一下 Webpack 的四个生命周期钩子。"></a>解释一下 Webpack 的四个生命周期钩子。</h4><ul>
<li>**<code>initialize</code>**：Webpack 初始化的阶段。</li>
<li>**<code>emit</code>**：在生成资源文件之前，Webpack 可以修改生成的文件。</li>
<li>**<code>compile</code>**：在构建过程中，模块准备被打包。</li>
<li>**<code>done</code>**：所有编译完成后的阶段，进行最终的回调操作。</li>
</ul>
<h4 id="如何在生产环境和开发环境中配置-Webpack？"><a href="#如何在生产环境和开发环境中配置-Webpack？" class="headerlink" title="如何在生产环境和开发环境中配置 Webpack？"></a>如何在生产环境和开发环境中配置 Webpack？</h4><p>通常可以创建两个配置文件 <code>webpack.dev.js</code> 和 <code>webpack.prod.js</code>，在开发阶段可以启用热模块替换和源代码映射，而生产阶段则可以启用压缩和优化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js  </span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;  </span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,  </span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span>,  </span><br><span class="line">    <span class="comment">// 其他开发环境配置  </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.prod.js  </span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;  </span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,  </span><br><span class="line">    <span class="attr">optimization</span>: &#123;  </span><br><span class="line">        <span class="attr">minimize</span>: <span class="literal">true</span>,  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="comment">// 其他生产环境配置  </span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>



<h4 id="模块化-Commonjs，AMD，CMD，UMD，ES6-Module分别有什么区别"><a href="#模块化-Commonjs，AMD，CMD，UMD，ES6-Module分别有什么区别" class="headerlink" title="模块化 Commonjs，AMD，CMD，UMD，ES6 Module分别有什么区别"></a>模块化 Commonjs，AMD，CMD，UMD，ES6 Module分别有什么区别</h4><p><strong>CommonJS</strong></p>
<p>CommonJS 是一种模块化规范，主要用于服务器端的 JavaScript( Node环境)。它的特点是：</p>
<ul>
<li>使用 <code>require()</code> 方法加载模块。</li>
<li>使用 <code>module.exports</code> 导出模块。</li>
<li>同步加载模块，即在代码执行时立即加载模块。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入模块  </span></span><br><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块  </span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;  </span><br><span class="line">  <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> math.<span class="title function_">add</span>(a, b);  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="attr">subtract</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> math.<span class="title function_">subtract</span>(a, b);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p><strong>AMD</strong></p>
<p>AMD（Asynchronous Module Definition）是一种异步加载模块的规范，主要用于浏览器端的 JavaScript。它的特点是：</p>
<ul>
<li>使用 <code>define()</code> 方法定义模块。</li>
<li>使用 <code>require()</code> 方法异步加载模块。</li>
<li>支持在浏览器端异步加载模块，避免了阻塞页面加载的问题。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块  </span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;math&#x27;</span>], <span class="keyword">function</span>(<span class="params">math</span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> &#123;  </span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> math.<span class="title function_">add</span>(a, b);  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="attr">subtract</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> math.<span class="title function_">subtract</span>(a, b);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步加载模块  </span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;calculator&#x27;</span>], <span class="keyword">function</span>(<span class="params">calculator</span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(calculator.<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>));  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<p><strong>CMD</strong></p>
<p>CMD（Common Module Definition）是一种类似于 AMD 的模块化规范，主要用于浏览器端的 JavaScript。它的特点是：</p>
<ul>
<li>使用 <code>define()</code> 方法定义模块。</li>
<li>使用 <code>require()</code> 方法异步加载模块。</li>
<li>支持在浏览器端异步加载模块，避免了阻塞页面加载的问题。</li>
<li>与 AMD 不同的是，CMD 是在需要使用模块时才加载模块，而不是在页面加载时就加载所有模块。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块  </span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;  </span><br><span class="line">  <span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>);  </span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> math.<span class="title function_">add</span>(a, b);  </span><br><span class="line">  &#125;;  </span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">subtract</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> math.<span class="title function_">subtract</span>(a, b);  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步加载模块  </span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;calculator&#x27;</span>], <span class="keyword">function</span>(<span class="params">calculator</span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(calculator.<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>));  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<p><strong>UMD</strong></p>
<p>UMD（Universal Module Definition）是一种通用的模块化规范，可以同时支持 CommonJS、AMD 和全局变量的方式。它的特点是：</p>
<ul>
<li>先判断是否支持 CommonJS，如果支持则使用 CommonJS 规范加载模块。</li>
<li>如果不支持 CommonJS，则判断是否支持 AMD，如果支持则使用 AMD 规范加载模块。</li>
<li>如果既不支持 CommonJS 也不支持 AMD，则将模块作为全局变量加载。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">root, factory</span>) &#123;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;  </span><br><span class="line">    <span class="comment">// AMD  </span></span><br><span class="line">    <span class="title function_">define</span>([<span class="string">&#x27;math&#x27;</span>], factory);  </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;  </span><br><span class="line">    <span class="comment">// CommonJS  </span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>));  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// 全局变量  </span></span><br><span class="line">    root.<span class="property">calculator</span> = <span class="title function_">factory</span>(root.<span class="property">math</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;(<span class="variable language_">this</span>, <span class="keyword">function</span>(<span class="params">math</span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> &#123;  </span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> math.<span class="title function_">add</span>(a, b);  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="attr">subtract</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> math.<span class="title function_">subtract</span>(a, b);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;));  </span><br></pre></td></tr></table></figure>

<p><strong>ES6 Module</strong></p>
<p>ES6 Module 是 ECMAScript 6 标准中新增的模块化规范，主要用于浏览器端和服务器端的 JavaScript。它的特点是：</p>
<ul>
<li>使用 <code>import</code> 和 <code>export</code> 关键字导入和导出模块。</li>
<li>支持静态分析，可以在编译时确定模块的依赖关系。</li>
<li>支持异步加载模块。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入模块  </span></span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块  </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> math.<span class="title function_">add</span>(a, b);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">a, b</span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> math.<span class="title function_">subtract</span>(a, b);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>





<h4 id="webpack能处理什么文件，不能处理什么文件"><a href="#webpack能处理什么文件，不能处理什么文件" class="headerlink" title="webpack能处理什么文件，不能处理什么文件"></a>webpack能处理什么文件，不能处理什么文件</h4><p><strong>Webpack 能处理的文件类型</strong></p>
<ol>
<li><strong>JavaScript 文件</strong>：Webpack 可以处理 ES6、CommonJS、AMD 等模块化标准的 JavaScript 文件，并可以通过 <code>babel-loader</code> 转换 ES6+ 代码。</li>
<li><strong>CSS 文件</strong>：可以通过 <code>css-loader</code> 和 <code>style-loader</code> 处理 CSS 文件，还可以处理 SASS、LESS 等预处理样式。</li>
<li><strong>图像和字体文件</strong>：通过 <code>file-loader</code> 和 <code>url-loader</code>，Webpack 可以处理 JPEG、PNG、SVG 等图像文件，以及 TTF、WOFF、WOFF2 等字体文件。</li>
<li><strong>HTML 文件</strong>：通过 <code>html-webpack-plugin</code> 插件，Webpack 可以处理 HTML 文件，并自动插入生成的 JavaScript 和 CSS 文件。</li>
<li><strong>JSON 文件</strong>：Webpack 能够直接处理和导入 JSON 文件。</li>
<li><strong>其他文件</strong>：可以使用特定的 loader 处理其他类型的文件，如 Markdown、XML、YAML 等。</li>
</ol>
<p><strong>Webpack 不能处理的文件类型</strong></p>
<ol>
<li><strong>其他语言原生代码</strong>：如 C、C++ 等编写的代码，Webpack 并没有内置支持，需要借助额外工具来编译。</li>
<li><strong>特定的非模块化文件</strong>：如某些二进制文件、视频文件等，Webpack 虽然可以通过 loader 处理，但并不适合直接用于打包。</li>
<li><strong>大型项目中的超高复杂度文件</strong>：在某些情况下，大型项目中的文件结构过于复杂可能需要自定义解决方案，Webpack 可能不是最佳选择。</li>
</ol>
<h4 id="webpack-处理性能优化"><a href="#webpack-处理性能优化" class="headerlink" title="webpack 处理性能优化"></a>webpack 处理性能优化</h4><p><strong>代码分割（Code Splitting）</strong></p>
<ul>
<li><strong>动态导入</strong>：使用 <code>import()</code> 动态导入模块，按需加载，减少初始加载体积。</li>
<li><strong>Entry Points</strong>：将应用程序的不同部分分成不同的入口点，以便每个入口点只加载其所需的依赖。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：动态导入  </span></span><br><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;my-button&#x27;</span>);  </span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./module.js&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">module</span> =&gt;</span> &#123;  </span><br><span class="line">        <span class="variable language_">module</span>.<span class="title function_">doSomething</span>();  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<p><strong>Tree Shaking</strong></p>
<ul>
<li><p>Tree Shaking 是一种静态分析技术，旨在减少打包文件的大小。它的核心目标是从最终的捆绑结果中删除未被引用的模块或导出。通过这种方式，开发者可以避免在生产环境中载入多余的代码，从而提高性能和加载速度。</p>
</li>
<li><p><strong>工作原理</strong></p>
<p>Tree Shaking 依赖于 ES6 模块系统（即使用 <code>import</code> 和 <code>export</code> 语法），这是因为这种系统具有静态结构，能够在编译时进行更好的分析。以下是主要原因：</p>
<ul>
<li><strong>静态分析</strong>：由于模块导入和导出在编译时是已知的，Webpack 和其他打包工具能够分析哪些模块被使用，哪些没有。</li>
<li><strong>明确的引用</strong>：与 CommonJS 这样的动态加载方式不同，ES6 语法明确声明了模块的依赖</li>
</ul>
</li>
<li><p><strong>步骤</strong></p>
<ol>
<li><strong>解析代码</strong>：打包工具解析应用程序的代码，构建模块的依赖图。</li>
<li><strong>分析使用情况</strong>：查找哪些模块和导出实际被使用，哪些是未使用的“死代码”。</li>
<li><strong>删除未使用的代码</strong>：在生成最终的捆绑文件之前，去除未被引用的模块和导出</li>
</ol>
</li>
<li><p><strong>副作用</strong></p>
<p>一些代码可能会有副作用，例如修改全局变量、添加事件监听等。为了安全地使用 Tree Shaking，建议在 <code>package.json</code> 文件中明确指定哪些模块是有副作用的，或者通过 <code>sideEffects: false</code> 来声明整个库没有副作用。</p>
</li>
</ul>
<p><strong>减少打包体积</strong></p>
<ul>
<li>**使用 <code>TerserPlugin</code>**：压缩和优化 JS 文件。</li>
<li><strong>移除未使用的依赖</strong>：检查包并移除不必要的依赖。</li>
</ul>
<p><strong>使用 DllPlugin - 分包</strong></p>
<ul>
<li>将不频繁变动的依赖这些库单独打包，后期只需要打包逻辑代码即可，从而提高整体打包速度。</li>
</ul>
<p><strong>图片和资源优化</strong></p>
<ul>
<li>使用 <code>image-webpack-loader</code> 对图片进行压缩和优化，减少其体积，进而提高加载速度。</li>
<li>通过 <code>file-loader</code> 或 <code>url-loader</code> 根据文件大小进行合理的打包和加载。</li>
</ul>
<p><strong>CSS优化</strong></p>
<ul>
<li>使用 <code>MiniCssExtractPlugin</code> 将 CSS 分离到单独的文件中，减少 JS 文件的体积，提高加载速度。</li>
<li>避免在 CSS 中使用过大的背景图，考虑加载替代图像的方式。</li>
</ul>
<p><strong>使用预取和懒加载</strong></p>
<ul>
<li>使用 Webpack 的 <code>Prefetch</code> 功能，让某些较大的资源在空闲时预加载。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 示例：在 Webpack 中启用 Prefetch  </span><br><span class="line">import(/* webpackPrefetch: true */ &#x27;./module.js&#x27;);  </span><br></pre></td></tr></table></figure>

<p><strong>开启长缓存</strong></p>
<ul>
<li>使用 <code>contenthash</code> 指定生成文件的名称，使文件在更新后才能发生变化，从而使 CDN 缓存更高效。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;  </span><br><span class="line">    filename: &#x27;[name].[contenthash].js&#x27;,  </span><br><span class="line">    path: path.resolve(__dirname, &#x27;dist&#x27;),  </span><br><span class="line">&#125;,  </span><br></pre></td></tr></table></figure>

<p><strong>打包分析</strong></p>
<ul>
<li>使用 Webpack Bundle Analyzer 插件，分析打包后的文件，查看模块的体积，找出可以优化的部分。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-bundle-analyzer  </span><br></pre></td></tr></table></figure>

<p><strong>开发模式优化</strong></p>
<ul>
<li>在开发模式中使用 <code>webpack-dev-server</code> 或 <code>webpack-dev-middleware</code> 提高热模块替换的效率，减少不必要的完整打包。</li>
</ul>
<p><strong>使用 HTTP&#x2F;2</strong></p>
<ul>
<li>如果你服务器支持 HTTP&#x2F;2，可以并行加载多个小文件，建议保持较小的入口点。</li>
</ul>
<p><strong>减少请求数量</strong></p>
<ul>
<li>将多个 CSS 或 JS 文件合并为一个，减少初始请求的数量。</li>
</ul>
<p><strong>使用 Service Workers</strong></p>
<ul>
<li>可以将页面预加载和缓存逻辑实现到 Service Worker 中，进一步加快页面加载速度。</li>
</ul>
<h4 id="SPA首屏优化方案-减少白屏时间"><a href="#SPA首屏优化方案-减少白屏时间" class="headerlink" title="SPA首屏优化方案 - 减少白屏时间"></a>SPA首屏优化方案 - 减少白屏时间</h4><ol>
<li><p><strong>资源优化</strong></p>
<ul>
<li><strong>静态资源优化压缩减少体积</strong>：对于首屏需要的静态资源（如CSS、JavaScript、图片等），可以进行优化，如压缩、合并、缓存等。使用压缩工具可以减小文件大小，合并多个文件可以减少请求数量，使用缓存可以减少网络请求。</li>
<li><strong>使用CDN</strong>：将静态资源部署到CDN上，提高资源访问效率</li>
</ul>
</li>
<li><p><strong>减少一次性请求的文件大小</strong></p>
<ul>
<li><strong>代码分割 - 按需加载&#x2F; 异步加载</strong>：使用Webpack等构建工具的代码分割功能，将应用程序的代码拆分成多个小块（chunks）。这样可以实现按需加载或异步加载，只加载当前页面所需的代码，减少首屏加载的大小和时间。</li>
<li><strong>预加载和懒加载</strong>：通过预加载和懒加载技术，可以在首屏加载完成后，异步加载其他页面所需的代码和资源。预加载可以在后台加载页面所需的资源，以提前准备好下一个页面的加载。懒加载可以延迟加载某些组件或模块，只在需要时才进行加载。</li>
</ul>
</li>
<li><p><strong>服务端渲染（SSR）</strong>：将部分页面在服务器端进行渲染，生成静态HTML返回给客户端。这样可以加快首屏加载速度，因为客户端只需要展示已经渲染好的HTML，而不需要等待JavaScript代码的下载和执行。</p>
</li>
<li><p><strong>优化网络请求</strong>：</p>
<ul>
<li><strong>减少请求数量</strong>：<ul>
<li>合并css和js文件，减少http请求，雪碧图&#x2F;精灵图</li>
<li>使用http&#x2F;2 ，多路复用请求</li>
</ul>
</li>
<li><strong>缓存</strong>：<ul>
<li>配置浏览器缓存策略：减少重复加载</li>
<li>使用service worker进行资源缓存</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>骨架屏</strong></p>
<ul>
<li>在页面加载时显示骨架屏，提升用户感知性能</li>
</ul>
</li>
<li><p><strong>优化渲染</strong></p>
<ul>
<li><strong>提前渲染</strong><ul>
<li>提前渲染关键性能：确保关键内容在html中靠前位置，优先渲染</li>
</ul>
</li>
<li><strong>渲染优化</strong><ul>
<li>避免大型DOM操作，优化渲染性能</li>
<li>使用虚拟滚动技术，优化长列表渲染</li>
</ul>
</li>
<li><strong>使用现代构建工具和技术</strong><ul>
<li>构建工具配置</li>
<li>Tree Sharking技术</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="webpack和vite区别"><a href="#webpack和vite区别" class="headerlink" title="webpack和vite区别"></a>webpack和vite区别</h4><ul>
<li>vite是基于ESM，浏览器原生支持；webpack是基于Commonjs，需要编译</li>
<li>viite开发环境基于esbuild，也就是基于go语言( 适合CUP密集型计算，适用多线程)；webpack基于node，node特点有单线程</li>
</ul>
<h3 id="html-css"><a href="#html-css" class="headerlink" title="html+css"></a>html+css</h3><h4 id="如何理解html，css，js"><a href="#如何理解html，css，js" class="headerlink" title="如何理解html，css，js"></a>如何理解html，css，js</h4><ol>
<li><strong>HTML</strong>：HTML（HyperText Markup Language）是一种用于创建Web页面结构的标记语言。</li>
<li><strong>CSS</strong>：CSS（Cascading Style Sheets）是一种用于控制Web页面样式的语言</li>
<li><strong>JavaScript</strong>：JavaScript是一种用于实现Web页面交互的脚本语言</li>
</ol>
<h4 id="html代码第一行有什么作用"><a href="#html代码第一行有什么作用" class="headerlink" title="html代码第一行有什么作用"></a>html代码第一行有什么作用</h4><p>告诉浏览器采用哪种HTML版本解释页面内容。不同的HTML版本有不同的规范和特性，因此通过<code>&lt;!DOCTYPE&gt;</code>声明可以确保浏览器正确地呈现页面。</p>
<h4 id="html的meta属性有哪些，都是什么作用"><a href="#html的meta属性有哪些，都是什么作用" class="headerlink" title="html的meta属性有哪些，都是什么作用"></a>html的meta属性有哪些，都是什么作用</h4><p><code>meta</code>元素是HTML中用来提供关于文档的元数据（metadata）的标签。以下是一些常见的<code>meta</code>属性及其作用：</p>
<ol>
<li><code>charset</code>: 指定文档使用的字符编码，例如UTF-8。</li>
<li><code>name=&quot;viewport&quot;</code>: 用于控制页面在移动设备上的显示，包括宽度、缩放等。</li>
<li><code>name=&quot;description&quot;</code>: 提供对文档内容的简短描述，通常被搜索引擎用于搜索结果中显示。</li>
<li><code>name=&quot;keywords&quot;</code>: 指定与文档相关的关键词，有助于搜索引擎索引。</li>
<li><code>name=&quot;author&quot;</code>: 用于指定文档的作者。</li>
<li><code>http-equiv=&quot;refresh&quot;</code>: 自动刷新页面或定时跳转到其他页面。</li>
</ol>
<p>这些是<code>meta</code>元素中常见的属性，它们可以帮助优化网页内容、提高SEO</p>
<h4 id="隐藏一个元素有哪些方法"><a href="#隐藏一个元素有哪些方法" class="headerlink" title="隐藏一个元素有哪些方法"></a>隐藏一个元素有哪些方法</h4><ol>
<li><p>CSS <code>display</code> 属性:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过给元素添加 hidden 类，可以将其隐藏起来。</span><br><span class="line"><span class="selector-class">.hidden</span> &#123;  </span><br><span class="line">    <span class="attribute">display</span>: none;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>CSS <code>visibility</code> 属性:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过给元素添加 hidden 类，可以使元素不可见但仍占据页面空间。</span><br><span class="line"><span class="selector-class">.hidden</span> &#123;  </span><br><span class="line">    <span class="attribute">visibility</span>: hidden;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>设置元素的 <code>style.display</code> 属性:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过 JavaScript 修改元素的 display 属性来隐藏它。</span><br><span class="line">document.getElementById(&#x27;elementId&#x27;).style.display = &#x27;none&#x27;;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>设置元素的 <code>style.visibility</code> 属性:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过 JavaScript 修改元素的 visibility 属性来隐藏它。</span><br><span class="line">document.getElementById(&#x27;elementId&#x27;).style.visibility = &#x27;hidden&#x27;;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="小程序和h5有什么区别"><a href="#小程序和h5有什么区别" class="headerlink" title="小程序和h5有什么区别"></a>小程序和h5有什么区别</h4><ul>
<li><strong>运行环境</strong> -  小程序是平台内部运行的轻量级应用，可以直接在平台运行；h5 用户需要通过浏览器访问网址来使用</li>
<li><strong>开发语言</strong> - 小程序通常采用特定的框架和语言进行开发，例如微信小程序采用WXML、WXSS和JavaScript；H5 使用现代web前技术</li>
<li><strong>权限</strong> - 小程序能够调用更多的系统API权限。 h5是基于浏览器，在安全方面着想，受限程度多。</li>
<li><strong>分发方式</strong> - 小程序必须依赖该用户平台，而h5 则不用依赖于特定浏览器</li>
</ul>
<h4 id="盒子模型理解介绍"><a href="#盒子模型理解介绍" class="headerlink" title="盒子模型理解介绍"></a>盒子模型理解介绍</h4><p>盒模型（Box Model）是用于构建和布局网页元素的基本概念之一，它描述了每个 HTML 元素在页面上所占空间的方式。在 CSS 中，每个元素都被表示为一个矩形盒子，该盒子包括内容区域、内边距（padding）、边框（border）和外边距（margin）四个部分</p>
<h4 id="css的几种引入方式"><a href="#css的几种引入方式" class="headerlink" title="css的几种引入方式"></a>css的几种引入方式</h4><ol>
<li><p><strong>内联样式（Inline Styles）</strong>:<br>使用内联样式的方式，直接在 HTML 元素的 style 属性中指定样式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;color: red; font-size: 16px;&quot;&gt;这是一段红色字体的文本&lt;/div&gt;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内部样式表（Internal Stylesheet）</strong>:<br>在 HTML 文档的头部（head）标签内使用 <code>&lt;style&gt;</code> 标签定义样式表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;  </span><br><span class="line">    &lt;style&gt;  </span><br><span class="line">        div &#123;  </span><br><span class="line">            color: blue;  </span><br><span class="line">            font-size: 18px;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &lt;/style&gt;  </span><br><span class="line">&lt;/head&gt;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>外部样式表（External Stylesheet）</strong>:<br>将样式表单独保存为一个 .css 文件，并在 HTML 文档中通过 <link> 标签引入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;  </span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;  </span><br><span class="line">&lt;/head&gt;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@import 语句</strong>:<br>在样式表中使用 @import 语句引入其他 CSS 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* styles.css */  </span><br><span class="line">@import url(&quot;reset.css&quot;);  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 @import 引入外部样式表</strong>:<br>在样式表中使用 @import 语句来引入其他外部样式表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* styles.css */  </span><br><span class="line">@import url(&quot;https://fonts.googleapis.com/css?family=Roboto&quot;);  </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="css-布局方式有哪些"><a href="#css-布局方式有哪些" class="headerlink" title="css 布局方式有哪些"></a>css 布局方式有哪些</h4><p>CSS中常见的布局方式有以下几种：</p>
<ol>
<li><strong>流动布局（Flow Layout）</strong>：元素按照在HTML中出现的顺序依次排列，可以通过设置<code>float</code>属性实现左浮动或右浮动。</li>
<li><strong>定位布局（Positioning Layout）</strong>：通过设置<code>position</code>属性为<code>absolute</code>、<code>relative</code>或<code>fixed</code>来控制元素的位置。</li>
<li><strong>弹性盒子布局（Flexbox Layout）</strong>：使用<code>display: flex</code>或<code>display: inline-flex</code>来创建灵活的布局，可以方便地控制元素的排列顺序、对齐方式等。</li>
<li><strong>网格布局（Grid Layout）</strong>：使用CSS网格布局可以将页面划分为行和列，通过定义网格容器和网格项来实现复杂的布局。</li>
<li><strong>多列布局（Multiple Column Layout）</strong>：通过设置<code>column-count</code>、<code>column-width</code>等属性，将文本内容分成多列显示。</li>
</ol>
<h4 id="讲一下弹性盒子布局"><a href="#讲一下弹性盒子布局" class="headerlink" title="讲一下弹性盒子布局"></a>讲一下弹性盒子布局</h4><p>通过将容器设置为<code>display: flex</code>或<code>display: inline-flex</code>，容器内的子元素就会成为弹性项目弹性盒子布局的主要特点包括：</p>
<ul>
<li><strong>主轴和交叉轴</strong>：主轴是弹性项目排列的方向，交叉轴与主轴垂直。开发者可以通过<code>flex-direction</code>属性控制主轴的方向。</li>
<li><strong>弹性项目的灵活性</strong>：弹性项目可以根据需要扩展、收缩，可以通过<code>flex-grow</code>、<code>flex-shrink</code>和<code>flex-basis</code>属性来控制。</li>
<li><strong>对齐方式</strong>：可以通过<code>justify-content</code>和<code>align-items</code>等属性来控制弹性项目在主轴和交叉轴上的对齐方式。</li>
<li><strong>顺序控制</strong>：可以通过<code>order</code>属性调整弹性项目的排列顺序。</li>
</ul>
<h4 id="开头的css属性"><a href="#开头的css属性" class="headerlink" title="@开头的css属性"></a>@开头的css属性</h4><p>以 “@” 开头的部分在 CSS 中通常被称为 “at-rules”（规则），它们用来定义一些CSS规则和特性，而不是用来设置元素的样式</p>
<ol>
<li><p><strong>@media</strong>:<br>用于设定媒体查询，根据设备属性如屏幕尺寸、分辨率等来应用不同的样式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;  </span><br><span class="line">    <span class="selector-tag">body</span> &#123;  </span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">14px</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@font-face</strong>:<br>用于在CSS中嵌入自定义字体，让网页可以使用非标准字体。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;  </span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;CustomFont&quot;</span>;  </span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;customfont.woff&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@keyframes</strong>:<br>用于创建动画序列，定义动画的各个关键帧。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> slidein &#123;  </span><br><span class="line">    <span class="selector-tag">from</span> &#123; <span class="attribute">margin-left</span>: <span class="number">100%</span>; &#125;  </span><br><span class="line">    <span class="selector-tag">to</span> &#123; <span class="attribute">margin-left</span>: <span class="number">0%</span>; &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@import</strong>:<br>用于引入其他的 CSS 文件。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&#x27;otherstyles.css&#x27;</span>);  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@supports</strong>:<br>用于检查浏览器是否支持某些 CSS 属性或值。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@supports</span> (<span class="attribute">display</span>: <span class="attribute">grid</span>) &#123;  </span><br><span class="line">    <span class="comment">/* CSS rules for browsers that support CSS Grid */</span>  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@page</strong>:<br>用于设置打印页面的样式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@page</span> &#123;  </span><br><span class="line">    size: A4;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="CSS长度单位"><a href="#CSS长度单位" class="headerlink" title="CSS长度单位"></a>CSS长度单位</h4><p>在 CSS 中，有多种长度单位用于指定元素的尺寸和位置。</p>
<ol>
<li><p><strong>像素（px）</strong>:<br>像素是相对于显示器上的物理像素（屏幕上的点）的单位。它是最常用的长度单位，通常用于指定固定尺寸。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div &#123;  </span><br><span class="line">    width: 200px;  </span><br><span class="line">    height: 50px;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>百分比（%）</strong>:<br>百分比是相对于父元素的尺寸的单位，可以用于创建响应式布局。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div &#123;  </span><br><span class="line">    width: 50%;  </span><br><span class="line">    padding: 10%;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>em</strong>:<br>em 是相对于元素自身的字体大小的单位。1em 等于元素的字体大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div &#123;  </span><br><span class="line">    font-size: 1.2em;  </span><br><span class="line">    padding: 0.5em;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>rem</strong>:<br>rem 是相对于根元素（html 元素）的字体大小的单位。1rem 等于根元素的字体大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div &#123;  </span><br><span class="line">    font-size: 1.5rem;  </span><br><span class="line">    margin: 2rem;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>vw 和 vh</strong>:<br>vw 和 vh 分别代表视口宽度（Viewport Width）和视口高度（Viewport Height）的百分比。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div &#123;  </span><br><span class="line">    width: 50vw;  </span><br><span class="line">    height: 20vh;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>cm、mm、in、pt、pc</strong>:<br>这些单位分别代表厘米（cm）、毫米（mm）、英寸（inch）、点（point）和派卡（pica），在打印样式表中使用较多。</p>
</li>
</ol>
<h4 id="CSS-中，display-属性"><a href="#CSS-中，display-属性" class="headerlink" title="CSS 中，display 属性"></a>CSS 中，display 属性</h4><p>display 属性用于控制元素的显示方式，一般用来做模型的灵活布局</p>
<ol>
<li><p><strong>block</strong>:<br>将元素显示为块级元素，会独占一行并自动换行，宽度默认为父元素的100%。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;  </span><br><span class="line">    display: block;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>inline</strong>:<br>将元素显示为内联元素，不会独占一行，宽度由内容决定，不会自动换行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">span &#123;  </span><br><span class="line">    display: inline;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>inline-block</strong>:<br>将元素显示为内联块级元素，可以设置宽高，不会独占一行，但会换行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;  </span><br><span class="line">    display: inline-block;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>none</strong>:<br>将元素隐藏，不占用空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;  </span><br><span class="line">    display: none;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>flex</strong>:<br>使用 Flexbox 布局来布局元素，可以实现强大的布局效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;  </span><br><span class="line">    display: flex;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>grid</strong>:<br>使用网格布局来布局元素，提供了更灵活的网格布局效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;  </span><br><span class="line">   display: grid;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="css元素居中的4中写法"><a href="#css元素居中的4中写法" class="headerlink" title="css元素居中的4中写法"></a>css元素居中的4中写法</h4><ol>
<li><p>水平居中：</p>
<ul>
<li>对于块级元素，可以使用 <code>margin: 0 auto;</code> 来实现水平居中。</li>
<li>对于行内元素，可以将父元素设置为 <code>text-align: center;</code> 并且将子元素设为 <code>display: inline-block;</code> 来实现水平居中。</li>
</ul>
</li>
<li><p>垂直居中：</p>
<ul>
<li>使用 Flexbox 布局，可以通过将父容器设置为 <code>display: flex;</code> 并且使用 <code>align-items: center;</code> 来实现垂直居中。</li>
<li>使用 Grid 布局，可以通过将父容器设置为 <code>display: grid; place-items: center;</code> 来实现垂直和水平同时居中。</li>
</ul>
</li>
<li><p>水平和垂直都居中：</p>
<ul>
<li><p>使用绝对定位（position:absolute）和 transform 属性来使元素水平和垂直同时居中。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.centered</span> &#123;  </span><br><span class="line">  <span class="attribute">position</span>: absolute;  </span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;  </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;  </span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>表格布局方式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;  </span><br><span class="line">  <span class="attribute">display</span>: table;  </span><br><span class="line">  <span class="attribute">width</span> :<span class="number">100%</span>; <span class="comment">/*宽度设置*/</span>  </span><br><span class="line">  <span class="attribute">height</span> :<span class="number">100vh</span>;<span class="comment">/*高度设置*/</span>  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="selector-class">.centered</span> &#123;  </span><br><span class="line">  <span class="attribute">display</span> :table-cell;  </span><br><span class="line">  <span class="attribute">vertical-align</span> :middle;  </span><br><span class="line">  <span class="attribute">text-align</span>:center;<span class="comment">/*文本信息左右对齐的属性*/</span>  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="css绘制三角形"><a href="#css绘制三角形" class="headerlink" title="css绘制三角形"></a>css绘制三角形</h4><ol>
<li><p><strong>使用 border：</strong></p>
<p>设置一个矩形元素的边框，利用透明的边框来隐藏一部分，从而形成三角形的效果。具体步骤如下：</p>
<ul>
<li>创建一个具有宽度和高度为0的块元素。</li>
<li>设置三个边框的样式，其中两个边框为透明，一个边框为所需颜色。</li>
<li>最后设置一个矩形元素的宽度和高度为0，并确保三个边框的宽度满足绘制三角形的需求。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;  </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;  </span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;  </span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;  </span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 transform：</strong></p>
<p>绘制一个矩形元素，然后通过旋转这个矩形元素45度将下面的隐藏来形成一个等边三角形。</p>
<ul>
<li>创建一个矩形元素。</li>
<li>设置三边的宽度和颜色来绘制一个等边三角形。</li>
<li>使用 CSS 的 <code>transform: rotate(45deg);</code> 将矩形元素旋转45度，从而形成三角形。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;  </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;  </span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;  </span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;  </span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;  </span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 clip-path：</strong></p>
<p>使用 CSS 的 <code>clip-path</code> 属性来定义一个多边形剪切路径，从而将矩形元素剪切成一个三角形</p>
<ul>
<li>创建一个矩形元素。</li>
<li>使用 <code>clip-path: polygon()</code> 函数来定义一个三角形的多边形路径，路径的顶点坐标按照需要的形状来设置。</li>
<li>这样设置后，矩形元素就会被剪切成一个三角形的形状。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;  </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;  </span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">50%</span> <span class="number">0%</span>, <span class="number">0%</span> <span class="number">100%</span>, <span class="number">100%</span> <span class="number">100%</span>);  </span><br><span class="line">    <span class="attribute">background-color</span>: red;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="使用css设置0-5px的线条"><a href="#使用css设置0-5px的线条" class="headerlink" title="使用css设置0.5px的线条"></a>使用css设置0.5px的线条</h4><p>在 CSS 中无法直接设置 0.5px 的线条宽度。可以使用缩放的方式</p>
<p>有两种方法可以尝试：</p>
<ol>
<li><p><strong>使用边框半透明</strong>：<br>设置一个像素单位的边框，并给它设置为半透明，可以模拟出一个看起来像是 0.5px 的线条。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.halfpx-line</span> &#123;  </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;  </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>); <span class="comment">/* 半透明黑色 */</span>  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 transform 缩放</strong>：<br>可以利用 CSS 的 <code>transform</code> 属性中的 <code>scale()</code> 函数，将一个细线条元素进行缩放来实现看似 0.5px 的效果。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.halfpx-line</span> &#123;  </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;  </span><br><span class="line">    <span class="attribute">background-color</span>: black;  </span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>css用 <code>transform</code> 的 <code>scaleY(0.5)</code> 来将元素在垂直方向上缩放为原来的一半，从而实现看似是 0.5px 宽度的线条。</p>
</li>
</ol>
<h4 id="CSS3实现动画效果的属性"><a href="#CSS3实现动画效果的属性" class="headerlink" title="CSS3实现动画效果的属性"></a>CSS3实现动画效果的属性</h4><ol>
<li><p><strong>transition</strong>：<br><code>transition</code> 属性可以指定元素在状态变化时的过渡效果。通过指定过渡属性、持续时间、延迟时间和过渡函数来实现平滑的状态变化效果。<br>可以用于对元素进行变换（如平移、旋转、缩放、倾斜等）。在 <code>transform</code> 属性中可以使用 <code>translate()</code> 和 <code>rotate()</code> 函数来分别实现平移和旋转效果</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;  </span><br><span class="line">    <span class="attribute">transition</span>: width <span class="number">0.5s</span> ease-in-out;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>animation</strong>：<br><code>animation</code> 属性允许在指定的时间内通过在关键帧之间来循环显示动画。使用 <code>@keyframes</code> 规则定义动画的关键帧。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> slidein &#123;  </span><br><span class="line">    <span class="selector-tag">from</span> &#123; <span class="attribute">margin-left</span>: <span class="number">100%</span>; &#125;  </span><br><span class="line">    <span class="selector-tag">to</span> &#123; <span class="attribute">margin-left</span>: <span class="number">0%</span>; &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;  </span><br><span class="line">    <span class="attribute">animation</span>: slidein <span class="number">2s</span> infinite;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>keyframes</strong>：<br><code>@keyframes</code> 规则用于创建动画序列，定义不同关键帧下的元素样式。</p>
</li>
<li><p><strong>transition-property</strong>：<br>用于指定过渡效果的 CSS 属性名称，仅这些属性发生变化时才会应用过渡效果。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;  </span><br><span class="line">    <span class="attribute">transition-property</span>: background-color, transform;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>animation-timing-function</strong>：<br>用于指定动画过渡函数，控制动画变化速度。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;  </span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-in-out;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>animation-duration</strong>：<br>用于指定动画执行的持续时间。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;  </span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">2s</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="css清除浮动"><a href="#css清除浮动" class="headerlink" title="css清除浮动"></a>css清除浮动</h4><p>清除浮动（clearfix）是用来解决由浮动元素引起的父元素高度塌陷的常见问题。</p>
<ol>
<li><p><strong>使用 clear 属性</strong>：<br>在浮动元素的下方添加一个空的 div 元素，并为该 div 添加样式 <code>clear: both;</code>，这样可以清除浮动效果。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;  </span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;  </span><br><span class="line">    <span class="attribute">display</span>: block;  </span><br><span class="line">    <span class="attribute">clear</span>: both;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们给添加了 <code>.clearfix</code> 类的元素的伪元素 <code>::after</code> 中设置了 <code>clear: both;</code>，这样便清除了浮动。</p>
</li>
<li><p><strong>使用overflow 属性</strong>：<br>通过为包含浮动元素的父元素添加 <code>overflow: hidden;</code> 或 <code>overflow: auto;</code> 属性来清除浮动效果。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;  </span><br><span class="line">    <span class="attribute">overflow</span>: hidden;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们给包含浮动元素的父元素添加了 <code>overflow: hidden;</code> 属性，这样也可以清除浮动。</p>
</li>
<li><p><strong>使用伪元素</strong>：<br>通过设置父元素的 <code>overflow: hidden;</code> 属性，并同时为其添加一个清除浮动的伪元素。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;  </span><br><span class="line">    <span class="attribute">overflow</span>: hidden;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span> &#123;  </span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;  </span><br><span class="line">    <span class="attribute">display</span>: table;  </span><br><span class="line">    <span class="attribute">clear</span>: both;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们在包含浮动元素的父元素中使用了伪元素 <code>::after</code> 来清除浮动，并设置了 <code>clear: both;</code>。</p>
</li>
</ol>
<h4 id="margin-坍塌"><a href="#margin-坍塌" class="headerlink" title="margin 坍塌"></a>margin 坍塌</h4><p>当两个相邻的元素之间的上（或下）外边距发生重叠时，就会发生边距坍塌（margin collapsing）的现象。坍塌后的边距取两者中的最大值，而不是简单相加起来</p>
<ol>
<li><strong>父子元素之间的边距坍塌</strong>：<br>如果父元素和子元素之间的边距发生坍塌，可以通过给父元素添加 <code>padding</code> 或 <code>border</code> 来阻止边距坍塌。</li>
<li><strong>兄弟元素之间的边距坍塌</strong>：<br>当相邻的兄弟元素中的上（或下）外边距相遇时也会发生边距坍塌。可以通过其中一个元素设置 <code>padding</code> 或 <code>border</code> 来阻止边距坍塌。</li>
<li><strong>空元素的边距坍塌</strong>：<br>如果两个相邻的空元素之间有边距，也可能发生坍塌。可以通过设置其中一个元素的高度或添加内容来避免边距坍塌。</li>
<li><strong>使用 <code>display: inline-block</code> 时的边距坍塌</strong>：<br>使用 <code>inline-block</code> 的元素也可能出现边距坍塌，可以通过在元素之间插入空白字符或者设置 <code>font-size: 0;</code> 来解决。</li>
</ol>
<h4 id="BFC实现方法"><a href="#BFC实现方法" class="headerlink" title="BFC实现方法"></a>BFC实现方法</h4><p>BFC（块级格式化上下文）是 CSS 中的一个重要概念，它可以影响元素的布局和渲染。BFC 的主要作用是创建一个独立的渲染环境，使得元素的布局不受外部影响，从而避免一些常见的布局问题。</p>
<p>解决的问题：</p>
<ol>
<li><strong>清除浮动</strong>：当一个元素设置了浮动后，其父元素的高度将会塌陷，导致布局错乱。使用 BFC 可以触发父元素形成一个独立的渲染环境，使得其高度可以正确地被计算并包裹浮动元素。</li>
<li><strong>避免外边距重叠</strong>：在普通流中相邻块级盒子的上外边距和下外边距有时会发生重叠。将这些盒子放入不同的 BFC 中可以避免外边距重叠。</li>
<li><strong>自适应两栏布局</strong>：当需要实现两栏等高自适应布局时，可以利用 BFC 来清除浮动，并保证两栏等高。</li>
<li><strong>垂直居中问题</strong>：利用 BFC 可以实现一些垂直居中效果，例如通过设置父元素为 BFC 并采用 flex 布局实现垂直居中。</li>
<li><strong>阻止文字环绕</strong>：使用 BFC 可以防止文字环绕非浮动块级盒子。</li>
<li><strong>margin 重叠</strong>: 在普通流中，相邻的两个块级盒子的上下外边距会发生重叠，导致外边距的计算结果不符合预期</li>
</ol>
<p>BFC 的实现方法有以下几种：</p>
<ol>
<li><strong>float 属性</strong>：当元素设置了 float 属性时，会创建一个 BFC。这是因为 float 元素会脱离文档流，形成一个独立的渲染环境。</li>
<li><strong>position 属性</strong>：当元素设置了 position 属性为 absolute 或 fixed 时，会创建一个 BFC。这是因为绝对定位和固定定位的元素会脱离文档流，形成一个独立的渲染环境。</li>
<li><strong>display 属性</strong>：当元素设置了 display 属性为 inline-block、table-cell、table-caption、flex、inline-flex 或 grid 时，会创建一个 BFC。这是因为这些属性会使元素形成一个独立的渲染环境。</li>
<li><strong>overflow 属性</strong>：当元素设置了 overflow 属性为 auto、scroll 或 hidden 时，会创建一个 BFC。这是因为 overflow 属性可以控制元素的溢出内容，从而形成一个独立的渲染环境。</li>
</ol>
<h4 id="对IFC的理解"><a href="#对IFC的理解" class="headerlink" title="对IFC的理解"></a>对IFC的理解</h4><p>IFC 是 CSS 中的一种布局模式，IFC 是指内联格式化上下文，它是一种用于排列内联元素的 CSS 布局模式</p>
<p>IFC 的特点包括：</p>
<ul>
<li>内联元素会在水平方向上依次排列，直到排满一行，然后自动换行到下一行。</li>
<li>IFC 中的元素会在垂直方向上对齐，例如顶部对齐、底部对齐等。</li>
<li>IFC 中的元素会在水平方向上对齐，例如左对齐、右对齐等。</li>
<li>IFC 中的元素会根据自身的大小和内容自动调整位置和大小，以适应容器的大小和其他元素的位置。</li>
</ul>
<p><strong>flex</strong></p>
<ol>
<li><strong>容器属性</strong>：<ul>
<li><code>display</code>：设置容器为 flex 布局。</li>
<li><code>flex-direction</code>：设置主轴的方向（row、row-reverse、column、column-reverse）。</li>
<li><code>flex-wrap</code>：设置是否换行（nowrap、wrap、wrap-reverse）。</li>
<li><code>justify-content</code>：设置主轴上的对齐方式（flex-start、flex-end、center、space-between、space-around）。</li>
<li><code>align-items</code>：设置交叉轴上的对齐方式（flex-start、flex-end、center、baseline、stretch）。</li>
<li><code>align-content</code>：设置多根轴线的对齐方式（flex-start、flex-end、center、space-between、space-around、stretch）。</li>
</ul>
</li>
<li><strong>项目属性</strong>：<ul>
<li><code>order</code>：设置项目的排列顺序。</li>
<li><code>flex-grow</code>：设置项目的放大比例。</li>
<li><code>flex-shrink</code>：设置项目的缩小比例。</li>
<li><code>flex-basis</code>：设置项目的基准大小。</li>
<li><code>flex</code>：设置项目的放大比例、缩小比例和基准大小。</li>
<li><code>align-self</code>：设置单个项目在交叉轴上的对齐方式。</li>
</ul>
</li>
</ol>
<h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>媒体查询是一种用于网页设计的技术，它允许根据设备的特性（如屏幕大小、分辨率、设备方向等）来应用不同的样式表</p>
<h4 id="css回流，重绘，合并图层，GPU-加速"><a href="#css回流，重绘，合并图层，GPU-加速" class="headerlink" title="css回流，重绘，合并图层，GPU 加速"></a>css回流，重绘，合并图层，GPU 加速</h4><p>减少回流和重绘：</p>
<ol>
<li>使用 transform 属性来移动元素，而不是使用 top 或 left。</li>
<li>使用 requestAnimationFrame 来执行动画，这样可以将所有的 DOM 更新合并成一个，并在下一帧统一处理。</li>
<li>避免频繁修改样式属性，最好通过修改 CSS 类名的方式来批量改变元素样式。</li>
</ol>
<p>合并图层：</p>
<ol>
<li>避免创建大量复杂的 z-index 嵌套结构，这可能会导致浏览器创建大量图层。</li>
<li>将页面中不经常变化的部分放在单独的图层中，比如使用 will-change 属性或 translate3d 来提前启用 GPU 加速。</li>
</ol>
<p>GPU 加速：</p>
<ol>
<li>将需要使用 GPU 加速渲染的元素设为 3D 变换。例如：transform: translateZ(0) 或者 perspective: 1000px。</li>
<li>尽量避免过多地同时开启硬件加速，因为它也会消耗额外内存。</li>
</ol>
<h4 id="关于适配问题"><a href="#关于适配问题" class="headerlink" title="关于适配问题"></a>关于适配问题</h4><ol>
<li><p>普通移动端(H5)</p>
<p>盒子可以采用rem单位( rem是针对html根元素的fontSize)，可以通过动态获取屏幕可视宽度，来设置html的fontSize属性。从而达到适配</p>
</li>
<li><p>uniapp 小程序 做适配</p>
<p>使用 rpx单位，一般开发时，若设计图宽度一般为750px。例如测量一个元素宽度为300px。代码中直接写300rpx即可。</p>
<p>早期uniapp是推荐使用upx，目前改成了 rpx。rpx是根据屏幕宽度自适应的动态单位，基准单位为750rpx。会进行px换算: 1rpx &#x3D; 750*(设计稿元素宽度px &#x2F; 设计稿基准宽度px)</p>
<p>例如： 设计稿为640px，元素宽度为100px，则换算后为 117 rpx</p>
<p>750*(100px&#x2F;640px) &#x3D; 117rpx</p>
</li>
<li><p>扩展 - px、em、rem、%、vh、vw</p>
<ul>
<li>px  绝对单位，精确像素展示</li>
<li>em   相对单位，相对于父节点字体进行计算</li>
<li>rem   相对单位，相对根节点html的字体大小来计算</li>
<li>%   百分比，根据父节点的大小进行百分比计算</li>
<li>vh   百分比，根据可视高度进行百分比计算，1vh &#x3D; 可视高度1%</li>
<li>vw   百分比，根据可视宽度进行百分比计算，1vh &#x3D; 可视宽度1%</li>
</ul>
</li>
</ol>
<h4 id="骨架屏原理"><a href="#骨架屏原理" class="headerlink" title="骨架屏原理"></a>骨架屏原理</h4><ol>
<li>设计骨架屏：首先需要设计好网页的基本结构，并确定哪些元素会在页面加载时展示为骨架屏。这可能包括导航栏、列表、卡片等重要的页面结构元素。</li>
<li>创建骨架屏样式：利用CSS来定义骨架屏的样式，通常是使用灰色或者其他淡色调来绘制基本结构。你可以使用占位符元素、伪类选择器或者内联样式来实现这些效果。</li>
<li>控制显示与隐藏：借助JavaScript或者其他前端框架，在页面加载时将对应的骨架屏样式应用到页面上，并在实际内容加载完成后切换回真实内容。这可以通过动态添加&#x2F;移除CSS类名、使用条件渲染（例如Vue.js中的v-if指令）等方式来实现。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css">  </span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 配置骨架屏样式 */</span>  </span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.skeleton</span> &#123;  </span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#f2f2f2</span>;  </span></span><br><span class="line"><span class="language-css">      <span class="attribute">border-radius</span>: <span class="number">4px</span>;  </span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;  </span></span><br><span class="line"><span class="language-css">    &#125;  </span></span><br><span class="line"><span class="language-css">    </span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 实际内容容器 */</span>  </span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.content</span> &#123;  </span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: none; <span class="comment">/* 默认隐藏 */</span>  </span></span><br><span class="line"><span class="language-css">    &#125;  </span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!-- 需要展示成为骨架屏的部分 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;skeleton&quot;</span> <span class="attr">id</span>=<span class="string">&quot;skeleton1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 实际内容 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span> <span class="attr">id</span>=<span class="string">&quot;realContent&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 这里放置真正的网页内容 --&gt;</span>  </span><br><span class="line">    ...  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 模拟数据加载延迟  </span></span></span><br><span class="line"><span class="language-javascript"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// 数据加载完成后显示真正内容  </span></span></span><br><span class="line"><span class="language-javascript">   <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;realContent&#x27;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>;  </span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// 移除对应位置上原有的 skeleton 元素  </span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;skeleton1&#x27;</span>);  </span></span><br><span class="line"><span class="language-javascript">   element.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(element);  </span></span><br><span class="line"><span class="language-javascript">&#125;, <span class="number">3000</span>); <span class="comment">// 模拟3秒钟后数据加载完毕  </span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="鼠标穿透属性"><a href="#鼠标穿透属性" class="headerlink" title="鼠标穿透属性"></a>鼠标穿透属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.popup</span>&#123;</span><br><span class="line">    // 可以将被该层的元素遮挡的鼠标事件穿透过去，不被遮挡</span><br><span class="line">    <span class="attribute">pointer-events</span>: none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;loader&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.loader</span> &#123;  </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;  </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;  </span><br><span class="line">  <span class="attribute">border</span>: <span class="number">8px</span> solid <span class="number">#f3f3f3</span>;  </span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">8px</span> solid <span class="number">#3498db</span>;  </span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;  </span><br><span class="line">  <span class="attribute">animation</span>: spin <span class="number">1s</span> infinite linear;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> spin &#123;  </span><br><span class="line">  <span class="number">0%</span> &#123;  </span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="number">100%</span> &#123;  </span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个案例中，一个名为 <code>.loader</code> 的 <code>&lt;div&gt;</code> 元素被创建用作加载动画的容器。通过设置元素的边框样式，以及使用 <code>border-top</code> 属性指定一个特定的颜色，在视觉上形成一个带有旋转效果的圆形。关键帧动画 <code>spin</code> 定义了从运动开始到结束的过渡效果。</p>
<p>在 CSS 中，通过 <code>@keyframes</code> 规则定义了动画的关键帧。在这个案例中，<code>spin</code> 动画从初始状态（0%）开始，没有旋转（0deg），到最终状态（100%），完整旋转一圈（360deg）。<code>animation</code> 属性将该动画应用于 <code>.loader</code> 元素，并设置动画的持续时间为 1 秒，并且设置为无限循环播放。</p>
<p>其他属性：</p>
<ol>
<li><strong>translate()：</strong> 平移元素，根据给定的距离在水平和垂直方向上移动元素。例如，<code>translate(50px, 100px)</code> 会将元素向右移动 50px，向下移动 100px。</li>
<li><strong>rotate()：</strong> 旋转元素，在给定的角度下沿顺时针方向旋转元素。角度单位可以是度数（deg）或弧度（rad）。例如，<code>rotate(45deg)</code> 会将元素顺时针旋转 45 度。</li>
<li><strong>scale()：</strong> 缩放元素，根据给定的比例在水平和垂直方向上放大或缩小元素。例如，<code>scale(2, 1.5)</code> 会将元素在水平方向上放大 2 倍，在垂直方向上放大 1.5 倍。</li>
<li><strong>skew()：</strong> 倾斜元素，通过给定的角度值将元素沿着 X 和 Y 轴进行倾斜。角度单位可以是度数（deg）或弧度（rad）。例如，<code>skew(30deg, -10deg)</code> 会将元素在 X 轴方向上逆时针倾斜 30 度，在 Y 轴方向上顺时针倾斜 10 度。</li>
<li><strong>matrix()：</strong> 使用 2D 变换矩阵变换元素。可以通过指定 6 个值来进行矩阵变换。矩阵变换可以实现多种复杂的变换效果。</li>
</ol>
<h3 id="SCSS"><a href="#SCSS" class="headerlink" title="SCSS"></a>SCSS</h3><ol>
<li><strong>SCSS 与 CSS 的区别</strong>：要求应聘者解释 SCSS 与纯 CSS 之间的区别，以及为什么使用 SCSS 的优势。这可能涉及到 SCSS 提供的变量、嵌套、混合、继承等功能，以及它们对代码组织和可维护性的影响。</li>
<li><strong>SCSS 中的变量</strong>：询问应聘者如何在 SCSS 中声明和使用变量，并要求举例说明如何使用变量提高样式表的可维护性。</li>
<li><strong>嵌套</strong>：考察应聘者对于在 SCSS 中如何利用嵌套来组织样式规则，并讨论其优点和缺点。也可以问一些关于嵌套过度导致选择器权重过高或产生不必要复杂性等情况下可能遇到的问题。</li>
<li><strong>混合（Mixins）</strong>：询问应聘者如何创建和使用 SCSS 混合，以及混合与函数之间有什么不同之处。</li>
<li><strong>继承（Inheritance）</strong>：了解应聘者对于在 SCSS 中如何利用继承来减少重复代码并提高样式表可读性方面所持有观点。</li>
<li><strong>函数与指令（Functions and Directives）</strong>: 考察应聘者是否熟悉 SassScript 函数以及编写自定义指令时需要注意哪些事项。</li>
<li><strong>导入其他文件</strong>：询问候选人他们是如何在项目中管理多个 SCSS 文件，并探讨他们认为最佳实践是什么？</li>
<li><strong>SCSS 的工作原理</strong>：考虑向候选人提出关于编译器将 SCSS 转换为纯 CSS 的工作原理相关问题。</li>
</ol>
<h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><h4 id="说说js中的数据类型-基本数据类型和引用数据类型区别，以及存储上的差别"><a href="#说说js中的数据类型-基本数据类型和引用数据类型区别，以及存储上的差别" class="headerlink" title="说说js中的数据类型,基本数据类型和引用数据类型区别，以及存储上的差别"></a>说说js中的数据类型,基本数据类型和引用数据类型区别，以及存储上的差别</h4><p>JavaScript中的数据类型分为两大类：基本数据类型（原始数据类型）和引用数据类型。</p>
<p><strong>基本数据类型</strong></p>
<p>基本数据类型在内存中存储的是值，包含以下几种：</p>
<ol>
<li><strong>Undefined</strong>：表示一个未定义的值，默认值为<code>undefined</code>。</li>
<li><strong>Null</strong>：表示一个空值，意为“无”。</li>
<li><strong>Boolean</strong>：布尔值，只有两个值：<code>true</code>和<code>false</code>。</li>
<li><strong>Number</strong>：表示数字，包括整数和浮点数，所有数字都采用64位浮点数表示。</li>
<li><strong>BigInt</strong>：表示可以表示任意大小的整数，超出Number的安全范围（<code>Number.MAX_SAFE_INTEGER</code>）。</li>
<li><strong>String</strong>：表示字符序列，用于存储文本。</li>
<li><strong>Symbol</strong>：表示唯一且不可变的值，在ES6引入，用于对象属性的唯一性。</li>
</ol>
<p><strong>引用数据类型</strong></p>
<p>引用数据类型存储的是对象的引用或指针，而不是对象本身。主要包括：</p>
<ol>
<li><strong>Object</strong>：最基本的引用数据类型，可以用来存放键值对。</li>
<li><strong>Array</strong>：特殊的对象，用于存放有序列表，可以通过索引访问。</li>
<li><strong>Function</strong>：JavaScript中的函数也是对象，因此也是引用数据类型。</li>
<li><strong>Date</strong>、<strong>RegExp</strong>等：这些都是特定类型的对象。</li>
</ol>
<p><strong>存储上的差别</strong></p>
<ol>
<li><strong>存储方式</strong>：<ul>
<li><strong>基本数据类型</strong>：直接存储在栈（Stack）内存中。由于是固定大小，访问速度快。</li>
<li><strong>引用数据类型</strong>：存储在堆（Heap）内存中，变量保存的是引用地址。访问速度相对较慢。</li>
</ul>
</li>
<li><strong>复制方式</strong>：<ul>
<li><strong>基本数据类型</strong>：赋值时，会创建一个新的副本，例如：<code>let a = 10; let b = a;</code>，此时<code>a</code>和<code>b</code>是两个独立的值。</li>
<li><strong>引用数据类型</strong>：赋值时，实际上是复制了引用，比如：<code>let obj1 = &#123;name: &#39;Alice&#39;&#125;; let obj2 = obj1;</code>，此时<code>obj1</code>和<code>obj2</code>指向同一个对象，修改其中一个会影响另一个。</li>
</ul>
</li>
<li><strong>类型检查</strong>：<ul>
<li><strong>基本数据类型</strong>直接用<code>typeof</code>来判断。</li>
<li><strong>引用数据类型</strong>在判断时需要特别注意，因为数组和对象在<code>typeof</code>下都是<code>object</code>，可以使用<code>Array.isArray()</code>来判断数组。</li>
</ul>
</li>
</ol>
<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>将一种数据类型自动转换为另一种数据类型而不需要显式地调用转换函数。</p>
<ul>
<li><p>字符串连接</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;  </span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&quot;20&quot;</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + b); <span class="comment">// 输出 &quot;1020&quot;，此时数字 10 隐式转换为字符串 &quot;10&quot;，然后与字符串 &quot;20&quot; 连接。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比较操作符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;  </span><br><span class="line"><span class="comment">//因为使用了双等号进行比较时，JavaScript 会进行隐式转换使得数字 10 转化为字符串 &quot;10&quot;。</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="string">&quot;10&quot;</span>) &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;相等&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数学运算</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="number">5</span> - <span class="string">&#x27;3&#x27;</span>;   </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// 输出2, &#x27;3&#x27;被隐式转化成了数字3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>布尔值上下文</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d= !!<span class="string">&quot;hello&quot;</span>; <span class="comment">// true, !! 可以将任何值强制隐式地变成布尔值。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（相等运算符）和-（严格相等运算符）"><a href="#（相等运算符）和-（严格相等运算符）" class="headerlink" title="==（相等运算符）和 ===（严格相等运算符）"></a><code>==</code>（相等运算符）和 <code>===</code>（严格相等运算符）</h4><p>&#x3D;&#x3D; ，在比较之前，会进行类型转换（隐式转换），即使两个值的类型不同，JavaScript 也会尝试将它们转换为相同的类型进行比较</p>
<p>&#x3D;&#x3D;&#x3D;，不进行类型转换，只有当两个值的类型相同且值相等时，才返回 <code>true</code>，可以避免潜在的错误</p>
<h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><p><strong>常用方法：</strong></p>
<ol>
<li><code>push()</code>：在数组末尾添加一个或多个元素，并返回新的长度。</li>
<li><code>pop()</code>：删除并返回数组删除的元素。</li>
<li><code>shift()</code>：删除并返回数组删除的元素。</li>
<li><code>unshift()</code>：在数组开头添加一个或多个元素，并返回新的长度。</li>
<li><code>concat()</code>：连接两个或更多数组，并返回新数组。</li>
<li><code>slice(start, end)</code>：从现有数组中返回选定的元素。</li>
</ol>
<p><strong>特殊方法:</strong></p>
<ol>
<li><p><code>map(callback)</code>:</p>
<ul>
<li>这个方法会对数组中的每个元素都执行回调函数，并将回调函数返回的结果组成一个新的数组返回。</li>
<li>示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  </span><br><span class="line"><span class="keyword">const</span> doubledNumbers = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>);  </span><br><span class="line"><span class="comment">// doubledNumbers 现在是 [2, 4, 6, 8]  </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>filter(callback)</code>:</p>
<ul>
<li>这个方法会根据指定函数过滤原始数据，通过回调函数的boolean，得到符合条件数据组成新数组返回。</li>
<li>示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  </span><br><span class="line"><span class="keyword">const</span> evenNumbers = numbers.<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> ===<span class="number">0</span>);  </span><br><span class="line"><span class="comment">// evenNumbers 现在是 [2,4]  </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>reduce(callback [, initialValue])</code>:</p>
<ul>
<li>这个方法通过提供一个函数来累积所有值以生成单个值。</li>
<li>它接受一个回调函数和一个初始值作为参数，并且这个回调函数接收了上一次调用得到 的结果（或者初始值）和当前元素作为参数。</li>
<li>示例:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span> ,<span class="number">4</span>];  </span><br><span class="line"><span class="keyword">const</span> sum = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulater,currentValue</span>)=&gt;</span> accumulater+currentValue ,<span class="number">0</span> );  </span><br><span class="line"><span class="comment">// sum现在等于10</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="数组扁平化和数组去重"><a href="#数组扁平化和数组去重" class="headerlink" title="数组扁平化和数组去重"></a>数组扁平化和数组去重</h4><p><strong>数组扁平化：</strong></p>
<p>数组扁平化是将多维数组转换为一维数组的过程。这在处理嵌套数组时非常有用。以下是一些实现方式：</p>
<ol>
<li>使用 <code>flat()</code> 方法：<code>flat()</code> 方法可以将嵌套数组展开指定的层数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>]]];  </span><br><span class="line"><span class="keyword">const</span> flattenedArray = nestedArray.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>);  </span><br><span class="line"><span class="comment">// flattenedArray 现在是 [1, 2, 3, 4, 5]  </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用递归函数：可以编写一个递归函数来处理嵌套数组。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenArray</span>(<span class="params">arr</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(val) ? acc.<span class="title function_">concat</span>(<span class="title function_">flattenArray</span>(val)) : acc.<span class="title function_">concat</span>(val), []);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>]]];  </span><br><span class="line"><span class="keyword">const</span> flattenedArray = <span class="title function_">flattenArray</span>(nestedArray);  </span><br><span class="line"><span class="comment">// flattenedArray 现在是 [1, 2, 3, 4, 5]  </span></span><br></pre></td></tr></table></figure>

<p><strong>数组去重：</strong></p>
<p>数组去重是指从数组中移除重复的元素，只保留唯一的元素。以下是一些实现方式：</p>
<ol>
<li>使用 <code>Set</code>：可以使用 <code>Set</code> 数据结构来创建一个不重复的数组。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>];  </span><br><span class="line"><span class="keyword">const</span> uniqueArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array));  </span><br><span class="line"><span class="comment">// uniqueArray 现在是 [1, 2, 3, 4, 5]  </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <code>filter()</code> 和 <code>indexOf()</code>：可以使用 <code>filter()</code> 方法结合 <code>indexOf()</code> 方法来过滤重复的元素。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>];  </span><br><span class="line"><span class="keyword">const</span> uniqueArray = array.<span class="title function_">filter</span>(<span class="function">(<span class="params">value, index, self</span>) =&gt;</span> self.<span class="title function_">indexOf</span>(value) === index);  </span><br><span class="line"><span class="comment">// uniqueArray 现在是 [1, 2, 3, 4, 5]  </span></span><br></pre></td></tr></table></figure>



<h4 id="forEach-和-map-区别"><a href="#forEach-和-map-区别" class="headerlink" title="forEach 和 map 区别"></a>forEach 和 map 区别</h4><p><code>forEach</code> 和 <code>map</code> 都是用于对数组进行遍历和处理的方法</p>
<ul>
<li>如果只需要循环遍历并处理每个元素而不需要生成新的数据，则可以使用 <code>forEach</code></li>
<li>如果希望对原始数据进行映射或转换，并且获得一个新的处理后数据集合，则可以使用 <code>map</code></li>
</ul>
<p><strong><code>forEach</code>:</strong></p>
<ul>
<li><code>forEach</code> 方法是数组的原生方法，它接受一个函数作为参数，并对数组中的每个元素执行该函数。</li>
<li>它没有返回值（或者说返回值为 <code>undefined</code>），因此主要用于遍历数组并对其中的元素执行一些操作。</li>
<li>由于没有返回值，无法通过 <code>forEach</code> 直接得到一个新的数组。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  </span><br><span class="line">array.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(element);  </span><br><span class="line">&#125;);  </span><br><span class="line"><span class="comment">// 输出：1、2、3、4  </span></span><br></pre></td></tr></table></figure>

<p><strong><code>map</code>:</strong></p>
<ul>
<li><code>map</code> 方法也是数组的原生方法，它接受一个函数作为参数，并对数组中的每个元素执行该函数。不同之处在于，它会将处理后得到的结果组成一个新数组并返回。</li>
<li>可以使用 <code>map</code> 方法将原始数组映射&#x2F;转换为新的数组。</li>
<li>对原始数据进行映射或转换时非常有用。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  </span><br><span class="line"><span class="keyword">const</span> doubledArray = array.<span class="title function_">map</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> element * <span class="number">2</span>);  </span><br><span class="line"><span class="comment">// doubledArray 现在是 [2, 4, 6, 8]  </span></span><br></pre></td></tr></table></figure>



<h4 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h4><ol>
<li><code>length</code>：返回字符串的长度。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello&quot;</span>;  </span><br><span class="line"><span class="keyword">const</span> length = str.<span class="property">length</span>; <span class="comment">// length 现在等于 5  </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>charAt(index)</code> 或者 <code>[index]</code>：返回指定索引位置的字符。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello&quot;</span>;  </span><br><span class="line"><span class="keyword">const</span> firstChar = str.<span class="title function_">charAt</span>(<span class="number">0</span>); <span class="comment">// firstChar 现在等于 &quot;H&quot;  </span></span><br><span class="line"><span class="comment">// 或者  </span></span><br><span class="line"><span class="keyword">const</span> firstChar2 = str[<span class="number">0</span>]; <span class="comment">// firstChar2 现在等于 &quot;H&quot;  </span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>toUpperCase()</code> 和 <code>toLowerCase()</code>：将字符串中的字母转换为大写或小写。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line"><span class="keyword">const</span> upperCaseStr1 = str1.<span class="title function_">toUpperCase</span>(); <span class="comment">// upperCaseStr1 现在等于 &quot;HELLO&quot;  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&quot;WORLD&quot;</span>;  </span><br><span class="line"><span class="keyword">const</span> lowerCaseStr2 = str2.<span class="title function_">toLowerCase</span>(); <span class="comment">// lowerCaseStr2 现在等于 &quot;world&quot;  </span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>indexOf(substring)</code> 和 <code>lastIndexOf(substring)</code>：查找子串第一次出现和最后一次出现的位置（索引）。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sentence = <span class="string">&#x27;The quick brown fox jumps over the lazy dog&#x27;</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sentence.<span class="title function_">indexOf</span>(<span class="string">&#x27;fox&#x27;</span>)); <span class="comment">// 输出 16  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sentence.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;the&#x27;</span>)); <span class="comment">// 输出 35  </span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>replace(searchValue, replaceValue)</code>：替换字符串中某个子串为新值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message =<span class="string">&#x27;I am learning JavaScript&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newMessage= message.<span class="title function_">replace</span>(<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newMessage);<span class="comment">//输出: I am learning Python  </span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>split(separator)</code>拆分一个字符串成数组，通过指定分隔符。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sentence=<span class="string">&quot;Welcome to our website&quot;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> words=sentence.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(words);<span class="comment">//输出[&quot;Welcome&quot;, &quot;to&quot;, &quot;our&quot;, 	&quot;website&quot;]  </span></span><br></pre></td></tr></table></figure>



<h4 id="JavaScript-中常用的对象方法"><a href="#JavaScript-中常用的对象方法" class="headerlink" title="JavaScript 中常用的对象方法"></a>JavaScript 中常用的对象方法</h4><ol>
<li>Object.keys(obj)：返回一个包含对象自身属性（不包括继承属性）的键的数组。</li>
<li>Object.values(obj)：返回一个包含对象自身属性值（不包括继承属性）的值的数组。</li>
<li>Object.entries(obj)：返回一个包含对象自身属性键值对（不包括继承属性）的数组。</li>
<li>Object.assign(target, source)：将一个或多个源对象的所有可枚举属性复制到目标对象，并返回目标对象。</li>
<li>Object.create(proto)：使用指定的原型对象创建一个新对象。</li>
<li>Object.defineProperty(obj, prop, descriptor)：定义一个新的属性或修改一个已经存在的属性，并返回该对象。</li>
<li>Object.getOwnPropertyDescriptor(obj, prop)：返回指定对象上一个自有属性对应的属性描述符。</li>
<li>Object.entries(obj)：返回一个给定对象自身可枚举属性的键值对数组。</li>
<li>Object.freeze(obj)：冻结一个对象，使其属性不可修改。</li>
<li>Object.fromEntries(iterable)：将键值对列表转换为一个对象。</li>
<li>Object.getOwnPropertyNames(obj)：返回指定对象的所有自身属性的属性名。</li>
<li>Object.prototype.hasOwnProperty(prop)：判断对象是否具有指定属性。</li>
</ol>
<h4 id="typeof和instanceof-区别"><a href="#typeof和instanceof-区别" class="headerlink" title="typeof和instanceof 区别"></a>typeof和instanceof 区别</h4><ul>
<li>**<code>typeof</code>**： 在 JavaScript 中，原生数据类型（如字符串、数字、布尔值等）使用typeof 或 &#x3D;&#x3D;&#x3D; 来判断<ul>
<li>返回一个字符串，表示变量的类型。</li>
<li>适用于基本数据类型和函数类型的检查。</li>
<li>对于对象和数组返回的都是 <code>&quot;object&quot;</code>，不会提供细粒度的信息。</li>
</ul>
</li>
<li>**<code>instanceof</code>**：对于非原生数据类型，例如对象、数组、函数等，可以使用 <code>instanceof</code> 运算符来判断其类型。<code>instanceof</code> 运算符可以检查一个对象是否是某个构造函数或类的实例。<ul>
<li>返回一个布尔值，表示对象是否是特定构造函数的实例。</li>
<li>适用于所有对象和自定义类型的检查，能够准确检测对象类型。</li>
</ul>
</li>
</ul>
<h4 id="typeof-null-返回的是-“object”，为什么"><a href="#typeof-null-返回的是-“object”，为什么" class="headerlink" title="typeof null 返回的是 “object”，为什么"></a>typeof null 返回的是 “object”，为什么</h4><p>这是因为在 JavaScript 中，null 被认为是一个空的对象引用。它的实际类型是原始值类型，但是 typeof null 返回 “object” 是出于历史原因造成的。</p>
<h4 id="js原型？原型链？有什么特点？"><a href="#js原型？原型链？有什么特点？" class="headerlink" title="js原型？原型链？有什么特点？"></a>js原型？原型链？有什么特点？</h4><p><strong>原型（prototype)</strong></p>
<ul>
<li><strong>原型</strong>：JavaScript 中的原型（prototype）是一种对象间的关联机制，是实现继承和属性共享的基础。</li>
<li>特点：<ol>
<li>原型是对象与对象之间的关系，本质上是一种引用关系。</li>
<li>能够实现对象属性和方法的共享，提高代码的重用性和效率。</li>
<li>当访问一个对象的属性或方法时，JavaScript 引擎会沿着原型链向上查找，直到找到该属性或方法。</li>
</ol>
</li>
</ul>
<p><strong>原型链（prototype chain）</strong></p>
<ul>
<li><strong>原型链</strong>：原型链是由对象的原型与对象组成的链式结构，直到到达原型链的顶端（即 <code>Object.prototype</code>）</li>
<li>特点：<ol>
<li>每个对象都有一个指向其原型的链接，即 <code>__proto__</code> 属性。</li>
<li>当访问一个对象的属性或方法时，JavaScript 引擎会沿着原型链向上查找，直到找到该属性或方法所在的原型对象。</li>
<li>原型链会一直追溯下去直至 <code>Object.prototype</code> 对象 ：person1 —&gt; Person.prototype —&gt; Object.prototype —&gt; null</li>
</ol>
</li>
</ul>
<p><strong>Function.prototype</strong></p>
<p>在 JavaScript 中，<code>Function.prototype</code> 是一个特殊的对象，它是所有函数的原型。当我们创建一个函数时，该函数会自动关联到 <code>Function.prototype</code>。这意味着所有函数对象都可以访问 <code>Function.prototype</code> 上的方法和属性。<br>而 <code>Function.prototype</code> 指向的是一个包含常用函数方法的空函数对象，这个对象是所有函数对象的原型，用于存放和共享函数对象所需的方法和属性。</p>
<h4 id="作用域和作用域链的理解"><a href="#作用域和作用域链的理解" class="headerlink" title="作用域和作用域链的理解"></a>作用域和作用域链的理解</h4><p><strong>作用域</strong></p>
<p>JavaScript 中的作用域主要分为以下几种：</p>
<ol>
<li><strong>全局作用域（Global Scope）</strong>：全局作用域是指在代码中任何地方都能访问的作用域。在浏览器环境中，全局作用域是指 <code>window</code> 对象。</li>
<li><strong>函数作用域（Function Scope）</strong>：函数作用域是指在函数内部声明的变量只能在该函数内部访问。函数外部无法直接访问函数内部的变量。</li>
<li><strong>块级作用域（Block Scope）</strong>：块级作用域是指由一对花括号 <code>&#123;&#125;</code> 定义的范围内有效的作用域。在 ES6 之前，JavaScript 中没有块级作用域，变量的作用域只限于函数内部。但是在 ES6 引入了 <code>let</code> 和 <code>const</code> 关键字，使得可以在块级作用域内声明变量。</li>
<li><strong>词法作用域（Lexical Scope）</strong>：词法作用域是指变量的作用域由代码中变量声明的位置决定，与调用位置无关。JavaScript 使用词法作用域，也就是静态作用域。</li>
<li><strong>闭包（Closure）</strong>：闭包是指函数和其词法环境的组合，可以访问外部函数中定义的变量。通过闭包</li>
</ol>
<p><strong>作用域链</strong></p>
<p>当在一个函数中查找变量时，JavaScript 引擎会首先在当前函数作用域中查找。如果找不到，它会向外部作用域（外皮函数或全局作用域）查找，直到找到该变量或确定该变量未定义为止。这个查找过程形成了一个链式结构，称为“作用域链”。</p>
<p>作用域链式js查找函数和变量的一种机制，作用域链是由当前执行环境的变量对象和父级执行环境的变量对像组成的</p>
<p><strong>作用域链查找过程</strong></p>
<ol>
<li>当前执行的代码块（内层作用域）。</li>
<li>外层函数的作用域（依次向上查找）。</li>
<li>全局作用域。</li>
</ol>
<h4 id="普通函数和箭头函数的区别"><a href="#普通函数和箭头函数的区别" class="headerlink" title="普通函数和箭头函数的区别"></a>普通函数和箭头函数的区别</h4><ol>
<li>语法形式：普通函数使用function关键字定义，箭头函数使用箭头符号（&#x3D;&gt;）定义。</li>
<li>this指向：箭头函数没有自己的this，它会继承外部作用域的this。而普通函数的this是在运行时绑定的，取决于函数的调用方式。</li>
<li>arguments对象：箭头函数没有自己的arguments对象，而是继承外部作用域的arguments。普通函数有arguments对象。</li>
<li>new关键字：普通函数可以作为构造函数使用，通过new关键字创建实例对象。而箭头函数不能被用作构造函数。</li>
<li>返回值：箭头函数对于只有一行返回语句的函数，可以省略{}和return关键字。普通函数没有这种简写形式。</li>
</ol>
<h4 id="谈谈对this的理解"><a href="#谈谈对this的理解" class="headerlink" title="谈谈对this的理解"></a>谈谈对this的理解</h4><ul>
<li><code>this</code> 是一个特殊的关键字，它并不指向函数本身，而是指向调用该函数的上下文（即函数被调用的位置）。</li>
<li>在不同的上下文中，<code>this</code> 的值会有所不同，这取决于函数被调用的方式。</li>
<li><strong>全局上下文</strong>：在全局执行环境中，<code>this</code> 指向全局对象（在浏览器中是 <code>window</code> 对象，在 Node.js 中是 <code>global</code> 对象）</li>
</ul>
<p>​	<strong><code>this</code> 的值的确定方式</strong></p>
<ul>
<li><strong>函数调用</strong>：在普通函数中，<code>this</code> 指向调用该函数的对象。如果是直接调用，<code>this</code> 会指向全局对象（非严格模式下）。</li>
<li><strong>对象的方法</strong>：当一个函数作为对象的方法被调用时，<code>this</code> 指向该对象。</li>
<li><strong>构造函数</strong>：在构造函数中，<code>this</code> 指向新创建的实例。</li>
<li><strong>ES6 箭头函数</strong>：箭头函数不具备自己的 <code>this</code>，它继承自外部函数的 <code>this</code>。</li>
<li><strong>手动绑定</strong>：可以使用 <code>call</code>、<code>apply</code> 和 <code>bind</code> 方法来手动指定 <code>this</code> 的值。</li>
</ul>
<p>​	<strong>常见的陷阱</strong></p>
<ul>
<li><strong>严格模式</strong>：在严格模式下，未绑定的 <code>this</code> 会是 <code>undefined</code> 而不是全局对象。</li>
<li><strong>事件处理函数</strong>：在事件处理程序中，<code>this</code> 通常指向触发事件的元素。</li>
<li><strong>不适合作为构造函数</strong>：箭头函数没有自己的 <code>this</code> 值，不能使用 <code>new</code> 关键字来调用，也不能作为构造函数来创建实例对象。</li>
<li><strong>不适合在对象方法中</strong>：箭头函数的 <code>this</code> 始终指向定义箭头函数时的外层作用域的 <code>this</code> 值，而不是调用时的对象。因此，如果需要在对象方法中使用 <code>this</code>，应该使用普通函数。</li>
<li><strong>不适合在需要动态 <code>this</code> 值的场景</strong>：箭头函数无法改变其 <code>this</code> 的指向，因此不适合在需要动态绑定 <code>this</code> 值的情况下使用。</li>
</ul>
<h4 id="call、apply-和-bind-方法的区别"><a href="#call、apply-和-bind-方法的区别" class="headerlink" title="call、apply 和 bind 方法的区别"></a><code>call</code>、<code>apply</code> 和 <code>bind</code> 方法的区别</h4><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>参数传递方式</th>
<th>返回值</th>
<th>立即执行</th>
</tr>
</thead>
<tbody><tr>
<td><code>call</code></td>
<td>调用函数并指定 <code>this</code></td>
<td>依次传递独立的参数</td>
<td>无</td>
<td>是</td>
</tr>
<tr>
<td><code>apply</code></td>
<td>调用函数并指定 <code>this</code></td>
<td>以数组传递参数</td>
<td>无</td>
<td>是</td>
</tr>
<tr>
<td><code>bind</code></td>
<td>创建一个新函数，指定 <code>this</code> 和参数</td>
<td>指定的参数</td>
<td>返回新函数</td>
<td>否</td>
</tr>
</tbody></table>
<ul>
<li>bind()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;  </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundFunc = sayHello.<span class="title function_">bind</span>(obj);  </span><br><span class="line"><span class="title function_">boundFunc</span>(); <span class="comment">// 输出：Hello, Alice</span></span><br></pre></td></tr></table></figure>

<ul>
<li>apply() &#x2F; call()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;  </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">sayHello.<span class="title function_">call</span>(obj); <span class="comment">// 输出：Hello, Alice  </span></span><br><span class="line">sayHello.<span class="title function_">apply</span>(obj); <span class="comment">// 输出：Hello, Alice</span></span><br></pre></td></tr></table></figure>

<h4 id="其他修改this指向的方法"><a href="#其他修改this指向的方法" class="headerlink" title="其他修改this指向的方法"></a>其他修改this指向的方法</h4><ul>
<li><strong>使用 ES6 的解构赋值</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;  </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,  </span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; sayHello &#125; = obj;  </span><br><span class="line"><span class="title function_">sayHello</span>(); <span class="comment">// 输出：Hello, Alice</span></span><br></pre></td></tr></table></figure>



<h4 id="ajax的原理"><a href="#ajax的原理" class="headerlink" title="ajax的原理"></a>ajax的原理</h4><p>AJAX（Asynchronous JavaScript and XML）是一种用于在不重新加载整个网页的情况下向服务器发送和接收数据的技术。使用 AJAX，可以通过 JavaScript 发送异步请求，从而使用户能够与页面交互而无需等待整个页面刷新</p>
<ol>
<li>使用 XMLHttpRequest 对象：JavaScript 中的 XMLHttpRequest 对象是实现 AJAX 的基础。通过创建一个新的 XMLHttpRequest 对象，可以发送 HTTP 请求到服务器，并在后台处理响应。</li>
<li>异步通信：AJAX 使用异步方式发送和接收数据，这意味着浏览器会在不阻塞其他操作的情况下进行数据通信。这样用户可以继续与页面交互，同时浏览器会在后台进行数据传输和处理。</li>
<li>服务器端处理请求：当客户端发送一个 AJAX 请求时，服务器会接受并处理该请求。通常情况下，服务器将返回 JSON、XML 或纯文本等格式化数据作为响应。</li>
<li>更新页面内容：一旦客户端收到来自服务器的响应数据，在获取到结果后就能够使用 JavaScript 动态地更新网页上对应的部分内容或执行特定操作。</li>
<li>回调函数机制：由于异步请求是非阻塞式执行, 因此在获取到响应之前无法直接得知结果。因此，在发起异步请求时需要注册回调函数，并当请求完成时执行相应回调函数以处理返回结果。</li>
</ol>
<h4 id="axios的原理"><a href="#axios的原理" class="headerlink" title="axios的原理"></a>axios的原理</h4><p>Axios 是一个基于 Promise 的 HTTP 客户端，它提供了一种简单、易用、灵活和强大的方式来发送 HTTP 请求和处理响应。</p>
<ol>
<li>基于 XMLHttpRequest 对象：Axios 使用 XMLHttpRequest 对象来发送 HTTP 请求和接收响应。它提供了一种简单、易用、灵活和强大的方式来处理 HTTP 请求和响应。</li>
<li>支持 Promise API：Axios 基于 Promise API，可以使用 Promise 的 then() 和 catch() 方法来处理异步请求和响应。这使得代码更加简洁易读，并且可以避免回调地狱的问题。</li>
<li>支持拦截器：Axios 支持请求和响应拦截器，可以在请求和响应被发送或接收之前或之后对它们进行处理。这使得可以在请求和响应中添加通用的处理逻辑，例如添加请求头、处理错误等。</li>
<li>支持取消请求：Axios 支持取消请求，可以在请求被发送之前或之后取消它们。这使得可以在需要时取消不必要的请求，从而提高性能和用户体验。要取消请求，只需调用 source.cancel() 方法</li>
<li>支持并发请求：Axios 支持并发请求，可以同时发送多个请求，并在所有请求完成后处理它们的响应。这使得可以在需要时同时发送多个请求，从而提高性能和用户体验。基于pomise.all() ;Axios使用 <code>axios.all()</code> 或 <code>axios.spread()</code> 方法来发送并发请求。</li>
</ol>
<h4 id="如何判断一个元素在可视区域内"><a href="#如何判断一个元素在可视区域内" class="headerlink" title="如何判断一个元素在可视区域内"></a>如何判断一个元素在可视区域内</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个元素是否在可视区域内的方法  </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewport</span>(<span class="params">element</span>) &#123;  </span><br><span class="line">  <span class="comment">// 获取元素相对于视口的位置信息  </span></span><br><span class="line">  <span class="keyword">const</span> rect = element.<span class="title function_">getBoundingClientRect</span>();  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断元素的四个边界是否都在视口内，如果是则返回 true，否则返回 false  </span></span><br><span class="line">  <span class="keyword">return</span> (  </span><br><span class="line">    rect.<span class="property">top</span> &gt;= <span class="number">0</span> &amp;&amp;                              <span class="comment">// 元素顶部在视口内（大于等于0）  </span></span><br><span class="line">    rect.<span class="property">left</span> &gt;= <span class="number">0</span> &amp;&amp;                             <span class="comment">// 元素左边在视口内（大于等于0）  </span></span><br><span class="line">    rect.<span class="property">bottom</span> &lt;= (<span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>) &amp;&amp;   <span class="comment">// 元素底部在视口内（小于等于视口高度）  </span></span><br><span class="line">    rect.<span class="property">right</span> &lt;= (<span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>)          <span class="comment">// 元素右边在视口内（小于等于视口宽度）  </span></span><br><span class="line">  );  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例  </span></span><br><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;yourElementId&#x27;</span>);   <span class="comment">// 获取需要检测的元素  </span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isInViewport</span>(element)) &#123;                                <span class="comment">// 调用 isInViewport 函数判断该元素是否在可见区域内，并进行相应处理  </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Element is in the viewport&#x27;</span>);                 <span class="comment">// 如果元素在可见区域内，则输出提示信息到控制台  </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Element is not in the viewport&#x27;</span>);             <span class="comment">// 如果元素除了可见区域外，则输出提示信息到控制台   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><p>柯里化的主要思想是，将一个多参数的函数转换为一系列只接受单个参数的函数，这些函数通过闭包的方式“记住”之前传递的参数，最后再返回一个值或执行某些操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> x + y;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用柯里化的add函数  </span></span><br><span class="line"><span class="keyword">const</span> add5 = <span class="title function_">add</span>(<span class="number">5</span>);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add5</span>(<span class="number">2</span>)); <span class="comment">// 输出：7  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以一次性传入所有参数  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">5</span>)(<span class="number">2</span>)); <span class="comment">// 输出：7</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">add 是一个接受一个参数 x 的函数，返回一个接受参数 y 的函数。通过柯里化，我们可以先传入部分参数创建一个新的函数（如 add5 = add(5)），然后再传入剩余的参数来调用这个函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数柯里化在函数式编程中有很多应用，比如可以用来简化函数的调用方式、方便数据处理和组合等。通过柯里化，我们可以更灵活地使用函数和处理数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="for…in…-可枚举属性-和-for…of…-区别-迭代器"><a href="#for…in…-可枚举属性-和-for…of…-区别-迭代器" class="headerlink" title="for…in… (可枚举属性)和 for…of… 区别(迭代器)"></a>for…in… (可枚举属性)和 for…of… 区别(迭代器)</h4><ol>
<li>for…in<ul>
<li>适用于遍历对象（Object）的属性名。</li>
<li>在遍历时会包括对象自身的可枚举属性以及继承得到的可枚举属性。性能开支会比for…of…大</li>
<li>通常不建议直接使用 <code>for...in</code> 来遍历数组，因为它<strong>可能会遍历到数组原型链上的其他属性。</strong></li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;  </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,  </span><br><span class="line"> <span class="attr">age</span>: <span class="number">30</span>  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person) &#123;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(key, person[key]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>for…of<ul>
<li><code>for...of</code> 循环是 ES6 引入的用于迭代可迭代对象（如数组、字符串、Set、Map 等）的语法。</li>
<li>主要用于循环<strong>可迭代对象</strong>（iterable objects），比如数组、字符串、Map、Set 等。不支持普通对象(对象没有迭代器)</li>
<li>在循环时会访问到对象中具体的值，而不是键或索引。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">of</span> colors) &#123;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(color);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="js-DOM事件模型"><a href="#js-DOM事件模型" class="headerlink" title="js DOM事件模型"></a>js DOM事件模型</h4><p>​	<strong>事件</strong></p>
<ul>
<li><code>click</code>：鼠标点击事件</li>
<li><code>mouseover</code>：鼠标悬停事件</li>
<li><code>keydown</code>：键盘按下事件</li>
<li><code>submit</code>：表单提交事件</li>
</ul>
<p>​	<strong>事件监听器</strong></p>
<ul>
<li><code>addEventListener</code> 方法来注册事件监听器</li>
</ul>
<p>​	<strong>事件对象</strong></p>
<ul>
<li>当事件发生时，浏览器会创建一个事件对象（<code>event</code>），该对象包含事件的相关信息（如事件类型、目标元素、鼠标位置等）。</li>
</ul>
<p>​	<strong>事件冒泡与事件捕获</strong></p>
<blockquote>
<p>可以通过 <code>addEventListener</code> 的第三个参数来控制事件处理的阶段<br>element.addEventListener(‘click’, ()&#x3D;&gt;{}, true);如果设置为 <code>true</code>，则使用捕获模式；如果设置为 <code>false</code> 反之<br>默认是 <code>false</code>，即采用事件冒泡模式。</p>
</blockquote>
<ul>
<li><strong>事件捕获</strong>：事件从外部元素向内部元素传递（从文档根节点到目标元素）。</li>
<li><strong>事件冒泡</strong>：事件从目标元素向外部元素传递（从目标元素到文档根节点）。</li>
</ul>
<p>​	<strong>事件委托</strong></p>
<p>利用事件冒泡机制, 允许将事件处理程序添加到父元素上。将事件监听器绑定到父元素。</p>
<p>场景：1. 列表或菜单 2. 动态生成内容 3. 多个表单元素</p>
<p>​	<strong>防止默认行为</strong></p>
<p>阻止事件的默认行为（例如，防止表单提交）。可以通过调用事件对象的 <code>preventDefault()</code> 方法来实现</p>
<p>​	<strong>停止事件传播</strong></p>
<p>通过调用事件对象的 <code>stopPropagation()</code> 方法来停止事件的传播，防止事件冒泡到父元素。</p>
<h4 id="创建对象有哪些方法"><a href="#创建对象有哪些方法" class="headerlink" title="创建对象有哪些方法"></a>创建对象有哪些方法</h4><ol>
<li><strong>使用对象字面量</strong>：这是最简单的创建对象的方法，通过花括号 <code>&#123;&#125;</code> 来定义对象，并填入属性和方法。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;  </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,  </span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,  </span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用构造函数</strong>：可以使用构造函数来创建对象。通过 <code>new</code> 关键字和构造函数来实例化新的对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;  </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;  </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;  </span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">30</span>);  </span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用 Object 构造函数</strong>：可以使用内置的 <code>Object</code> 构造函数来创建空对象，然后逐个添加属性和方法。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Charlie&#x27;</span>;  </span><br><span class="line">person.<span class="property">age</span> = <span class="number">22</span>;  </span><br><span class="line">person.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用原型</strong>：通过定义一个原型（prototype）并将其与一个构造函数相关联，我们可以共享属性和方法，并且每个实例都有对它们的引用。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span>=age;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;David&#x27;</span>,<span class="number">28</span>);  </span><br></pre></td></tr></table></figure>

<ol>
<li><strong>ES6 中的类</strong> ：ES6 引入了类（class）语法糖，更容易地定义并继承 JavaScript 中的类。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;  </span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params">name,age</span>)&#123;  </span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">name</span>=name,  </span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">age</span>=age  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="title function_">greet</span>(<span class="params"></span>)&#123;  </span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>._name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>._age&#125;</span>`</span>)  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Eve&#x27;</span>,<span class="number">26</span>)  </span><br></pre></td></tr></table></figure>



<h4 id="new-操作符具体操作"><a href="#new-操作符具体操作" class="headerlink" title="new 操作符具体操作"></a>new 操作符具体操作</h4><ol>
<li>创建一个空对象，这个对象会成为函数的实例。</li>
<li>将这个空对象的原型指向构造函数的原型对象。</li>
<li>将构造函数中的 <code>this</code> 绑定到这个新的实例对象。</li>
<li>执行构造函数内部的代码。</li>
</ol>
<h4 id="什么数据存在对象中，什么数据存在prototype中"><a href="#什么数据存在对象中，什么数据存在prototype中" class="headerlink" title="什么数据存在对象中，什么数据存在prototype中"></a>什么数据存在对象中，什么数据存在prototype中</h4><ul>
<li><strong>存在对象本身中的数据</strong>：通常是实例特有的数据，每个对象实例都有自己的一份数据副本。这些数据可以通过对象的属性来访问和修改，属于对象的内部状态。</li>
<li><strong>存在 prototype 中的数据</strong>：通常是对象共享的数据，被所有该类型对象实例共享。这些数据一般是方法或共享的属性，定义在对象的原型上，可以被所有该类型的实例访问。当我们访问一个对象的属性时，如果该属性不在对象本身中，则会去原型链上查找。</li>
</ul>
<h4 id="如何判断a是不是b的实例"><a href="#如何判断a是不是b的实例" class="headerlink" title="如何判断a是不是b的实例"></a>如何判断a是不是b的实例</h4><p>在 JavaScript 中，可以使用 <code>instanceof</code> 运算符来判断一个对象是否是另一个对象的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>



<h4 id="深拷贝和浅拷贝区别"><a href="#深拷贝和浅拷贝区别" class="headerlink" title="深拷贝和浅拷贝区别"></a>深拷贝和浅拷贝区别</h4><p>​	<strong>浅拷贝</strong></p>
<p>浅拷贝是指创建一个新对象，普通数据类型属性会被拷贝，但引用类型变量将指向同一个引用，且这种方式只复制一层的属性。</p>
<p>常用方法：  <code>Object.assign()</code>， 使用扩展运算符， 数组的 <code>slice()</code> 或 <code>concat()</code></p>
<p>​	<strong>深拷贝</strong></p>
<p>深拷贝是指创建一个新对象，这个新对象完全复制原始对象的所有属性，包括嵌套对象的属性。深拷贝的结果是新对象与原始对象之间没有任何引用关系，彼此独立</p>
<p>常用方法： </p>
<ul>
<li><p>使用 <code>JSON.stringify()</code> 和 <code>JSON.parse()</code>（有局限性）</p>
<ul>
<li><p>使用 JSON.parse(JSON.stringify()) - 序列化</p>
<p>深拷贝时，可能会丢失以下信息：</p>
<ul>
<li>不支持 函数、正则表达式、日期对象、undefined、symbol等。</li>
<li>如果对象之间存在引用关系会导致无法正确的序列化和反序列化。</li>
</ul>
</li>
</ul>
</li>
<li><p>手动递归拷贝</p>
</li>
<li><p>使用第三方库，如 Lodash 的 <code>_.cloneDeep()</code></p>
</li>
<li><p>对数组的深拷贝还可以使用 扩展运算符</p>
</li>
</ul>
<h4 id="json-stringify-是干什么的，什么时候会使用到"><a href="#json-stringify-是干什么的，什么时候会使用到" class="headerlink" title="json.stringify() 是干什么的，什么时候会使用到"></a>json.stringify() 是干什么的，什么时候会使用到</h4><p><code>JSON.stringify()</code> 方法是用于将 JavaScript 对象或值转换为 JSON 字符串的方法。它接受一个对象或数组作为参数，然后返回对应的 JSON 字符串表示。</p>
<ol>
<li><strong>数据传输：</strong> 在客户端和服务器之间进行数据传输时，通常需要将 JavaScript 对象转换为 JSON 字符串进行传输。这样可以方便地在不同系统之间交换数据。</li>
<li><strong>本地存储：</strong> 在浏览器端使用 <code>localStorage</code> 或 <code>sessionStorage</code> 存储数据时，通常需要将 JavaScript 对象转换为 JSON 字符串再存储，以便在取出时重新解析为对象。</li>
<li><strong>日志记录：</strong> 在记录日志或调试信息时，有时会将对象转换为 JSON 格式以便于查看和分析。</li>
<li><strong>与后端交互：</strong> 在前端向后端发送数据时，常常会将 JavaScript 对象转换为 JSON 字符串，以便后端能够正确解析和处理数据。</li>
</ol>
<h4 id="防抖和节流，及应用场景"><a href="#防抖和节流，及应用场景" class="headerlink" title="防抖和节流，及应用场景"></a>防抖和节流，及应用场景</h4><p>防抖和节流都是用于控制函数执行频率的技术，它们的应用场景如下：</p>
<ol>
<li><strong>防抖（Debouncing）</strong>：防抖是指在一段时间内，多次触发同一个函数，只执行最后一次触发的函数。防抖通常用于处理用户输入，比如搜索框输入、滚动事件等。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;  </span><br><span class="line">  <span class="keyword">let</span> timer;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;  </span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;  </span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);  </span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">      func.<span class="title function_">apply</span>(context, args);  </span><br><span class="line">    &#125;, delay);  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> searchInput = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#search-input&#x27;</span>);  </span><br><span class="line">searchInput.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="title function_">debounce</span>(handleSearch, <span class="number">500</span>));  </span><br></pre></td></tr></table></figure>

<ol>
<li><strong>节流（Throttling）</strong>：节流是指在一段时间内，多次触发同一个函数，只执行一次函数。节流通常用于处理高频事件，比如鼠标移动、窗口调整等。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, delay</span>) &#123;  </span><br><span class="line">  <span class="keyword">let</span> timer;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;  </span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;  </span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;  </span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">        func.<span class="title function_">apply</span>(context, args);  </span><br><span class="line">        timer = <span class="literal">null</span>;  </span><br><span class="line">      &#125;, delay);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="title function_">throttle</span>(handleResize, <span class="number">500</span>));  </span><br></pre></td></tr></table></figure>



<h4 id="大量加载数据怎么优化，怎么避免滚动条滚动"><a href="#大量加载数据怎么优化，怎么避免滚动条滚动" class="headerlink" title="大量加载数据怎么优化，怎么避免滚动条滚动"></a>大量加载数据怎么优化，怎么避免滚动条滚动</h4><ol>
<li><strong>分页加载</strong>：将数据分成多个页面，只在用户需要时加载当前页面的数据。这样可以减少一次性加载大量数据带来的性能问题。</li>
<li><strong>虚拟滚动</strong>：使用虚拟滚动技术，只渲染可见区域内的部分数据，而不是全部数据。这种方式可以减少 DOM 元素数量，提高页面渲染性能。</li>
<li><strong>懒加载</strong>：在用户向下滚动时才进行数据加载，而不是一开始就加载所有内容。这样可以延迟实际需要显示的内容的加载时间。</li>
<li><strong>增量式加载</strong>：根据用户操作实时请求新的数据，并将它们添加到已有列表中，而不是重新获取整个列表。</li>
<li><strong>前端缓存</strong>：如果可能，在前端进行缓存以避免重复请求相同资源，并且优先从缓存中获取所需信息。</li>
<li><strong>后端优化</strong>：对于大型数据库查询或跨网络请求，请确保后端服务具备高效率和合理响应时间。</li>
<li><strong>索引和分片</strong>（针对数据库）: 如果你使用数据库，则确保表上有适当地索引以提高检索速度，并且考虑将大表切割成小片段以加快查询速度。</li>
<li><strong>压缩传输</strong>: 如果你从后端服务器获得了大量静态资源（如图片、视频等），请确保它们被适当地压缩和传输到客户端，以减小网络负载和加快下载速度。</li>
</ol>
<h4 id="图片懒加载和列表虚拟滚动怎么实现"><a href="#图片懒加载和列表虚拟滚动怎么实现" class="headerlink" title="图片懒加载和列表虚拟滚动怎么实现"></a>图片懒加载和列表虚拟滚动怎么实现</h4><p><strong>图片懒加载</strong></p>
<ol>
<li>将页面上的图片的 <code>src</code> 属性设置为占位符，例如一个空白的透明图片。</li>
<li>监听页面滚动事件，或者使用 Intersection Observer API 监听图片元素是否进入可视区域。</li>
<li>当图片进入可视区域时，将图片的 <code>src</code> 属性设置为实际的图片地址，从而触发图片加载。</li>
</ol>
<p><strong>列表虚拟滚动</strong></p>
<ol>
<li>获取列表的总高度和每个列表项的高度。</li>
<li>根据可视区域的高度计算出可见的列表项数量。</li>
<li>根据滚动位置计算出当前可见的列表项的起始索引。</li>
<li>只渲染当前可见的列表项，而不渲染整个列表。</li>
<li>随着用户滚动列表，动态更新可见列表项的内容。</li>
</ol>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包的核心概念是函数和其词法环境的组合。在函数内部定义函数，函数内部引用外部作用域的变量，形成闭包。<br>应用场景：1. 保存状态  2.封装私有变量  3. 延迟执行 3.模块化</p>
<h4 id="原生js创建自定义事件"><a href="#原生js创建自定义事件" class="headerlink" title="原生js创建自定义事件"></a>原生js创建自定义事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个名为 &quot;customEvent&quot; 的自定义事件  </span></span><br><span class="line"><span class="keyword">const</span> customEvent = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;customEvent&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要监听该事件的地方添加监听器  </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;customEvent&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Custom event triggered&#x27;</span>);  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发自定义事件  </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(customEvent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以使用 CustomEvent 构造函数来创建包含更多信息（如数据）的更复杂的自定义事件：</span></span><br><span class="line"><span class="keyword">const</span> eventData = &#123; <span class="attr">message</span>: <span class="string">&#x27;Hello, this is a custom event&#x27;</span> &#125;;  </span><br><span class="line"><span class="keyword">const</span> customEvent = <span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="string">&#x27;customEvent&#x27;</span>, &#123; <span class="attr">detail</span>: eventData &#125;);  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;customEvent&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Custom event triggered with message: <span class="subst">$&#123;event.detail.message&#125;</span>`</span>);  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(customEvent);</span><br></pre></td></tr></table></figure>



<h4 id="文件上传怎么做预览"><a href="#文件上传怎么做预览" class="headerlink" title="文件上传怎么做预览"></a>文件上传怎么做预览</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fileInput&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;preview&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    	<span class="comment">// 获取文件输入元素和预览容器  </span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>);  </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> preview = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;preview&#x27;</span>);  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 监听文件输入元素的变化事件  </span></span></span><br><span class="line"><span class="language-javascript">        fileInput.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 获取用户选择的文件  </span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> file = fileInput.<span class="property">files</span>[<span class="number">0</span>];  </span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 创建 FileReader 对象  </span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 当读取完成时触发 onload 事件  </span></span></span><br><span class="line"><span class="language-javascript">          reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 创建新的 Image 对象  </span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();  </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 将读取的文件内容设置为图片的 src 属性  </span></span></span><br><span class="line"><span class="language-javascript">            img.<span class="property">src</span> = e.<span class="property">target</span>.<span class="property">result</span>;  </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 清空预览容器并添加图片  </span></span></span><br><span class="line"><span class="language-javascript">            preview.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;  </span></span><br><span class="line"><span class="language-javascript">            preview.<span class="title function_">appendChild</span>(img);  </span></span><br><span class="line"><span class="language-javascript">          &#125;;  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 如果用户选择了文件，则读取文件内容并生成预览  </span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (file) &#123;  </span></span><br><span class="line"><span class="language-javascript">            reader.<span class="title function_">readAsDataURL</span>(file);  </span></span><br><span class="line"><span class="language-javascript">          &#125;  </span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="文件秒传怎么实现"><a href="#文件秒传怎么实现" class="headerlink" title="文件秒传怎么实现"></a>文件秒传怎么实现</h4><p>文件秒传是一种常见的文件上传优化技术，可以在用户重复上传相同文件时，通过检查文件的哈希值或其他标识，实现直接跳过上传步骤，从而大幅提升用户体验。</p>
<h4 id="切片上传"><a href="#切片上传" class="headerlink" title="切片上传"></a>切片上传</h4><ul>
<li>触发input上传事件</li>
<li>获取上传文件对象</li>
<li>创建分片数据</li>
<li>文件内容创建hash</li>
<li>调用发送分片接口</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;upload&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.bootcdn.net/ajax/libs/spark-md5/3.0.2/spark-md5.min.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.7.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取元素节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;upload&quot;</span>);  </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 监听input</span></span></span><br><span class="line"><span class="language-javascript">        input.<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">event</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取文件信息 </span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> file = event.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> fileName = event.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>].<span class="property">fileName</span>;  </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 创建分片 以50M 为一个分片</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> chunks = <span class="title function_">createChunk</span>(file, <span class="number">50</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 为上传文件创建hash</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">hash</span>(chunks);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 调用上传接口</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">uploadChunk</span>(chunks, hash, fileName);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 分片存储</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">createChunk</span>(<span class="params">file, chunkSize</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> result = []</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;file.<span class="property">size</span>;i += chunkSize)&#123;</span></span><br><span class="line"><span class="language-javascript">                result.<span class="title function_">push</span>(file.<span class="title function_">slice</span>(i, i + chunkSize))</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> result;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建hash值</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">hash</span>(<span class="params">chunks</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> spark = <span class="keyword">new</span> <span class="title class_">SparkMD5</span>()</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">function</span> <span class="title function_">_read</span>(<span class="params">index</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span>(i &gt;= chunks.<span class="property">length</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">resolve</span>(spark.<span class="title function_">end</span>())</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                    </span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">let</span> blob = chunks[index]</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">let</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>()</span></span><br><span class="line"><span class="language-javascript">                    reader.<span class="property">onload</span> = <span class="function"><span class="params">e</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> byters = e.<span class="property">target</span>.<span class="property">result</span>;</span></span><br><span class="line"><span class="language-javascript">                        spark.<span class="title function_">append</span>(bytes)</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">_read</span>(i+<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                    reader.<span class="title function_">readAsArrayBuffer</span>(blob)</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">_read</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 分片上传</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">uploadChunk</span>(<span class="params">chunks, hash, fileName</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 遍历上传</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> taskArr=[];</span></span><br><span class="line"><span class="language-javascript">            chunk.<span class="title function_">forEash</span>(<span class="function">(<span class="params">chunk, index</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> formdata = <span class="keyword">new</span> <span class="title class_">FromData</span>();</span></span><br><span class="line"><span class="language-javascript">                formdata.<span class="title function_">append</span>(<span class="string">&#x27;chunk&#x27;</span>,chunk);</span></span><br><span class="line"><span class="language-javascript">                formdata.<span class="title function_">append</span>(<span class="string">&#x27;chunkName&#x27;</span>, <span class="string">`<span class="subst">$&#123;hash&#125;</span>-<span class="subst">$&#123;index&#125;</span>-<span class="subst">$&#123;fileName&#125;</span>`</span>)</span></span><br><span class="line"><span class="language-javascript">                formdata.<span class="title function_">append</span>(<span class="string">&#x27;fileName&#x27;</span>,fileName)</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> task = axios.<span class="title function_">post</span>(<span class="string">&#x27;https://127.0.0.1:3000/&#x27;</span>, fromdata, &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">headers</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;)</span></span><br><span class="line"><span class="language-javascript">                taskArr.<span class="title function_">push</span>(task)</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Promise</span>.<span class="title function_">all</span>(taskArr)</span></span><br><span class="line"><span class="language-javascript">                .<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;通知后端，上传完毕，合并数据&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">                .<span class="title function_">catch</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="一个10g文件怎么进行分片，怎么确定合适的分片大小，分片hash过程怎么优化"><a href="#一个10g文件怎么进行分片，怎么确定合适的分片大小，分片hash过程怎么优化" class="headerlink" title="一个10g文件怎么进行分片，怎么确定合适的分片大小，分片hash过程怎么优化"></a>一个10g文件怎么进行分片，怎么确定合适的分片大小，分片hash过程怎么优化</h4><p><strong>实现步骤：</strong></p>
<ol>
<li>确定分片大小：分片大小应该根据网络带宽、服务器性能和文件大小等因素进行调整。通常情况下，分片大小应该在 1MB 到 10MB 之间。如果分片过小，会增加网络请求的次数，导致上传或下载速度变慢；如果分片过大，会增加服务器的负担，导致上传或下载失败。</li>
<li>计算分片数量：根据文件大小和分片大小计算出需要分成多少个分片。</li>
<li>分片上传或下载：将文件分成多个分片，分别上传或下载。在上传或下载过程中，需要记录每个分片的状态，以便在上传或下载失败时进行重试。</li>
<li>合并分片：在所有分片上传或下载完成后，将所有分片合并成一个完整的文件。</li>
</ol>
<h4 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h4><p>断点续传是指在上传或下载文件时，如果因为网络中断或其他原因导致上传或下载失败，可以从上次失败的位置继续上传或下载，而不需要重新开始。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li>在上传或下载过程中，记录已经上传或下载的字节数。</li>
<li>如果上传或下载失败，可以使用已经上传或下载的字节数来计算出需要继续上传或下载的位置。</li>
<li>从上次失败的位置继续上传或下载。</li>
<li>在上传或下载完成后，将所有分片合并成一个完整的文件。</li>
</ol>
<h4 id="上拉刷新，下拉加载"><a href="#上拉刷新，下拉加载" class="headerlink" title="上拉刷新，下拉加载"></a>上拉刷新，下拉加载</h4><p>使用scroll事件，您可以实现以下功能：</p>
<ol>
<li>监听滚动位置：通过scroll事件可以获取滚动条的位置信息，例如滚动条的垂直滚动位置（scrollTop）或水平滚动位置（scrollLeft）。</li>
<li>实现无限滚动：通过监听scroll事件，可以在滚动到页面底部时自动加载更多内容，实现无限滚动效果。这在需要展示大量数据的网页或应用中很常见。</li>
<li>实现懒加载：通过监听scroll事件，可以判断元素是否进入可视区域，从而实现图片或其他资源的懒加载。当用户滚动到包含懒加载元素的位置时，再加载相应的内容，以提高页面加载速度和性能。</li>
<li>实现滚动动画：通过监听scroll事件，可以根据滚动条的位置实现各种滚动动画效果，例如导航栏的固定、滚动时的渐变效果等。</li>
</ol>
<p><strong>上拉刷新：</strong></p>
<ul>
<li>当用户向上滑动页面时，检测到滑动距离达到一定阈值时，触发数据的刷新操作。</li>
<li>可以使用JavaScript监听<code>scroll</code>事件来监测页面滚动位置，并在特定条件下执行数据更新操作。</li>
<li>也可以借助第三方插件或框架（如React Native中的FlatList组件）提供的上拉刷新功能。</li>
</ul>
<p><strong>下拉加载：</strong></p>
<ul>
<li>当用户向下滑动页面至底部时，触发加载更多内容的操作。</li>
<li>同样可以利用JavaScript监听<code>scroll</code>事件并结合页面高度、滚动位置等信息来实现。</li>
<li>也可以使用第三方库或框架提供的下拉加载功能（比如Vue.js中的Infinite Scroll插件）。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>上拉刷新、下拉加载示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css">  </span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 样式用于显示loading状态 */</span>  </span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.loading</span> &#123;  </span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-align</span>: center;  </span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">20px</span>;  </span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-weight</span>: bold;  </span></span><br><span class="line"><span class="language-css">    &#125;  </span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:500px; overflow-y:auto;&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!-- 动态数据内容 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 这里是动态数据列表 --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 加载更多提示信息 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;loadMore&quot;</span> <span class="attr">class</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span>向上滑动以加载更多内容...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 模拟的动态数据  </span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> data = [<span class="string">&#x27;Item1&#x27;</span>, <span class="string">&#x27;Item2&#x27;</span>, <span class="string">&#x27;Item3&#x27;</span>];  </span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> currentPage = <span class="number">1</span>;  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 下拉加载更多  </span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">scrollTop</span> + <span class="variable language_">this</span>.<span class="property">clientHeight</span> &gt;= <span class="variable language_">this</span>.<span class="property">scrollHeight</span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">loadMore</span>();  </span></span><br><span class="line"><span class="language-javascript">   &#125;  </span></span><br><span class="line"><span class="language-javascript">&#125;);  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">loadMore</span>(<span class="params"></span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">   <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;loadMore&#x27;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;  </span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// 模拟异步请求新数据（假设通过API获取新数据）  </span></span></span><br><span class="line"><span class="language-javascript">   <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">let</span> newData = [<span class="string">&#x27;New Item &#x27;</span> + (currentPage * data.<span class="property">length</span> + i) <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="title class_">Array</span>(<span class="number">5</span>))];  </span></span><br><span class="line"><span class="language-javascript">       <span class="comment">// 将新增数据添加到页面中  </span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">let</span> contentDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;content&#x27;</span>);  </span></span><br><span class="line"><span class="language-javascript">       newData.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;  </span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">let</span> newItemNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;DIV&quot;</span>);  </span></span><br><span class="line"><span class="language-javascript">           newItemNode.<span class="property">innerText</span> = item;  </span></span><br><span class="line"><span class="language-javascript">           contentDiv.<span class="title function_">appendChild</span>(newItemNode);  </span></span><br><span class="line"><span class="language-javascript">       &#125;);  </span></span><br><span class="line"><span class="language-javascript">       </span></span><br><span class="line"><span class="language-javascript">       currentPage++;  </span></span><br><span class="line"><span class="language-javascript">       </span></span><br><span class="line"><span class="language-javascript">       <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;loadMore&#x27;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;  </span></span><br><span class="line"><span class="language-javascript">   &#125;, <span class="number">1000</span>); <span class="comment">// 模拟延时请求  </span></span></span><br><span class="line"><span class="language-javascript">&#125;  </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="web常见攻击方式，如何预防"><a href="#web常见攻击方式，如何预防" class="headerlink" title="web常见攻击方式，如何预防"></a>web常见攻击方式，如何预防</h4><p>SQL注入、跨站脚本（XSS）、跨站请求伪造（CSRF）、点击劫持等。</p>
<ol>
<li>SQL注入：避免使用动态拼接SQL语句，而是使用参数化查询或者ORM框架来处理数据库操作；对用户输入进行严格验证和过滤，确保不含恶意代码。</li>
<li>跨站脚本（XSS）：对用户输入进行HTML编码或转义，以防止恶意脚本在页面中执行；设置安全的HTTP头部来减少XSS风险。</li>
<li>跨站请求伪造（CSRF）：使用随机生成的令牌来验证表单提交和重要操作的合法性；通过SameSite Cookie属性限制Cookie在跨域请求中发送。</li>
<li>点击劫持：通过设置X-Frame-Options头部或Content Security Policy (CSP) 来防止网页被嵌入到iframe中，并显示一个透明图层以遮挡可能存在于该页面上方其他内容。</li>
<li>授权和身份验证控制：强化用户认证流程、实施多因素身份验证，并且采用最小权限原则，只给予用户必要的权限。</li>
</ol>
<h4 id="js执行上下文和执行栈"><a href="#js执行上下文和执行栈" class="headerlink" title="js执行上下文和执行栈"></a>js执行上下文和执行栈</h4><blockquote>
<ul>
<li><strong>执行上下文</strong> 是代码运行时的环境，可以是全局的或函数的，每个上下文都有自己的变量环境、词法环境和 <code>this</code> 值。</li>
<li><strong>执行栈</strong> 是管理执行上下文的结构，负责跟踪当前正在执行的上下文，以及控制函数调用的顺序。</li>
</ul>
</blockquote>
<p>​	<strong>执行上下文</strong></p>
<p>代表了在某个特定地方运行的代码环境。每当 JavaScript 代码运行时，都会创建一个新的执行上下文。</p>
<ul>
<li>三个主要部分<ul>
<li><strong>变量环境</strong></li>
<li><strong>词法环境</strong></li>
<li><strong><code>this</code> 值</strong></li>
</ul>
</li>
<li>类型<ul>
<li><strong>全局执行上下文</strong></li>
<li><strong>函数执行上下文</strong></li>
<li><strong><code>eval</code> 执行上下文</strong></li>
</ul>
</li>
</ul>
<p>​	<strong>执行栈</strong></p>
<ul>
<li>工作原理<ul>
<li><strong>入栈</strong></li>
<li><strong>出栈</strong></li>
<li><strong>当前上下文</strong></li>
</ul>
</li>
</ul>
<h4 id="函数缓存"><a href="#函数缓存" class="headerlink" title="函数缓存"></a>函数缓存</h4><p>是一种优化技术，用于存储函数计算结果，从而避免重复计算。类似于框架中的计算属性。</p>
<p>​	<strong>应用场景</strong></p>
<ol>
<li>计算密集型函数： 耗时的计算</li>
<li>数据处理或转化：比如格式化日期、字符串处理等，可以缓存已经处理的结果，减少重复处理的开销。</li>
<li>组件渲染</li>
</ol>
<h4 id="js数据结构的了解"><a href="#js数据结构的了解" class="headerlink" title="js数据结构的了解"></a>js数据结构的了解</h4><p>JavaScript 中常用的数据结构主要包括数组、对象、Set、Map、WeakSet 和 WeakMap</p>
<ol>
<li><strong>数组 (Array)</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：有序的元素集合，可以存储任意类型的值。</p>
</li>
<li><p>特性</p>
<p>：</p>
<ul>
<li>动态大小，可以根据需要增加或减少元素。</li>
<li>支持多种数组方法，如 <code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>map</code>、<code>filter</code>等。</li>
<li>数组元素的索引从 0 开始。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：适合用于需要有序存储的数据，例如列表、队列等。</p>
</li>
</ul>
<ol start="2">
<li><strong>对象 (Object)</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：无序的键值对集合，用于存储相关的数据。</p>
</li>
<li><p>特性</p>
<p>：</p>
<ul>
<li>键是字符串（ES6 引入了 Symbol 类型作为键），值可以是任意类型。</li>
<li>对象的属性是动态的，可以随时添加、修改或删除。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：适合用于存储和组织与某个实体相关的信息，例如用户信息、配置选项等。</p>
</li>
</ul>
<ol start="3">
<li><strong>Set</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：代表一组唯一值的集合。</p>
</li>
<li><p>特性</p>
<p>：</p>
<ul>
<li>不允许重复值，自动去重。</li>
<li>支持基本的集合操作：添加、删除、判断是否存在。</li>
<li>迭代时元素的顺序为插入顺序。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：适用于需要保证唯一性的数据集合，例如用户活动记录、标签等。</p>
</li>
</ul>
<ol start="4">
<li><strong>Map</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：一个键值对的集合，其中键可以是任意类型（不局限于字符串）。</p>
</li>
<li><p>特性</p>
<ul>
<li>保持插入的顺序。</li>
<li>支持任何类型的值作为键。</li>
<li>提供了 <code>set</code>、<code>get</code>、<code>has</code>、<code>delete</code> 等方法来操作键值对。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：适合用于需要快速查找和更新的场景，例如存储频繁更新的配置或数据。</p>
</li>
</ul>
<ol start="5">
<li><strong>WeakSet</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：与 Set 类似，但其元素是弱引用。</p>
</li>
<li><p>特性</p>
<ul>
<li>只能存储对象类型的值。</li>
<li>当对象没有引用时，它们可能会被垃圾回收。</li>
<li>没有常规的遍历操作。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：适用于需要存储某些对象的集合，但不想阻止其被垃圾回收的场景。</p>
</li>
</ul>
<ol start="6">
<li><strong>WeakMap</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：与 Map 类似，但其键是弱引用。</p>
</li>
<li><p>特性</p>
<ul>
<li>键只能是对象，值可以是任意类型。</li>
<li>当对象没有其他引用时，可以被垃圾回收。</li>
<li>也没有常规的遍历操作。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：适用于需要关联某些对象数据，但又不希望阻止这些键对象被垃圾回收的场合。</p>
</li>
</ul>
<h4 id="DOM-BOM常见操作"><a href="#DOM-BOM常见操作" class="headerlink" title="DOM&#x2F;BOM常见操作"></a>DOM&#x2F;BOM常见操作</h4><p>DOM 提供了访问和操作 HTML 和 XML 文档的标准接口<br>而 BOM 提供了与浏览器进行交互的方法和接口。</p>
<p><strong>常见 DOM 操作</strong></p>
<ol>
<li><p><strong>选择元素</strong> </p>
<ul>
<li>通过 ID 选择单个元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = document.getElementById(&#x27;myId&#x27;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>通过类名选择多个元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const elements = document.getElementsByClassName(&#x27;myClass&#x27;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>通过标签名选择多个元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const elements = document.getElementsByTagName(&#x27;div&#x27;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>通过 CSS 选择器选择单个元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = document.querySelector(&#x27;.myClass&#x27;);  </span><br></pre></td></tr></table></figure>

<ul>
<li>通过 CSS 选择器选择多个元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const elements = document.querySelectorAll(&#x27;div.myClass&#x27;);  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建和添加元素</strong></p>
<ul>
<li><p>创建新元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const newElement = document.createElement(&#x27;div&#x27;);  </span><br></pre></td></tr></table></figure>
</li>
<li><p>添加子元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const parentElement = document.getElementById(&#x27;parent&#x27;);  </span><br><span class="line">parentElement.appendChild(newElement);  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>修改元素内容和属性</strong></p>
<ul>
<li><p>修改文本内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.textContent = &#x27;新内容&#x27;;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 HTML 内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.innerHTML = &#x27;&lt;span&gt;新内容&lt;/span&gt;&#x27;;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>修改属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.setAttribute(&#x27;class&#x27;, &#x27;newClass&#x27;);  </span><br><span class="line">element.style.color = &#x27;red&#x27;; // 修改样式  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>删除元素</strong></p>
<ul>
<li><p>删除子元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentElement.removeChild(childElement);  </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用remove()方法删除元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.remove();  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>事件处理</strong></p>
<ul>
<li><p>添加事件监听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&#x27;click&#x27;, function() &#123;  </span><br><span class="line">    alert(&#x27;元素被点击了&#x27;);  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>
</li>
<li><p>移除事件监听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.removeEventListener(&#x27;click&#x27;, callback);  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>常见 BOM 操作</strong></p>
<ol>
<li><p><strong>访问浏览器信息</strong></p>
<ul>
<li><p>获取浏览器的用户代理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(navigator.userAgent);  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>控制浏览器窗口</strong></p>
<ul>
<li><p>打开新窗口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open(&#x27;https://www.example.com&#x27;, &#x27;_blank&#x27;);  </span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭当前窗口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.close();  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>定时器</strong></p>
<ul>
<li><p>启动定时器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;  </span><br><span class="line">    alert(&#x27;定时器到期&#x27;);  </span><br><span class="line">&#125;, 2000); // 2秒后弹出提示  </span><br></pre></td></tr></table></figure>
</li>
<li><p>清除定时器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearTimeout(timerId);  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>处理浏览器历史</strong></p>
<ul>
<li><p>前进到历史的下一个页面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.forward();  </span><br></pre></td></tr></table></figure>
</li>
<li><p>返回到历史的上一个页面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.back();  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>操作 URL</strong></p>
<ul>
<li><p>获取当前页面的 URL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(window.location.href);  </span><br></pre></td></tr></table></figure>
</li>
<li><p>跳转到新的 URL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.location.href = &#x27;https://www.example.com&#x27;;  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="浏览器缓存机制-http缓存"><a href="#浏览器缓存机制-http缓存" class="headerlink" title="浏览器缓存机制 - http缓存"></a>浏览器缓存机制 - http缓存</h4><ol>
<li>强缓存：<ul>
<li>强缓存是指浏览器在第一次请求资源时，根据响应头中的缓存策略将资源缓存到本地，并在有效期内直接使用缓存，而不向服务器发送请求。</li>
<li>强缓存可以通过设置响应头中的Cache-Control和Expires来实现：<ul>
<li>Cache-Control：通过设置max-age指令来指定缓存的有效期，单位是秒。例如，Cache-Control: max-age&#x3D;3600 表示资源在客户端缓存1小时。</li>
<li>Expires：指定资源的过期时间，是一个GMT格式的时间字符串。例如，Expires: Tue, 15 Nov 2022 12:00:00 GMT 表示资源在指定时间之后过期。</li>
</ul>
</li>
<li>如果资源命中强缓存，浏览器直接从本地缓存中加载资源，而不会向服务器发送请求，从而提高加载速度。</li>
</ul>
</li>
<li>协商缓存：<ul>
<li>当资源未命中强缓存或强制缓存过期时，浏览器会向服务器发送请求，服务器通过某种方式验证资源是否有更新。</li>
<li>常见的协商缓存机制有：<ul>
<li>Last-Modified &#x2F; If-Modified-Since：服务器在响应头中返回资源的最后修改时间，浏览器在后续请求时通过发送If-Modified-Since头将该时间发送给服务器进行验证。如果服务器判断资源未修改，则返回状态码304 Not Modified，并且浏览器使用本地缓存。</li>
<li>ETag &#x2F; If-None-Match：服务器在响应头中返回资源的唯一标识符（ETag），浏览器在后续请求时通过发送If-None-Match头将该标识符发送给服务器进行验证。如果服务器判断资源未修改，则返回状态码304 Not Modified，并且浏览器使用本地缓存。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="浏览器缓存机制-浏览器缓存-cookie-sessionStorage-localStorage-区别"><a href="#浏览器缓存机制-浏览器缓存-cookie-sessionStorage-localStorage-区别" class="headerlink" title="浏览器缓存机制 - 浏览器缓存 cookie, sessionStorage,localStorage 区别"></a>浏览器缓存机制 - 浏览器缓存 cookie, sessionStorage,localStorage 区别</h4><ol>
<li><strong>Cookie</strong>：<ul>
<li>存储大小：每个cookie的大小通常限制在4KB左右，且每个域名下的cookie数量也有限制。</li>
<li>生命周期：可以设置cookie的过期时间，可以是会话级的（浏览器关闭后失效）或永久的。</li>
<li>作用域：cookie在同源的所有页面之间共享，包括子域名。</li>
<li>用途：主要用于在客户端和服务器之间传递信息，如身份验证、跟踪用户会话等。</li>
</ul>
</li>
<li><strong>sessionStorage</strong>：<ul>
<li>存储大小：通常限制在5MB左右。</li>
<li>生命周期：数据在当前会话期间有效，即在当前会话窗口或标签页关闭前有效。</li>
<li>作用域：每个sessionStorage对象都是独立的，不同页面之间无法共享数据。</li>
<li>用途：适合存储临时数据，如表单数据、临时状态等。</li>
</ul>
</li>
<li><strong>localStorage</strong>：<ul>
<li>存储大小：通常限制在5MB或更大。</li>
<li>生命周期：数据永久存储在浏览器中，除非用户清除或网站代码删除。</li>
<li>作用域：每个localStorage对象都是独立的，不同页面之间无法共享数据。</li>
<li>用途：适合长期存储的数据，如用户偏好设置、本地缓存等。</li>
</ul>
</li>
</ol>
<h4 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h4><p>在浏览器中，事件循环机制通常基于HTML5规范中定义的Event Loop模型。其主要包括以下几个部分：</p>
<ol>
<li><strong>调用栈</strong>：所有的同步任务都会被放入调用栈（call stack）中依次执行，形成一个执行上下文堆栈。</li>
<li><strong>消息队列</strong>：当异步任务完成后或者事件发生时，会将对应的回调函数放入消息队列（message queue）中等待被执行。</li>
<li><strong>事件循环</strong>：当调用栈为空时，会从消息队列中取出一个回调函数放入调用栈进行执行；如果消息队列为空，则等待新的回调函数加入。这样不断地将来自消息队列的任务推送到调用栈执行，这个过程就是所谓的“事件循环”。</li>
<li><strong>宏任务与微任务</strong>：为了更细致地控制异步操作，在每次完成一个宏观任务后都有可能需要去清空微观任务列表。因此对于每一轮循环而言，在取出并执行完一个宏观任务之后还需要检查是否有微观任务需要清空。<ul>
<li><strong>宏任务</strong>：包括整体代码块、setTimeout、setInterval、I&#x2F;O 操作等。宏任务在每次事件循环中只能执行一个，执行完毕后才会执行下一个宏任务。</li>
<li><strong>微任务</strong>：包括 Promise、MutationObserver 等。微任务在每个宏任务执行完毕后立即执行，且在下一个宏任务之前执行完毕。</li>
</ul>
</li>
</ol>
<p>事件循环机制的执行顺序可以总结为：</p>
<ol>
<li>执行当前执行栈中的同步代码。微任务，宏任务加入消息队列</li>
<li>检查微任务队列，依次执行所有微任务。微任务，宏任务加入消息队列</li>
<li>更新渲染（如果需要）。</li>
<li>执行宏任务队列中的一个任务。微任务，宏任务加入消息队列</li>
<li>重复上述步骤。</li>
</ol>
<h4 id="宏任务之间的优先级"><a href="#宏任务之间的优先级" class="headerlink" title="宏任务之间的优先级"></a>宏任务之间的优先级</h4><p>宏任务是指由浏览器提供的任务队列中的任务，例如定时器回调、用户交互事件处理、网络请求等。</p>
<p>在事件循环中，宏任务按照以下优先级依次执行：(各个浏览器厂商可能也有自己特定实现细节。)</p>
<ol>
<li>用户交互相关的宏任务（例如鼠标点击、键盘输入等）：这些任务通常具有最高优先级，因为用户交互响应性对于用户体验非常重要。</li>
<li>定时器和计时器相关的宏任务：这些包括 <code>setTimeout</code>、<code>setInterval</code> 等函数创建的异步操作。</li>
<li>I&#x2F;O 与网络请求相关的宏任务：例如异步加载资源或发送网络请求所产生的回调。</li>
<li>渲染：更新页面渲染所需要执行的宏任务。</li>
</ol>
<h4 id="标签下载、通过接口获取文件缓存中下载有什么区别"><a href="#标签下载、通过接口获取文件缓存中下载有什么区别" class="headerlink" title="&lt;a&gt;标签下载、通过接口获取文件缓存中下载有什么区别"></a><code>&lt;a&gt;</code>标签下载、通过接口获取文件缓存中下载有什么区别</h4><ul>
<li><p><code>&lt;a&gt;</code>标签下载：<br>通过在页面上创建一个 <code>&lt;a&gt;</code> 标签，设置其 <code>href</code> 属性为文件的下载地址，再通过 JavaScript 触发点击事件，即可实现文件的下载。<br>如果是一个预览文件，则可以通过后端响应头上添加文件表示，达到下载目的。或者添加 download属性告诉<code>&lt;a&gt;</code>标签点击执行下载</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 使用&lt;a&gt;标签下载文件 --&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 创建一个&lt;a&gt;标签，设置href属性为文件的下载地址，并通过JavaScript触发点击事件来实现文件下载 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;downloadLink&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com/file.pdf&quot;</span> <span class="attr">download</span>=<span class="string">&quot;filename.pdf&quot;</span>&gt;</span>点击下载文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取下载链接元素  </span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> downloadLink = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;downloadLink&#x27;</span>);  </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 触发点击事件下载文件  </span></span></span><br><span class="line"><span class="language-javascript">    downloadLink.<span class="title function_">click</span>();  </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过接口获取文件缓存中下载：<br>可以通过后端接口返回文件的字节流，客户端收到文件数据后将其转换为Blob对象，再通过URL.createObjectURL()生成文件URL用于下载。(当文件太大时会阻塞)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 通过接口获取文件缓存中下载  </span></span><br><span class="line"><span class="comment">// 通过后端接口返回文件的字节流，转换为Blob对象，并生成文件URL用于下载  </span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/api/download&#x27;</span>, &#123;  </span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,  </span><br><span class="line">&#125;)  </span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">blob</span>()) <span class="comment">// 将response转换为blob对象  </span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">blob</span> =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 生成文件URL  </span></span><br><span class="line">    <span class="keyword">const</span> url = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);  </span><br><span class="line">    <span class="comment">// 创建&lt;a&gt;标签  </span></span><br><span class="line">    <span class="keyword">const</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);  </span><br><span class="line">    a.<span class="property">href</span> = url;  </span><br><span class="line">    a.<span class="property">download</span> = <span class="string">&#x27;filename.pdf&#x27;</span>; <span class="comment">// 设置下载文件名  </span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(a);  </span><br><span class="line">    a.<span class="title function_">click</span>(); <span class="comment">// 触发下载  </span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">revokeObjectURL</span>(url);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="什么是流式下载"><a href="#什么是流式下载" class="headerlink" title="什么是流式下载"></a>什么是流式下载</h4><p>流式下载可通过实现分段请求获取大文件的方式，减轻服务器和客户端的性能压力。客户端会依次请求文件的不同部分，合并成完整文件。而不会将一个大文件完整缓存下来，导致阻塞</p>
<p><strong>步骤</strong></p>
<ol>
<li>发送HTTP请求获取文件的元信息</li>
</ol>
<p>在发起文件下载请求之前，首先需要发送一个HTTP请求，获取文件的元信息，如文件大小和文件类型等。获取文件大小后，可以根据文件大小和设置的数据块大小进行分块下载。</p>
<ol start="2">
<li>设置数据块大小和起始位置</li>
</ol>
<p>一般来说，在文件下载过程中设置数据块的大小是很重要的，数据块的大小越大，下载速度越快，但内存占用也会更多。可以根据数据块的大小和文件大小计算出下载的起始位置和数据块的结束位置。</p>
<ol start="3">
<li>发送HTTP请求下载文件数据块</li>
</ol>
<p>根据起始位置和结束位置，使用HTTP请求下载文件的数据块。请求头中需要设置Range字段，表示下载的数据块的范围。</p>
<ol start="4">
<li>处理下载完成的数据块</li>
</ol>
<p>当下载完成后，需要对下载的数据块进行处理，例如解压缩、合并、处理数据等。</p>
<ol start="5">
<li>将数据块写入文件或进行处理</li>
</ol>
<p>在将数据块写入文件或进行其他处理之前，根据需要进行处理。</p>
<ol start="6">
<li>重复步骤2-5，直到下载完成</li>
</ol>
<p>根据数据块的起始位置和数据块的结束位置，不断重复步骤2-5，直到所有的数据块都下载并处理完成。</p>
<p><strong>案例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起GET请求，流式下载大文件  </span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/api/streamDownload&#x27;</span>, &#123;  </span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,  </span><br><span class="line">&#125;)  </span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;  </span><br><span class="line">        <span class="comment">// 读取文件的内容信息，包括文件长度  </span></span><br><span class="line">        <span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">getReader</span>();  </span><br><span class="line">        <span class="keyword">const</span> contentLength = response.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&#x27;Content-Length&#x27;</span>);  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建Uint8Array，用于存储完整的文件  </span></span><br><span class="line">        <span class="keyword">const</span> file = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="built_in">parseInt</span>(contentLength));  </span><br><span class="line">        <span class="keyword">let</span> offset = <span class="number">0</span>; <span class="comment">// 起始偏移量  </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  </span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">read</span>(<span class="params"></span>) &#123;  </span><br><span class="line">                <span class="comment">// ReadableStream提供的read()方法，可以读取到一个数据chunk，返回一个Promise对象  </span></span><br><span class="line">                reader.<span class="title function_">read</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; done, value &#125;</span>) =&gt;</span> &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (done) &#123;  </span><br><span class="line">                        <span class="comment">// 所有数据读取完毕，完成流式下载  </span></span><br><span class="line">                        <span class="title function_">resolve</span>();  </span><br><span class="line">                        <span class="keyword">return</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将读取到的数据块追加到Uint8Array中  </span></span><br><span class="line">                    file.<span class="title function_">set</span>(value, offset);  </span><br><span class="line">                    offset += value.<span class="property">length</span>;  </span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 递归读取数据块  </span></span><br><span class="line">                    <span class="title function_">read</span>();  </span><br><span class="line">                &#125;).<span class="title function_">catch</span>(reject);  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取第一个数据块，启动读取流程  </span></span><br><span class="line">            <span class="title function_">read</span>();  </span><br><span class="line">        &#125;)  </span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">            <span class="comment">// 将Uint8Array转换为Blob对象  </span></span><br><span class="line">            <span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([file], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/pdf&#x27;</span> &#125;);  </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 生成Blob URL，并模拟点击下载链接，进行下载  </span></span><br><span class="line">            <span class="keyword">const</span> url = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);  </span><br><span class="line">            <span class="keyword">const</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);  </span><br><span class="line">            a.<span class="property">href</span> = url;  </span><br><span class="line">            a.<span class="property">download</span> = <span class="string">&#x27;filename.pdf&#x27;</span>;  </span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(a);  </span><br><span class="line">            a.<span class="title function_">click</span>();  </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//释放Blob URL，避免内存泄漏  </span></span><br><span class="line">            <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">revokeObjectURL</span>(url);  </span><br><span class="line">        &#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="js垃圾回收机制"><a href="#js垃圾回收机制" class="headerlink" title="js垃圾回收机制"></a>js垃圾回收机制</h4><blockquote>
<p>JavaScript的垃圾回收机制是一种自动管理内存的机制，它负责在运行时自动回收不再使用的内存，防止内存泄漏和资源浪费。</p>
</blockquote>
<p>JavaScript的垃圾回收机制主要有以下几种策略：</p>
<ol>
<li>标记-清除（Mark-and-sweep）：<ul>
<li>标记-清除是JavaScript最常用的垃圾回收算法。它通过标记所有能够从根部访问到的对象，然后清除未标记的对象来实现垃圾回收。这个“根”通常指的是全局对象（window对象）以及被全局对象引用的对象。所有不能从根部访问到的对象都将被标记为无法访问，然后进行清除。</li>
</ul>
</li>
<li>引用计数（Reference counting）：<ul>
<li>引用计数的垃圾回收策略是通过对每个对象维护一个引用计数器。当对象被引用时，引用计数器加1；当引用关系被释放时，引用计数器减1。当引用计数为0时，表示对象不再被使用，可以进行回收。不过，引用计数算法难以处理循环引用的情况，因此在实际中较少被使用。</li>
</ul>
</li>
</ol>
<h4 id="内存泄漏是怎么产生的"><a href="#内存泄漏是怎么产生的" class="headerlink" title="内存泄漏是怎么产生的"></a>内存泄漏是怎么产生的</h4><blockquote>
<p>内存泄漏是指程序在运行过程中因为错误的内存管理而导致已经不再使用的内存无法被及时释放，从而造成系统内存占用逐渐增加，最终可能导致系统性能下降甚至崩溃。</p>
</blockquote>
<ol>
<li>未释放不再使用的内存：<ul>
<li>当程序中分配了内存（例如使用new操作符创建对象或数组），但在不再需要这块内存时，没有及时释放（例如通过delete操作符或者释放对对象的引用）。这可能发生在某些特定的代码路径上，例如异常情况下未执行到释放内存的逻辑。</li>
</ul>
</li>
<li>循环引用：<ul>
<li>当两个或多个对象之间存在相互引用，且这些引用之间形成一个循环时，如果这些对象不再被其他代码访问，但由于存在循环引用，垃圾回收机制无法识别并回收这些对象。这样就会导致内存泄漏。</li>
</ul>
</li>
<li>未关闭资源或断开连接：<ul>
<li>在使用一些系统资源（如文件、网络连接、数据库连接等）时，如果在使用完毕后未正确关闭资源或断开连接，就可能导致资源未释放，从而造成内存泄漏。</li>
</ul>
</li>
<li>定时器和事件处理器未正确释放：<ul>
<li>在JavaScript等语言中，如果使用定时器或者绑定事件处理器，但在不再需要时未取消定时器或者解绑事件处理器，就会导致这些资源无法被及时释放，从而造成内存泄漏。</li>
</ul>
</li>
</ol>
<h4 id="sql调优"><a href="#sql调优" class="headerlink" title="sql调优"></a>sql调优</h4><p>SQL 调优是优化 SQL 查询性能的过程，旨在提高查询的执行效率和响应时间</p>
<ol>
<li>确保正确的索引：在频繁用于查询条件或连接的列上创建索引，可以大大提高查询效率。</li>
<li>优化查询语句：避免使用通配符操作符（如 <code>%</code>）开头的模糊查询，尽量使用前缀索引、范围查询等更高效的方式。</li>
<li>减少返回的数据量：只选择需要的列，避免 SELECT *，限制返回的行数，利用 LIMIT 子句进行分页等。</li>
<li>消除冗余查询：尽量避免重复查询相同的数据，利用子查询或者 JOIN 语句合并查询。</li>
<li>使用合适的连接方式：根据查询逻辑选择正确的连接方式，如 INNER JOIN、LEFT JOIN、UNION 等。</li>
<li>避免使用函数和操作符：在 WHERE 子句中避免使用函数和操作符操作查询列，以免影响索引的使用。</li>
<li>优化 SQL 查询顺序：优化 WHERE 子句的顺序，将可过滤掉大量数据的条件放在前面，以尽早筛选不符合条件的数据。</li>
<li>分析查询执行计划：通过 EXPLAIN 命令或其他数据库工具，分析查询执行计划，找出潜在的性能瓶颈和优化点。</li>
<li>增加缓存和缓冲区：合理设置数据库的缓存和缓冲区大小，减少磁盘访问，提高数据读取速度。</li>
</ol>
<h4 id="webworker多线程可以避免阻塞，为什么不把js内容放到webworker运行"><a href="#webworker多线程可以避免阻塞，为什么不把js内容放到webworker运行" class="headerlink" title="webworker多线程可以避免阻塞，为什么不把js内容放到webworker运行"></a>webworker多线程可以避免阻塞，为什么不把js内容放到webworker运行</h4><p>将 JavaScript 代码放到 Web Worker 中运行可以避免阻塞主线程，因为 Web Worker 在单独的线程中运行，不会影响主线程的执行。这对于一些耗时的计算、大量数据处理和复杂的逻辑运算非常有用，可以提高页面的响应性能和用户体验。</p>
<p>但并不是所有的 JavaScript 代码都适合放到 Web Worker 中运行，主要原因有以下几点：</p>
<ol>
<li>Web Worker 无法访问 DOM：由于 Web Worker 运行在一个独立的线程中，无法直接访问 DOM 元素，因此无法进行 DOM 操作。如果 JavaScript 代码需要操作页面的 DOM 结构，就无法放到 Web Worker 中运行。</li>
<li>传递数据复杂：与主线程相比，Web Worker 与主线程之间的通信比较复杂，需要通过 postMessage 进行数据传递。如果需要频繁地传递大量数据，可能会带来额外的开销。</li>
<li>内存消耗问题：每个 Web Worker 都需要一定的内存开销，过多的 Web Worker 可能会导致内存消耗过大，影响页面的性能。</li>
<li>浏览器支持限制：虽然现代浏览器都支持 Web Worker，但并不是所有的浏览器都支持，特别是一些旧版本的浏览器可能存在兼容性问题。</li>
</ol>
<h4 id="SSR服务端渲染"><a href="#SSR服务端渲染" class="headerlink" title="SSR服务端渲染"></a>SSR服务端渲染</h4><p>SSR是一种用于在服务器上渲染网页，将完全渲染后的页面发送给客户端显示的一种技术。它允许服务器生成完整的html标签，包括动态内容。</p>
<p>SSR在服务器已经渲染好网页，发送给客户端，可以改善客户端初始加载时间。完整的html信息可见性，有利于搜索引擎。减少客户端需要下载的数据量。因此有利于带宽低，延迟高的用户</p>
<h4 id="SSR会存在跨域问题吗"><a href="#SSR会存在跨域问题吗" class="headerlink" title="SSR会存在跨域问题吗"></a>SSR会存在跨域问题吗</h4><p>跨域问题通常是指浏览器的同源策略导致的限制，在浏览器中运行的前端代码访问其他域下的资源时可能会受到限制。</p>
<p>对于服务器端渲染（SSR），由于是在服务器端进行页面渲染并直接返回给客户端，一般不会存在跨域问题；如果在服务器端渲染过程中有一些数据需要通过 AJAX 请求获取，那么这些异步数据的请求依然会存在跨域问题。</p>
<p>原因：当使用服务器端渲染时，浏览器向服务器请求页面时，服务器会处理模板和数据，最终返回一段已经渲染好的 HTML 页面。这个 HTML 页面中的所有资源都来自于同一个域名，不会涉及到跨域请求。</p>
<h4 id="前端与后端之间的实时通信的方式"><a href="#前端与后端之间的实时通信的方式" class="headerlink" title="前端与后端之间的实时通信的方式"></a>前端与后端之间的实时通信的方式</h4><p>轮询，SSE(长连接), websocket</p>
<ol>
<li>轮询（Polling）：轮询是一种简单粗暴的实时通信方式，客户端定时发送请求询问服务器是否有新的数据。虽然实现简单，但效率低下且会导致无谓的网络流量和服务器负担。</li>
<li>SSE（Server-Sent Events，服务器推送事件）：SSE 是一种基于单向事件流的实时通信机制，允许服务器向客户端推送数据。与轮询相比，SSE更加高效，无需频繁地发送请求，能够实现服务器主动向客户端推送数据。</li>
<li>WebSocket：WebSocket 是一种全双工通信协议，可以在客户端和服务器之间建立持久性的连接，实现实时的双向通信。与HTTP和SSE不同，WebSocket连接一旦建立，客户端和服务器可以随时发送消息而不需要经过频繁的握手，适用于需要高度实时性和频繁交互的场景。</li>
</ol>
<h4 id="讲讲websocket怎么使用，怎么实现"><a href="#讲讲websocket怎么使用，怎么实现" class="headerlink" title="讲讲websocket怎么使用，怎么实现"></a>讲讲websocket怎么使用，怎么实现</h4><p>WebSocket是一种在单个TCP连接上进行全双工通信的协议，特点是可以实现实时的数据传输</p>
<ol>
<li><p>创建WebSocket连接： 首先，通过JavaScript创建一个WebSocket对象并指定要连接的服务器URL。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听WebSocket事件：WebSocket对象提供了多种事件钩子，可以监听连接打开、消息接收、连接关闭等事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="property">onopen</span> = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket连接已打开&#x27;</span>);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">socket.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到消息：&#x27;</span>, event.<span class="property">data</span>);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">socket.<span class="property">onclose</span> = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket连接已关闭&#x27;</span>);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">socket.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket连接出现错误&#x27;</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送和接收消息： 可以使用<code>send()</code>方法向服务器发送消息，并用<code>onmessage</code>事件处理服务器返回的消息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息  </span></span><br><span class="line">socket.<span class="title function_">send</span>(<span class="string">&#x27;Hello, server!&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收消息，在onmessage事件处理  </span></span><br><span class="line">socket.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到消息：&#x27;</span>, event.<span class="property">data</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭WebSocket连接： 当不再需要连接时，可以使用<code>close()</code>方法来关闭WebSocket连接</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<p>案例：</p>
<ol>
<li><p>心跳检测：<br>心跳检测是通过定期向服务器发送一个特定的消息来检测连接状态。如果服务器接收到了心跳消息，就说明连接是活动的，如果一段时间内没有收到心跳消息，服务器可以认为连接已断开。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时发送心跳消息  </span></span><br><span class="line"><span class="keyword">const</span> heartCheck = &#123;  </span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span>, <span class="comment">// 心跳间隔时间，单位毫秒  </span></span><br><span class="line">  <span class="attr">timer</span>: <span class="literal">null</span>,  </span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">      socket.<span class="title function_">send</span>(<span class="string">&#x27;Heartbeat&#x27;</span>);  </span><br><span class="line">    &#125;, <span class="variable language_">this</span>.<span class="property">timeout</span>);  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="title function_">stop</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在连接打开时开始心跳检测  </span></span><br><span class="line">socket.<span class="property">onopen</span> = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  heartCheck.<span class="title function_">start</span>();  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到消息时重置心跳检测  </span></span><br><span class="line">socket.<span class="property">onmessage</span> = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  heartCheck.<span class="title function_">stop</span>();  </span><br><span class="line">  heartCheck.<span class="title function_">start</span>();  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>断线重连：<br>断线重连是在检测到连接断开后，尝试重新建立连接以保持通信的功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重连函数  </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reConnect</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">if</span> (socket.<span class="property">readyState</span> !== <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;  </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">      socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080&#x27;</span>);  </span><br><span class="line">      <span class="comment">// 重新绑定事件监听  </span></span><br><span class="line">      socket.<span class="property">onopen</span> = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket连接已重新建立&#x27;</span>);  </span><br><span class="line">        heartCheck.<span class="title function_">start</span>(); <span class="comment">// 重新开始心跳检测  </span></span><br><span class="line">      &#125;;  </span><br><span class="line">      socket.<span class="property">onclose</span> = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket连接已关闭&#x27;</span>);  </span><br><span class="line">        <span class="title function_">reConnect</span>(); <span class="comment">// 断线重连  </span></span><br><span class="line">      &#125;;  </span><br><span class="line">    &#125;, <span class="number">3000</span>); <span class="comment">// 3秒后尝试重连  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在连接关闭时尝试重连  </span></span><br><span class="line">socket.<span class="property">onclose</span> = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket连接已关闭&#x27;</span>);  </span><br><span class="line">  <span class="title function_">reConnect</span>();  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="JWT认证过程"><a href="#JWT认证过程" class="headerlink" title="JWT认证过程"></a>JWT认证过程</h4><p>JWT 的认证过程基于 Token，其中包含了被加密的用户信息和签名，使得服务器端无需在每次请求中都查询数据库或者使用 Session 来进行身份验证。客户端使用 JWT 值来标识和验证用户的身份，从而完成认证和权限控制。</p>
<p>认证过程如下：</p>
<ol>
<li>客户端发送登录请求（通常是用户名和密码）到服务器端。</li>
<li>服务器端验证用户的身份和密码是否正确。</li>
<li>如果验证通过，服务器端生成一个 JWT，并将其发送回客户端。</li>
<li>客户端收到 JWT 后，将其保存在本地（通常是在 localStorage 或者 Cookie 中）。</li>
<li>客户端在每次请求需要认证的资源时，将 JWT 放入请求头（通常是在 Authorization 头部字段中）一同发送到服务器端。</li>
<li>服务器端收到请求后，从请求头中提取 JWT。</li>
<li>服务器端对 JWT 进行验证和解析，检查签名是否合法、是否过期等。</li>
<li>如果验证通过，服务器端根据 JWT 中的信息进行相应的操作，并返回资源或执行对应的业务逻辑。</li>
</ol>
<h4 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h4><p>使用 HTTPS 协议：确保数据传输过程中是加密的。HTTPS 可以保护数据在客户端和服务器之间的传输安全，并且在网络抓包时无法直接查看明文数据。</p>
<p>前端对密码进行加密：在用户输入密码后，前端可以对密码进行加密处理（例如使用哈希函数），然后将加密后的密码发送到服务器。这样即使接口被拦截，在网络请求中也只能看到经过加密处理的数据而不是明文密码。</p>
<h4 id="讲解一下promise"><a href="#讲解一下promise" class="headerlink" title="讲解一下promise"></a>讲解一下promise</h4><p>Promise 是 JavaScript 中的一种异步编程解决方案，解决了回调函数执行异步操作的回调地狱问题。它可以让我们更方便地处理异步操作。Promise 有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p>
<p>Promise 处于 pending 状态时，可以通过调用 resolve 函数将其状态改为 fulfilled，或者通过调用 reject 函数将其状态改为 rejected。</p>
<p>当 Promise 状态改变后，就会执行对应的回调函数，即 then 方法中的第一个参数或 catch 方法中的参数。</p>
<h4 id="promise后面如果有多个值，-then-怎么传值"><a href="#promise后面如果有多个值，-then-怎么传值" class="headerlink" title="promise后面如果有多个值，.then() 怎么传值"></a>promise后面如果有多个值，.then() 怎么传值</h4><p>在 Promise 中，可以通过使用链式调用的方式，多次调用 <code>.then()</code> 方法来处理多个值。每个 <code>.then()</code> 方法可以接收前一个 Promise 的结果，并返回一个新的 Promise，从而可以实现值的传递。</p>
<h4 id="async-await理解"><a href="#async-await理解" class="headerlink" title="async await理解"></a>async await理解</h4><p><code>async/await</code> 是 ES8（ECMAScript 2017）引入的异步编程模型，是建立在 Promise 之上的语法糖，让异步代码看起来更像同步代码，更易于理解和编写。<code>async</code> 函数用于定义一个异步函数，<code>await</code> 关键字用于等待一个 Promise 对象（通常是一个异步操作），等待完成后再执行后续的代码。</p>
<p><strong><code>async</code> 函数声明：</strong> 使用 <code>async</code> 关键字声明一个函数时，该函数会自动返回一个 Promise 对象。</p>
<p><strong><code>await</code> 表达式：</strong> 在 <code>async</code> 函数中，可以使用 <code>await</code> 关键字来暂停函数的执行，等待 Promise 对象的状态改变。</p>
<p><strong>错误处理：</strong> 使用 <code>try/catch</code> 结构可以捕获 <code>async/await</code> 中的异常。在 <code>try</code> 代码块中放置可能抛出异常的代码，而在 <code>catch</code> 代码块中处理异常情况。</p>
<h4 id="async-await比promise有什么优势"><a href="#async-await比promise有什么优势" class="headerlink" title="async await比promise有什么优势"></a>async await比promise有什么优势</h4><ol>
<li><strong>更直观的代码结构：</strong> <code>async/await</code> 使异步代码看起来更像同步代码，使得代码结构更加直观和易于理解。通过使用 <code>await</code> 关键字，可以在代码中明确地指定等待异步操作的结果，而不需要使用回调函数或链式调用。</li>
<li><strong>更容易处理错误：</strong> 在使用 <code>async/await</code> 时，可以使用 <code>try/catch</code> 结构来捕获和处理异常。这使得错误处理更加简洁和可读，而不需要在每个 Promise 链中都使用 <code>.catch()</code> 方法来处理错误。</li>
<li><strong>更好的错误堆栈追踪：</strong> <code>async/await</code> 可以提供更好的错误堆栈追踪，使得在出现错误时更容易定位问题所在。相比于 Promise 的链式调用，<code>async/await</code> 可以在出错的地方直接抛出异常，而不需要在每个 <code>.then()</code> 方法中手动抛出错误。</li>
<li><strong>更灵活的控制流：</strong> <code>async/await</code> 允许使用常规的控制流语句（如条件语句和循环语句），使得在异步操作之间进行逻辑控制更加灵活。这使得编写复杂的异步代码变得更加容易。</li>
</ol>
<h4 id="async-await的底层原理"><a href="#async-await的底层原理" class="headerlink" title="async await的底层原理"></a>async await的底层原理</h4><p>底层原理其实是基于 Promise 和生成器（Generator）的。</p>
<ol>
<li><code>async</code> 函数本质上是返回一个 Promise 对象，这个 Promise 对象的状态和值由 <code>async</code> 函数内部的代码决定。</li>
<li>在 <code>async</code> 函数内部使用 <code>await</code> 关键字时，其后的表达式会被封装为一个 Promise 对象，并等待该 Promise 对象的状态改变。</li>
<li>当 <code>await</code> 后面的 Promise 对象变为 resolved（已解决）状态时，<code>await</code> 表达式会返回 Promise 对象的解决值，然后程序会继续执行 <code>await</code> 后面的代码。</li>
<li>如果 <code>await</code> 后面的 Promise 对象变为 rejected（拒绝）状态，则会抛出一个异常，可以使用 <code>try/catch</code> 来捕获并处理异常。</li>
<li>生成器函数允许函数在执行过程中暂停，并在需要时回复。<code>async/await</code> 在底层会使用生成器函数来实现异步操作的暂停和回复。</li>
</ol>
<h4 id="generator的原理"><a href="#generator的原理" class="headerlink" title="generator的原理"></a>generator的原理</h4><p>Generator 是 JavaScript 中的一种特殊函数，它可以在执行过程中暂停并恢复。Generator 函数使用 <code>function*</code> 关键字进行声明，并使用 <code>yield</code> 关键字来定义暂停点。</p>
<p>Generator 函数的原理是通过迭代器（Iterator）的概念来实现的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">myGenerator</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;  </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;  </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = <span class="title function_">myGenerator</span>();  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="pnpm软连接和硬链接区别"><a href="#pnpm软连接和硬链接区别" class="headerlink" title="pnpm软连接和硬链接区别"></a>pnpm软连接和硬链接区别</h4><p>软链接（Symbolic Link）和硬链接（Hard Link）是在文件系统中用于创建链接到文件或目录的两种不同方式。</p>
<p>软链接（Symbolic Link）：</p>
<ol>
<li>软链接是一个独立的文件，其中包含一个指向另一个文件或目录的路径（绝对路径或相对路径）。</li>
<li>创建软链接时，源文件和链接之间是两个不同的文件，源文件的内容不会被复制到链接文件中，只是通过路径关联。</li>
<li>软链接可以跨文件系统，即可以跨越不同的物理硬盘或分区。</li>
<li>当源文件被删除或移动，软链接仍然保留，但软链接失效。</li>
<li>软链接可以用来创建指向文件或目录的符号链接。</li>
</ol>
<p>硬链接（Hard Link）：</p>
<ol>
<li>硬链接是文件系统中对同一个文件或目录的多个链接，它们共享相同的数据块。</li>
<li>创建硬链接时，不会创建新的文件，只是在文件系统中创建一个新的目录条目指向相同的 inode 节点。</li>
<li>硬链接只能在同一个文件系统中创建，即源文件和硬链接需要在同一文件系统内。</li>
<li>当所有硬链接都被删除后，文件才会被完全删除，并释放磁盘空间。</li>
<li>硬链接不能指向目录，只能指向文件。</li>
</ol>
<h4 id="pnpm-hoist机制"><a href="#pnpm-hoist机制" class="headerlink" title="pnpm hoist机制"></a>pnpm hoist机制</h4><p>pnpm 的 hoist 机制是一种优化依赖结构的方式，旨在减少存储空间和提高性能。<br>在传统的 npm 或者 Yarn 安装方式中，每个项目都会在其根目录下创建一个 node_modules 目录，并将所有的依赖包都安装在其中。这样的结果是，不同的项目会包含相同的依赖包的多个副本，造成存储空间的浪费。<br>而 pnpm 的 hoist 机制则将多个项目的依赖包按照相同的版本整理到一个公共的存储位置（称为 store）。具体来说，当一个包被多个项目依赖时，pnpm 会自动将这个包安装到存储位置，并创建软链接到各个项目的 node_modules 目录下。</p>
<p>流程：</p>
<ol>
<li>安装过程中，当 pnmp 发现某个依赖包在多个项目中重复出现时，它将该依赖包安装到公共存储位置（store）中，并为每个项目创建一个软链接到依赖包。</li>
<li>对于每个项目，pnpm 会在其根目录下创建一个特殊的 <code>.pnpm</code> 目录，该目录下包含一个 packages 软链接文件夹，其中存储了所有项目所依赖的包的软链接。</li>
<li>当项目需要使用某个依赖包时，pnpm 会根据软链接的路径找到对应的包。</li>
</ol>
<p>优点：</p>
<ul>
<li>节省存储空间：依赖包只会被下载一次，多个项目共享一个副本。</li>
<li>提高性能：在安装和更新依赖时，减少了 I&#x2F;O 操作，更快地完成配置。</li>
</ul>
<p>缺点：</p>
<p>pnpm hoist 机制可能会在某些情况下引发依赖冲突问题。在这种情况下，可以使用 pnmp 提供的工具来解决冲突，如 <code>pnpm recursive list</code> 可以列出所有项目的依赖关系树，并帮助找到冲突的依赖包版本。</p>
<h4 id="pnpm包的结构，三层寻址"><a href="#pnpm包的结构，三层寻址" class="headerlink" title="pnpm包的结构，三层寻址"></a>pnpm包的结构，三层寻址</h4><p>pnpm 是一个基于 npm 的包管理工具</p>
<p>它的包结构和寻址分为以下几层：</p>
<ol>
<li>根目录层：根目录层是指项目的根目录，也是 package.json 文件所在的目录。这一层主要包含一个 package.json 文件，用来记录项目的依赖关系和其他相关配置信息。</li>
<li>存储目录层：存储目录层是指存放依赖包代码的目录。pnpm 的存储目录层并不是像 npm 那样将所有依赖包放在一个统一的目录下，而是根据依赖包的名称、版本和 hash 值来生成不同的路径存放不同的依赖包。这样的做法可以有效减少存储空间的使用，同时也保证了依赖包的唯一性。</li>
<li>软链接层：软链接层是指通过软链接将依赖包连接到项目的 node_modules 目录下。当代码需要引用依赖包时，实际上是通过软链接层来找到依赖包的代码。pnpm 使用软链接的方式可以减少重复的依赖包拷贝，同时提供了更快更节省空间的安装和运行速度。</li>
</ol>
<p><strong>三层寻址</strong></p>
<p>三层寻址的过程如下：</p>
<ol>
<li>从根目录的 package.json 文件中读取项目的依赖关系。</li>
<li>根据依赖包的名称和版本等信息，在存储目录层中查找对应的依赖包。</li>
<li>将找到的依赖包通过软链接层连接到项目的 node_modules 目录下。</li>
</ol>
<p>通过三层寻址，可以在保证依赖包唯一性的同时，提高包的安装和运行效率。</p>
<h4 id="什么事幽灵依赖，会引发什么问题"><a href="#什么事幽灵依赖，会引发什么问题" class="headerlink" title="什么事幽灵依赖，会引发什么问题"></a>什么事幽灵依赖，会引发什么问题</h4><p>幽灵依赖是指在项目中存在但未在 package.json 文件中明确声明的依赖包或依赖关系。这种情况通常发生在项目代码中引入了某些依赖包，但没有及时在 package.json 文件中添加对应的依赖项。</p>
<p>会引发以下问题：</p>
<ol>
<li>不稳定的构建：由于幽灵依赖没能被明确标识在 package.json 文件中，项目的构建可能会出现不稳定性。每次安装依赖包时，依赖关系可能会发生变化，导致构建结果不一致。</li>
<li>版本不一致：没有在 package.json 中明确声明依赖关系可能会导致依赖包的版本不一致。在不同的环境中，可能会出现依赖包的不同版本被使用，从而导致代码在不同环境下表现不一致或出现功能错误。</li>
<li>安全隐患：幽灵依赖可能会带来安全隐患。如果项目中存在未声明的依赖包，且这些依赖包存在安全漏洞，攻击者可能会利用这些漏洞对项目进行攻击或注入恶意代码。</li>
<li>维护困难：在项目中存在大量幽灵依赖会增加代码的维护难度。随着项目的变大，难以追踪项目实际使用的依赖包，导致代码可读性和可维护性降低</li>
</ol>
<h4 id="package-A-和package-B-依赖同一个包，却不同版本，如何统一版本"><a href="#package-A-和package-B-依赖同一个包，却不同版本，如何统一版本" class="headerlink" title="package A 和package B 依赖同一个包，却不同版本，如何统一版本"></a>package A 和package B 依赖同一个包，却不同版本，如何统一版本</h4><ol>
<li>升级包：查看 A、B 两个包所依赖的包 C 分别的版本范围，如果范围存在交集，可以尝试将 A、B 中所依赖的包 C 版本范围升级到一个兼容的、相同的版本。这可以通过修改 A、B 的 package.json 文件中对包 C 的版本范围进行修改来实现。然后重新安装依赖并测试，确保项目能够正常运行。</li>
<li>更新依赖：如果升级包 C 的版本并不可行，可以尝试升级 A、B 包本身，以便它们能依赖同一个包 C 的相同版本。这可以通过修改 A、B 的 package.json 文件中对自身的版本范围进行修改来实现。然后重新安装依赖并测试，确保项目能够正常运行。</li>
<li>分别安装依赖包：如果无法升级包 C 的版本或者升级包 A、B 的版本也不可行，可以尝试分别安装依赖包。也就是说，分别为包 A 和包 B 创建独立的依赖环境，让它们各自安装自己所需要的依赖包版本。然后在使用它们的地方通过注入或者模块引入来分别使用对应的依赖包。</li>
<li>重构代码：如果无法统一版本，也无法分别安装依赖包，可能就需要进行代码重构了。通过重构代码，考虑使用兼容不同版本的 API 或者替代性的包来解决依赖不一致的问题。</li>
</ol>
<h4 id="关于浏览器渲染原理，重排"><a href="#关于浏览器渲染原理，重排" class="headerlink" title="关于浏览器渲染原理，重排"></a>关于浏览器渲染原理，重排</h4><p>重排（reflow）是浏览器在绘制页面时的一个重要概念。当页面发生布局变化时（如改变元素宽高、位置、字体大小等），浏览器需要重新计算元素的布局信息，并重新绘制页面。这个过程就是重排。</p>
<p>重排的代价很高，会导致页面的性能下降，因此我们应尽量减少重排的次数。<br><em>常见引起重排的操作有：</em></p>
<ol>
<li>修改 DOM 结构：如增删节点、修改节点顺序等；</li>
<li>改变元素位置和尺寸：如改变元素的位置、大小、边距、内填充等；</li>
<li>修改样式：如改变元素的背景颜色、字体大小、文字颜色等；</li>
<li>查询 DOM 元素的位置、尺寸等信息：如调用 offsetWidth、offsetHeight、scrollTop、scrollLeft 等属性。</li>
</ol>
<p><em>为了尽量减少重排，我们可以采取以下措施：</em></p>
<ol>
<li>将多次重排操作合并为一次：比如通过改变元素的 class 来一次性修改多个样式；</li>
<li>避免读取布局信息：尽量避免频繁读取 DOM 元素的位置和尺寸信息；</li>
<li>使用文档片段进行离线处理：将需要生成大量 DOM 元素的操作暂时放入文档片段中，完成后再一次性插入到页面中；</li>
<li>使用绝对定位的元素：需要频繁改变位置的元素最好采用绝对定位，避免引起其他元素的重排。</li>
</ol>
<h4 id="组件库怎么做，怎么实现"><a href="#组件库怎么做，怎么实现" class="headerlink" title="组件库怎么做，怎么实现"></a>组件库怎么做，怎么实现</h4><h4 id="如何看待框架，相比原生解决了什么问题"><a href="#如何看待框架，相比原生解决了什么问题" class="headerlink" title="如何看待框架，相比原生解决了什么问题"></a>如何看待框架，相比原生解决了什么问题</h4><h4 id="VDOM是什么，相比原生对比为什么要使用VDOM"><a href="#VDOM是什么，相比原生对比为什么要使用VDOM" class="headerlink" title="VDOM是什么，相比原生对比为什么要使用VDOM"></a>VDOM是什么，相比原生对比为什么要使用VDOM</h4><p>虚拟DOM，相比起直接操作真实的 DOM，使用 VDOM 的方式有以下几个优点：</p>
<ol>
<li>性能优化：直接操作 DOM 可能会导致频繁的重排和重绘，而 VDOM 通过在内存中构建一颗虚拟的 DOM 树，并将其与真实 DOM 进行比较，只更新有变化的部分，从而减少了不必要的 DOM 操作，提高了性能。</li>
<li>跨平台兼容性：VDOM 是对 DOM 结构的抽象，不依赖于具体的平台或浏览器实现，因此可以在不同平台上保持一致性，并提供良好的跨浏览器兼容性。</li>
<li>简化开发流程：使用 VDOM 可以更方便地进行组件化开发，并提供了一种数据驱动的方式来更新视图，代码更加清晰、易于理解和维护。</li>
<li>方便的状态管理：VDOM 结合了框架本身的状态管理机制，可以实现方便的状态管理和组件间的通信，提供了更好的代码组织和复用能力。</li>
</ol>
<p>但也有一些缺点，比如会引入一定的性能损耗，以及需要额外的代码来处理 VDOM 的生成和比较等。</p>
<h4 id="AST是什么"><a href="#AST是什么" class="headerlink" title="AST是什么"></a>AST是什么</h4><p>AST（Abstract Syntax Tree）是一种数据结构，用于表示程序代码的抽象语法结构。AST 可以帮助开发者理解和分析代码，以及进行静态分析、代码转换和优化等操作。</p>
<h4 id="BST是什么"><a href="#BST是什么" class="headerlink" title="BST是什么"></a>BST是什么</h4><p>BST（Binary Search Tree）是一种常见的数据结构，用于存储和组织数据。BST 是一种二叉树，其中每个节点最多有两个子节点。BST 通常用于实现搜索、插入和删除操作的高效数据结构。</p>
<h4 id="使用BST实现-包括insert，search，delete"><a href="#使用BST实现-包括insert，search，delete" class="headerlink" title="使用BST实现 包括insert，search，delete"></a>使用BST实现 包括insert，search，delete</h4><h3 id="ES6-HTML5-CSS3-新特性"><a href="#ES6-HTML5-CSS3-新特性" class="headerlink" title="ES6+,HTML5,CSS3 新特性"></a>ES6+,HTML5,CSS3 新特性</h3><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6+"></a>ES6+</h4><ol>
<li>let 和 const 声明<ul>
<li>引入块级作用域的 let 和不可变的常量 const，替代 var 关键字。</li>
</ul>
</li>
<li>箭头函数<ul>
<li>使用箭头（&#x3D;&gt;）定义匿名函数，简化了函数的写法。</li>
</ul>
</li>
<li>默认参数值<ul>
<li>在定义函数时可以给参数提供默认值。</li>
</ul>
</li>
<li>解构赋值<ul>
<li>可以从数组或对象中进行解构赋值，方便地提取数据。</li>
</ul>
</li>
<li>扩展运算符<ul>
<li>使用三个点（…）可以将一个数组扩展为另一个数组中的元素或将对象的属性复制到另一个对象中。</li>
</ul>
</li>
<li>类和继承<ul>
<li>引入了 class 关键字，支持了面向对象编程的语法糖。</li>
</ul>
</li>
<li>模块化<ul>
<li>引入了 import 和 export 关键字，支持了模块化的语法。</li>
</ul>
</li>
<li>Promise<ul>
<li>引入了Promise对象，用于更加方便地处理异步操作。</li>
</ul>
</li>
<li>简化的对象字面量语法<ul>
<li>允许在对象中直接使用变量名字作为属性名。</li>
</ul>
</li>
<li>模板字符串<ul>
<li>使用反引号（&#96;）包裹的字符串，支持了字符串内插和多行字符串。</li>
</ul>
</li>
</ol>
<h4 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h4><ol>
<li>语义化元素：<ul>
<li>引入了一系列语义化的标签，如header、footer、nav、section等，用于更好地描述页面结构，提升可读性和可访问性。</li>
</ul>
</li>
<li>媒体支持：<ul>
<li>引入了新的媒体元素，如<video>和<audio>，用于直接在网页中嵌入视频和音频内容，减少对第三方插件的依赖。</audio></video></li>
</ul>
</li>
<li>Canvas绘图：<ul>
<li>提供了<canvas>标签和相应的JavaScript API，可以使用JavaScript在网页上绘制图形、动画和游戏等。</canvas></li>
</ul>
</li>
<li>SVG图形：<ul>
<li>引入了对可缩放矢量图形（SVG）的原生支持，可以在网页上使用SVG格式的图形进行渲染和交互。</li>
</ul>
</li>
<li>WebSocket和WebRTC：<ul>
<li>引入了WebSocket和WebRTC API，用于实现在客户端和服务器之间进行实时双向通信和音视频通信的功能。</li>
</ul>
</li>
<li>本地存储：<ul>
<li>引入了localStorage和sessionStorage API，可以在客户端存储数据，支持长期保存和会话期间使用。</li>
</ul>
</li>
<li>地理定位：<ul>
<li>提供了Geolocation API，可以获取用户的地理位置信息，用于实现位置相关的应用和服务。</li>
</ul>
</li>
<li>表单增强：<ul>
<li>引入了一些新的表单类型和属性，如input的type属性新增了email、number等类型，表单验证和表单自动完成等功能得到改进。</li>
</ul>
</li>
<li>拖放：<ul>
<li>提供了拖放API，可以通过JavaScript实现元素的拖放操作。</li>
</ul>
</li>
<li>多线程和Web Workers：<ul>
<li>引入了Web Workers API，允许浏览器在后台创建独立的工作线程，可以执行复杂的计算任务，提升性能和响应能力。</li>
</ul>
</li>
</ol>
<h4 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h4><ol>
<li>选择器：<ul>
<li>引入了更多的CSS选择器，如属性选择器、伪类选择器等，提供了更多样的选择元素的方式。</li>
</ul>
</li>
<li>盒模型：<ul>
<li>引入了box-sizing属性，可以更方便地控制盒子的尺寸计算方式，包括content-box和border-box。</li>
</ul>
</li>
<li>背景和边框：<ul>
<li>提供了更多的背景属性，如背景渐变、背景尺寸控制等，以及更多的边框样式和边框阴影效果。</li>
</ul>
</li>
<li>字体：<ul>
<li>引入了@font-face规则，允许网页设计师使用自定义字体，并且支持Web字体格式。</li>
</ul>
</li>
<li>2D&#x2F;3D转换和动画：<ul>
<li>引入了transform属性和transition属性，可以通过CSS进行元素的旋转、缩放、倾斜等2D和3D变换，以及实现过渡和动画效果。</li>
</ul>
</li>
<li>Flexbox布局：<ul>
<li>引入了弹性盒子布局（Flexbox），用于实现灵活的布局和对齐方式，适应各种屏幕尺寸和设备。</li>
</ul>
</li>
<li>Grid布局：<ul>
<li>提供了网格布局（Grid Layout），可以更方便地实现复杂的网格化布局，支持多列和多行的网格化设计。</li>
</ul>
</li>
<li>媒体查询：<ul>
<li>引入了媒体查询（Media Queries），可以根据设备屏幕宽度、高度、方向等特性，为不同的设备提供不同的样式。</li>
</ul>
</li>
<li>过渡效果（transitions）：<ul>
<li>允许开发者在状态变化时实现平滑的过渡效果，比如鼠标滑过后颜色渐变。</li>
</ul>
</li>
<li>伸缩容器（Sizing Units）：<ul>
<li>引入了更多新的长度单位，如vw、vh、vmin、vmax，使得元素的大小可以相对于视口的尺寸来计算。</li>
</ul>
</li>
</ol>
<h3 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h3><h4 id="Electron软件自动更新操作"><a href="#Electron软件自动更新操作" class="headerlink" title="Electron软件自动更新操作"></a>Electron软件自动更新操作</h4><p>步骤：</p>
<ol>
<li>创建一个更新服务器：首先需要在服务器上托管您的应用程序安装文件和更新文件。您可以选择使用自己的服务器或第三方服务如GitHub Releases等。</li>
<li>配置应用程序：在Electron应用程序中，您需要配置自动更新功能。您可以使用Electron提供的自动更新模块<code>autoUpdater</code>来实现。</li>
<li>添加更新逻辑：在应用程序启动时，可以检查是否有新版本可用。您可以从服务器获取最新版本的信息，并与当前应用程序的版本进行比较。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, autoUpdater &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);  </span><br><span class="line"></span><br><span class="line">autoUpdater.<span class="title function_">setFeedURL</span>(&#123;  </span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;https://example.com/releases&#x27;</span>,  </span><br><span class="line">  <span class="attr">provider</span>: <span class="string">&#x27;github&#x27;</span>  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">autoUpdater.<span class="title function_">on</span>(<span class="string">&#x27;update-available&#x27;</span>, <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  <span class="comment">// 有新版本可用  </span></span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">autoUpdater.<span class="title function_">on</span>(<span class="string">&#x27;update-downloaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  <span class="comment">// 新版本已下载完成  </span></span><br><span class="line">  autoUpdater.<span class="title function_">quitAndInstall</span>();  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;ready&#x27;</span>, <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  autoUpdater.<span class="title function_">checkForUpdates</span>();  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="请介绍一下你对Electron的理解以及你的工作经验。"><a href="#请介绍一下你对Electron的理解以及你的工作经验。" class="headerlink" title="请介绍一下你对Electron的理解以及你的工作经验。"></a>请介绍一下你对Electron的理解以及你的工作经验。</h4><p>Electron是由GitHub开发的开源框架，用于构建跨平台的桌面应用程序。它使用Web技术（HTML、CSS和JavaScript）来构建应用程序，并将其封装在一个独立的容器中，以便在桌面操作系统（如Windows、Mac和Linux）上运行。</p>
<h4 id="Electron-优缺点"><a href="#Electron-优缺点" class="headerlink" title="Electron 优缺点"></a>Electron 优缺点</h4><p>优点：</p>
<ol>
<li>跨平台能力：Electron可以让开发者使用一套代码构建在多个操作系统上运行的桌面应用程序，大大简化了跨平台开发的复杂性。</li>
<li>使用Web技术：Electron基于Web技术，如HTML、CSS和JavaScript，开发者可以使用熟悉的工具和技术栈构建应用程序，减少了学习成本和开发周期。</li>
<li>强大的生态系统：Electron拥有庞大的开发者社区和丰富的第三方库，提供了丰富的资源和解决方案，方便开发者快速构建和定制应用程序。</li>
<li>系统级访问：Electron提供了访问操作系统特定功能的API，如文件系统、网络请求、系统通知、窗口管理等，可以满足应用程序的各种功能需求。</li>
<li>自定义界面：Electron允许开发者完全自定义应用程序的用户界面，从窗口样式到菜单、工具栏等，可以实现个性化的用户体验。</li>
<li>自动更新功能：Electron提供了自动更新功能，方便开发者向用户提供新版本和修复程序，保持应用程序的稳定性和安全性。</li>
</ol>
<p>缺点：</p>
<ol>
<li>资源占用较高：由于Electron封装了Chromium和Node.js，应用程序会占用较高的系统资源，包括内存和存储空间。</li>
<li>文件大小较大：由于Electron打包了整个Web运行环境，应用程序的安装包较大，可能会增加用户下载和安装的时间。</li>
<li>性能问题：尽管Electron在桌面环境下具有很好的性能，但与原生应用程序相比，仍然存在一定程度的性能差距。</li>
<li>安全性问题：由于使用Web技术开发，Electron的应用程序可能面临一些Web安全问题，如跨站脚本攻击等，需要开发者在设计和开发过程中重视安全性。</li>
</ol>
<h4 id="什么是Electron（原子）框架？它是如何工作的？"><a href="#什么是Electron（原子）框架？它是如何工作的？" class="headerlink" title="什么是Electron（原子）框架？它是如何工作的？"></a>什么是Electron（原子）框架？它是如何工作的？</h4><p>Electron框架的工作原理如下：</p>
<ol>
<li>渲染进程（Renderer Process）：在Electron应用程序中，每个窗口被称为一个渲染进程，它运行在Chromium浏览器的渲染进程中。这些渲染进程负责加载和显示应用程序的界面，以及处理与用户界面交互的逻辑。</li>
<li>主进程（Main Process）：除了渲染进程外，Electron应用程序还有一个主进程，它是应用程序的控制中心，负责管理应用程序的整体生命周期、窗口管理、系统级访问等功能。</li>
<li>渲染进程与主进程通信：渲染进程和主进程之间可以通过Electron提供的IPC（Inter-Process Communication）机制进行通信，以实现不同进程之间的数据交换和功能调用。</li>
<li>Node.js运行时环境：Electron集成了Node.js运行时环境，使开发者可以在应用程序中使用Node.js的模块和功能，如访问文件系统、网络请求、进程管理等。</li>
<li>框架提供的API：Electron提供了丰富的API，开发者可以使用这些API访问操作系统特定功能，如文件系统、系统通知、原生UI组件等，从而实现更强大和功能丰富的应用程序。</li>
</ol>
<h4 id="Electron与传统Web开发的区别是什么？它的优势和适用场景有哪些？"><a href="#Electron与传统Web开发的区别是什么？它的优势和适用场景有哪些？" class="headerlink" title="Electron与传统Web开发的区别是什么？它的优势和适用场景有哪些？"></a>Electron与传统Web开发的区别是什么？它的优势和适用场景有哪些？</h4><p>Electron与传统Web开发的区别主要在于应用程序的目标平台和功能需求：</p>
<ol>
<li>目标平台：传统Web开发主要是针对在浏览器中运行的Web应用程序，而Electron是用于构建桌面应用程序的开发框架，可以在Windows、Mac和Linux等操作系统上运行。</li>
<li>功能需求：传统Web应用通常是运行在浏览器中的网页应用，功能受限于浏览器的安全策略和功能限制。而Electron应用程序可以利用Node.js和Electron提供的API，访问操作系统的底层功能，实现更丰富的桌面应用功能，如文件系统访问、系统通知、本地数据库等。</li>
</ol>
<p>Electron的优势和适用场景包括：</p>
<ol>
<li>跨平台开发：Electron可以让开发者使用一套代码构建在多个操作系统上运行的桌面应用程序，提高开发效率，节省维护成本。</li>
<li>使用熟悉的Web技术：开发者可以使用熟悉的Web技术（如HTML、CSS和JavaScript）来构建桌面应用程序，无需学习新的语言和技术栈，降低了开发难度。</li>
<li>强大的生态系统：Electron拥有庞大的开发者社区和丰富的第三方库，提供了丰富的资源和解决方案，方便开发者快速构建和定制应用程序。</li>
<li>系统级访问：Electron提供访问操作系统特定功能的API，如文件系统、网络请求、系统通知、窗口管理等，开发者可以实现更丰富和功能强大的应用程序。</li>
<li>自定义界面：Electron允许开发者完全自定义应用程序的用户界面，从窗口样式到菜单、工具栏等，可以实现独特和个性化的用户体验。</li>
</ol>
<h4 id="请说明一下Electron的主要组成部分（主进程、渲染进程）、通信方式以及如何进行进程间的通信？"><a href="#请说明一下Electron的主要组成部分（主进程、渲染进程）、通信方式以及如何进行进程间的通信？" class="headerlink" title="请说明一下Electron的主要组成部分（主进程、渲染进程）、通信方式以及如何进行进程间的通信？"></a>请说明一下Electron的主要组成部分（主进程、渲染进程）、通信方式以及如何进行进程间的通信？</h4><p>Electron的主要组成部分包括主进程和渲染进程</p>
<ol>
<li>主进程（Main Process）：主进程是Electron应用程序的控制中心，负责管理应用程序的整体生命周期、窗口管理、系统级访问等功能。主进程在运行时可以创建多个窗口，每个窗口都对应一个渲染进程。</li>
<li>渲染进程（Renderer Process）：渲染进程在Electron应用程序中负责加载和显示界面以及处理与用户交互的逻辑。每个窗口对应一个渲染进程，运行在Chromium浏览器的渲染进程中。</li>
</ol>
<p>进程间通信（IPC）的常见方式：</p>
<ol>
<li>使用主进程和渲染进程之间的模块：在Electron应用程序中，主进程和渲染进程可以共享同一个Node.js环境，它们可以直接通过<code>require</code>命令来引入相同的模块，并共享数据和函数。</li>
<li>使用消息机制：Electron提供了<code>ipcRenderer</code>（在渲染进程中使用）和<code>ipcMain</code>（在主进程中使用）模块，用于实现进程之间的异步通信。通过发送和接收消息可以进行双向的进程间通信。</li>
<li>使用远程通信：Electron还提供了<code>remote</code>模块，允许渲染进程直接调用主进程中的API。通过远程调用，渲染进程可以访问主进程的功能，使得跨进程通信更加简化。</li>
</ol>
<h4 id="如何使用Electron构建桌面应用程序（Desktop-Application）？请描述一下整个开发流程和注意事项。"><a href="#如何使用Electron构建桌面应用程序（Desktop-Application）？请描述一下整个开发流程和注意事项。" class="headerlink" title="如何使用Electron构建桌面应用程序（Desktop Application）？请描述一下整个开发流程和注意事项。"></a>如何使用Electron构建桌面应用程序（Desktop Application）？请描述一下整个开发流程和注意事项。</h4><p>步骤：</p>
<ol>
<li>环境搭建：首先需要确保开发环境中已经安装了Node.js和npm（Node.js的包管理器）。</li>
<li>创建Electron项目：使用命令行工具，在项目目录中运行<code>npm init</code>命令来创建一个新的npm项目，并在<code>package.json</code>文件中添加Electron作为依赖项。</li>
<li>编写主进程代码：在项目中创建主进程的JavaScript文件，该文件负责创建Electron应用程序的窗口，以及管理应用程序的生命周期和系统级操作等。</li>
<li>编写渲染进程代码：在项目中创建渲染进程的HTML、CSS和JavaScript文件，该文件负责显示应用程序的用户界面，并处理与用户的交互逻辑。</li>
<li>打包和分发：使用Electron提供的打包工具（如Electron Forge、electron-packager等）将应用程序打包成可执行文件，并根据目标平台进行适配和分发。</li>
</ol>
<h4 id="请谈谈你对Electron打包工具（如electron-builder、electron-packager）的了解和使用经验，有哪些注意事项和优化方法？"><a href="#请谈谈你对Electron打包工具（如electron-builder、electron-packager）的了解和使用经验，有哪些注意事项和优化方法？" class="headerlink" title="请谈谈你对Electron打包工具（如electron-builder、electron-packager）的了解和使用经验，有哪些注意事项和优化方法？"></a>请谈谈你对Electron打包工具（如electron-builder、electron-packager）的了解和使用经验，有哪些注意事项和优化方法？</h4><ol>
<li>electron-builder：electron-builder是一个功能强大且易于使用的Electron打包工具，支持自动更新、多平台打包、代码签名等功能。通过配置文件可以定制化各种构建选项，例如设置应用程序图标、生成安装包等。</li>
<li>electron-packager：electron-packager是另一个常用的Electron打包工具，它可以将Electron应用程序打包成适用于不同平台的可执行文件。使用electron-packager可以轻松地将Electron应用程序打包成各种格式的安装包，如Windows的exe、Mac的dmg等。</li>
</ol>
<p>注意事项和优化方法：</p>
<ol>
<li>配置文件设置：根据项目需求，合理配置打包工具的参数和选项，比如指定应用程序图标、版本号、作者信息等，以及设置适配不同操作系统的参数。</li>
<li>优化资源和打包大小：对Electron应用程序进行资源优化，尽量减小可执行文件的大小，如移除不必要的依赖、压缩图片和代码等。可以通过调整构建选项和排除不必要的文件来实现。</li>
<li>多平台适配：要确保打包工具能够正确适配各个平台，包括处理每个平台的特定需求和配置，如Windows的安装程序、Mac的DMG文件等。</li>
<li>自动更新配置：如果需要实现自动更新功能，建议使用electron-builder的自动更新功能，配置Updater，以实现应用程序的自动更新功能。</li>
<li>CI&#x2F;CD集成：将Electron应用程序的打包流程集成到持续集成和持续交付（CI&#x2F;CD）系统中，实现自动构建、测试和部署，提高开发效率。</li>
</ol>
<h4 id="介绍一下Electron开发中常用的一些模块或库，以及它们的作用和使用场景。"><a href="#介绍一下Electron开发中常用的一些模块或库，以及它们的作用和使用场景。" class="headerlink" title="介绍一下Electron开发中常用的一些模块或库，以及它们的作用和使用场景。"></a>介绍一下Electron开发中常用的一些模块或库，以及它们的作用和使用场景。</h4><p>常用的Electron模块或库及其作用和使用场景：</p>
<ol>
<li><code>electron</code>模块：Electron的核心模块，提供Electron应用程序的构建和运行环境，包括主进程和渲染进程的管理、窗口创建、系统级访问等功能。</li>
<li><code>electron-builder</code>：用于打包和发布Electron应用程序的工具，支持生成多个平台的安装程序、自动更新、发布到不同渠道等功能。</li>
<li><code>electron-packager</code>：类似electron-builder，可以将Electron应用程序打包成可执行文件，并适配不同操作系统的安装包格式（如exe、dmg、deb等）。</li>
<li><code>Electron Forge</code>：一个用于快速搭建Electron应用程序项目结构的工具，提供了项目模板、自动化工作流等功能，简化了Electron应用程序的开发和打包过程。</li>
<li><code>electron-store</code>：用于在Electron应用程序中保存和获取持久化数据的模块，可以方便地管理应用程序的配置信息、用户偏好设置等数据。</li>
<li><code>electron-updater</code>：用于实现Electron应用程序的自动更新功能的模块，可以自动检查新版本、下载更新并安装，提升用户体验。</li>
<li><code>electron-debug</code>：用于在Electron应用程序中添加开发者工具的模块，可以调试应用程序、查看日志信息等，便于开发和调试过程。</li>
<li><code>Electron IPC</code>模块：用于实现Electron应用程序中不同进程间的通信的模块，包括主进程和渲染进程之间的消息传递功能，实现数据交换和功能调用。</li>
</ol>
<h4 id="讨论一下Electron安全性方面需要注意的事项，如何防止攻击和提高应用程序的安全性？"><a href="#讨论一下Electron安全性方面需要注意的事项，如何防止攻击和提高应用程序的安全性？" class="headerlink" title="讨论一下Electron安全性方面需要注意的事项，如何防止攻击和提高应用程序的安全性？"></a>讨论一下Electron安全性方面需要注意的事项，如何防止攻击和提高应用程序的安全性？</h4><ol>
<li>安全沙盒：Electron应用程序将主进程和渲染进程分开，并使用Chrome浏览器作为渲染进程的渲染引擎，从而提供了一定程度的安全隔离。但仍需谨慎处理用户输入数据，避免发生跨站脚本（XSS）攻击等安全漏洞。</li>
<li>安全通信：确保主进程和渲染进程之间的通信是安全的，可以使用Electron提供的IPC通信或者加密通信来保护数据传输的安全性，避免数据泄露。</li>
<li>避免远程代码执行：避免在Electron应用程序中执行远程或动态加载的代码，因为这可能会导致安全问题和漏洞。尽量在应用程序中使用本地可信代码。</li>
<li>安全更新：确保应用程序的自动更新功能是安全的，可以使用签名和校验等手段来验证更新包的完整性和真实性，防止被劫持或篡改。</li>
<li>文件系统访问：限制应用程序对本地文件系统的访问权限，避免恶意代码对用户数据和系统文件的恶意操作。避免直接操作系统文件，应该尽量使用Electron提供的API进行文件操作。</li>
<li>安全存储：确保用户敏感数据和证书等信息的安全存储，可以使用Electron提供的<code>secure-electron-store</code>等安全存储模块来保护用户数据。</li>
<li>内置Web服务安全：如果应用程序内置了Web服务，需要注意对服务器端代码进行安全编码，防止常见的Web安全漏洞，如SQL注入、跨站脚本等。</li>
<li>合规性和隐私：确保应用程序符合相关法规和隐私政策，避免收集和传输用户隐私数据，保护用户隐私权。</li>
</ol>
<h4 id="请描述一下你在使用Electron开发过程中遇到的挑战和解决方案，以及你的经验总结和教训。"><a href="#请描述一下你在使用Electron开发过程中遇到的挑战和解决方案，以及你的经验总结和教训。" class="headerlink" title="请描述一下你在使用Electron开发过程中遇到的挑战和解决方案，以及你的经验总结和教训。"></a>请描述一下你在使用Electron开发过程中遇到的挑战和解决方案，以及你的经验总结和教训。</h4><ol>
<li>跨平台兼容性：Electron应用程序需要在不同操作系统上运行，并保持一致的用户体验。在开发过程中，需要注意处理各种操作系统的差异性，如文件系统路径、系统API支持等，确保应用程序在不同平台上正常运行。</li>
</ol>
<p>解决方案：尽量使用Electron提供的跨平台API和模块，避免直接调用系统级API；进行针对性的测试，保证应用程序在不同平台上的兼容性；使用打包工具，如electron-builder，生成适配不同平台的安装包。</p>
<ol start="2">
<li>性能优化：Electron应用程序基于Chromium引擎，可能存在内存占用过高、启动速度慢等性能问题。特别是对于大型的Electron应用程序，需要更加注意性能优化。</li>
</ol>
<p>解决方案：优化渲染进程和主进程的代码，避免过度占用内存；使用Electron提供的工具进行性能分析，定位瓶颈并优化；减少无必要的资源加载和渲染操作，提高应用程序的响应速度。</p>
<ol start="3">
<li>安全问题：Electron应用程序需要注意安全问题，避免被攻击和数据泄露。需要注意处理用户输入和敏感数据，保护应用程序的安全性。</li>
</ol>
<p>解决方案：严格验证和过滤用户输入，避免XSS、CSRF等安全漏洞；对IPC通信进行加密保护；注意更新机制的安全性，避免被劫持或篡改；保护用户数据和隐私信息。</p>
<h4 id="如果你需要对一个现有的Web应用程序-Vue-React项目-进行移植到桌面应用程序，你将如何选择和使用Electron来完成这个任务？"><a href="#如果你需要对一个现有的Web应用程序-Vue-React项目-进行移植到桌面应用程序，你将如何选择和使用Electron来完成这个任务？" class="headerlink" title="如果你需要对一个现有的Web应用程序(Vue, React项目)进行移植到桌面应用程序，你将如何选择和使用Electron来完成这个任务？"></a>如果你需要对一个现有的Web应用程序(Vue, React项目)进行移植到桌面应用程序，你将如何选择和使用Electron来完成这个任务？</h4><ol>
<li><p>创建 Electron 项目：首先需要在项目目录中初始化 Electron 项目。可以使用 Electron Forge 工具来快速生成 Electron 项目的基本结构。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npx create-electron-app my-electron-app  </span><br><span class="line">$ <span class="built_in">cd</span> my-electron-app</span><br></pre></td></tr></table></figure>
</li>
<li><p>项目整合：将 React 或 Vue 项目的打包后的源代码<code>dist/</code>复制到 Electron 项目的 <code>src</code> 目录下，并在 Electron 主进程中加载 React 或 Vue 应用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/main.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; app, <span class="title class_">BrowserWindow</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createWindow</span> () &#123;  </span><br><span class="line">  <span class="comment">// 创建一个浏览器窗口，并加载 React 或 Vue 应用  </span></span><br><span class="line">  <span class="keyword">const</span> win = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;  </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="attr">width</span>: <span class="number">800</span>,  </span><br><span class="line">    <span class="attr">height</span>: <span class="number">600</span>,  </span><br><span class="line">    <span class="attr">webPreferences</span>: &#123;  </span><br><span class="line">      <span class="attr">nodeIntegration</span>: <span class="literal">true</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;);  </span><br><span class="line"></span><br><span class="line">  win.<span class="title function_">loadURL</span>(<span class="string">&#x27;http://localhost:3000&#x27;</span>); <span class="comment">// React 或 Vue 应用的开发服务器地址  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;ready&#x27;</span>, createWindow);</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置开发环境：在进行开发阶段，你可以运行 React 或 Vue 项目的开发服务器，并运行 Electron 项目来加载这些项目。以便进行开发调试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm start  </span><br><span class="line">$ npm run start-electron</span><br></pre></td></tr></table></figure>
</li>
<li><p>打包和发布：当项目开发完毕，你可以对应用进行打包和发布。使用 Electron Forge、Electron Builder 或 Electron Packager 等工具来打包 Electron 应用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx electron-forge make</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="ts"><a href="#ts" class="headerlink" title="ts"></a>ts</h3><h4 id="说说对typescript的理解"><a href="#说说对typescript的理解" class="headerlink" title="说说对typescript的理解"></a>说说对typescript的理解</h4><p>TypeScript 是一种由微软开发的开源编程语言，它是 JavaScript 的一个超集，提供了静态类型检查和其他特性。通过代码类型推断和编译时类型检查，TypeScript 可以在编写代码的同时帮助开发人员发现潜在错误，并提供代码提示，提高代码的可靠性和可维护性。</p>
<h4 id="说说typescript与javascript区别"><a href="#说说typescript与javascript区别" class="headerlink" title="说说typescript与javascript区别"></a>说说typescript与javascript区别</h4><ul>
<li>静态类型：TypeScript 引入了静态类型检查，提供了更严格的编译时错误检查，帮助开发人员在代码编写阶段捕获潜在的错误。</li>
<li>更好的工具支持：TypeScript 提供了更丰富的开发工具支持，如代码补全、自动重构、静态错误高亮等。</li>
<li>更好的可维护性：通过使用类型注解、接口和类等面向对象的特性，TypeScript 可以让代码更易于理解、重构和维护方便。</li>
<li>ECMAScript 的最新特性支持：TypeScript 支持使用最新的 ECMAScript 标准，可以在JavaScript 引擎中运行</li>
</ul>
<h4 id="typescript-类型注释和类型推断"><a href="#typescript-类型注释和类型推断" class="headerlink" title="typescript 类型注释和类型推断"></a>typescript 类型注释和类型推断</h4><ul>
<li>类型注解是在变量、函数、参数等声明时显式指定类型的方式。</li>
<li>类型推断是 TypeScript 根据变量的赋值语句自动推断出变量类型的过程</li>
</ul>
<h4 id="说说typescript有哪些类型"><a href="#说说typescript有哪些类型" class="headerlink" title="说说typescript有哪些类型"></a>说说typescript有哪些类型</h4><ol>
<li><strong>基本类型</strong>：<ul>
<li><code>number</code>：表示数字类型。</li>
<li><code>string</code>：表示字符串类型。</li>
<li><code>boolean</code>：表示布尔类型。</li>
<li><code>null</code>：表示空值。</li>
<li><code>undefined</code>：表示未定义的值。</li>
<li><code>symbol</code>：表示唯一的标识符。</li>
<li><code>void</code>：表示没有返回值的函数类型。</li>
</ul>
</li>
<li><strong>复合类型</strong>：<ul>
<li><code>Array</code>：表示数组类型。</li>
<li><code>Tuple</code>：表示固定长度和类型的数组。</li>
<li><code>Object</code>：表示对象类型。</li>
</ul>
</li>
<li><strong>特殊类型</strong>：<ul>
<li><code>any</code>：表示任意类型，可以绕过类型检查。</li>
<li><code>unknown</code>：表示未知类型，比 <code>any</code> 类型更安全。</li>
<li><code>never</code>：表示永远不会有返回值的类型。</li>
</ul>
</li>
<li><strong>函数类型</strong>：<ul>
<li><code>Function</code>：表示函数类型。</li>
<li><code>(): ReturnType</code>：表示函数返回值的类型。</li>
</ul>
</li>
<li><strong>高级类型</strong>：<ul>
<li><code>Union</code>：表示多个类型中的其中一个。</li>
<li><code>Intersection</code>：表示多个类型的交集。</li>
<li><code>Type Aliases</code>：表示自定义类型别名。</li>
<li><code>Enum</code>：表示枚举类型。</li>
<li><code>Generics</code>：表示泛型类型。</li>
</ul>
</li>
</ol>
<h4 id="说说typescript中高级类型的理解"><a href="#说说typescript中高级类型的理解" class="headerlink" title="说说typescript中高级类型的理解"></a>说说typescript中高级类型的理解</h4><p>高级类型是指一些复杂、灵活且强大的类型操作和编程模式，可以用来描述和操作各种类型。</p>
<ol>
<li><strong>联合类型（Union Types）</strong>：<ul>
<li>联合类型表示一个值可以是多种类型中的一种。使用 <code>|</code> 符号将多个类型联合在一起。</li>
<li>例如，<code>string | number</code> 表示某个值可以是字符串或数字类型。</li>
</ul>
</li>
<li><strong>交叉类型（Intersection Types）</strong>：<ul>
<li>交叉类型表示将多个类型合并为一个类型。使用 <code>&amp;</code> 符号将多个类型交叉在一起。</li>
<li>例如，<code>A &amp; B</code> 表示将类型 A 和类型 B 的属性和方法合并为一个新的类型。</li>
</ul>
</li>
<li><strong>类型别名（Type Aliases）</strong>：<ul>
<li>类型别名可以用来为复杂的类型或联合类型定义简洁的别名。使用 <code>type</code> 关键字定义类型别名。</li>
<li>例如，<code>type MyString = string | null | undefined</code> 定义了一个名为 <code>MyString</code> 的联合类型别名。</li>
</ul>
</li>
<li><strong>条件类型（Conditional Types）</strong>：<ul>
<li>条件类型基于判断条件来选择不同的类型。通过使用条件类型，根据输入的类型参数决定返回的结果类型。</li>
<li>例如，<code>T extends U ? X : Y</code> 表示如果类型 <code>T</code> 可以赋值给类型 <code>U</code>，则返回类型 <code>X</code>，否则返回类型 <code>Y</code>。</li>
</ul>
</li>
<li><strong>映射类型（Mapped Types）</strong>：<ul>
<li>映射类型可以通过映射现有类型的每个属性来创建一个新类型。可以在类型级别上操作对象的属性。</li>
<li>例如，<code>type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P] &#125;</code> 创建了一个将所有属性变为只读的类型。</li>
</ul>
</li>
<li><strong>Readonly 类型</strong>：<ul>
<li><code>Readonly&lt;T&gt;</code> 类型可以将对象的所有属性变为只读属性，防止对对象的属性进行修改。</li>
<li>例如，<code>type Point = Readonly&lt;&#123; x: number, y: number &#125;&gt;</code> 定义了一个不可修改的点类型。</li>
</ul>
</li>
</ol>
<h4 id="什么是类？如何在-TypeScript-中创建类"><a href="#什么是类？如何在-TypeScript-中创建类" class="headerlink" title="什么是类？如何在 TypeScript 中创建类"></a>什么是类？如何在 TypeScript 中创建类</h4><p>类是一种面向对象的编程概念，用于描述具有相同属性和方法的对象的模板。在 TypeScript 中使用 <code>class</code> 关键字创建类，并使用 <code>new</code> 关键字创建类的实例</p>
<h4 id="什么是接口？如何在-TypeScript-中使用接口？"><a href="#什么是接口？如何在-TypeScript-中使用接口？" class="headerlink" title="什么是接口？如何在 TypeScript 中使用接口？"></a>什么是接口？如何在 TypeScript 中使用接口？</h4><p>接口是用于定义对象的类型的一种方式，它描述了一个对象应该具有的属性和方法。使用 <code>interface</code> 关键字创建接口，并在对象中实现该接口。</p>
<h4 id="什么是泛型（Generics）？如何在-TypeScript-中使用泛型？"><a href="#什么是泛型（Generics）？如何在-TypeScript-中使用泛型？" class="headerlink" title="什么是泛型（Generics）？如何在 TypeScript 中使用泛型？"></a>什么是泛型（Generics）？如何在 TypeScript 中使用泛型？</h4><p>泛型允许在定义函数、类或接口时延迟指定具体类型，而在使用时根据需要指定具体类型。在 TypeScript 中使用 <code>&lt;T&gt;</code> 语法定义泛型，并在代码中使用具体类型替代 <code>T</code>。</p>
<h4 id="如何声明和使用枚举（Enum）类型？"><a href="#如何声明和使用枚举（Enum）类型？" class="headerlink" title="如何声明和使用枚举（Enum）类型？"></a>如何声明和使用枚举（Enum）类型？</h4><p>在 TypeScript 中使用 <code>enum</code> 关键字来声明和定义枚举类型。枚举类型可以作为一组命名的常量值的集合。</p>
<h4 id="什么是-TypeScript-断言？"><a href="#什么是-TypeScript-断言？" class="headerlink" title="什么是 TypeScript 断言？"></a>什么是 TypeScript 断言？</h4><p>TypeScript 断言是一种方式，让编译器知道一个值的类型。并且可以强制将该值视为指定的类型</p>
<h4 id="TypeScript-中的两种类型断言的语法和用法。"><a href="#TypeScript-中的两种类型断言的语法和用法。" class="headerlink" title="TypeScript 中的两种类型断言的语法和用法。"></a>TypeScript 中的两种类型断言的语法和用法。</h4><p>TypeScript 中有两种类型断言的语法：尖括号语法和 as 语法。</p>
<ul>
<li>尖括号语法：<code>let someValue: any = &quot;hello&quot;; let strLength: number = (&lt;string&gt;someValue).length;</code></li>
<li>as 语法：<code>let someValue: any = &quot;hello&quot;; let strLength: number = (someValue as string).length;</code></li>
</ul>
<h4 id="什么时候应该使用类型断言？"><a href="#什么时候应该使用类型断言？" class="headerlink" title="什么时候应该使用类型断言？"></a>什么时候应该使用类型断言？</h4><ul>
<li><em>当编译器无法自动推断变量的类型</em>，或者开发人员更了解某个变量的具体类型时，可以使用类型断言来告诉编译器该变量的准确类型。</li>
<li><em>当需要在某个类型上调用特定方法</em>，但编译器无法正确推断类型的时候也可以使用类型断言。</li>
</ul>
<h4 id="什么是非空断言运算符（-）？它在-TypeScript-中的作用是什么？"><a href="#什么是非空断言运算符（-）？它在-TypeScript-中的作用是什么？" class="headerlink" title="什么是非空断言运算符（!）？它在 TypeScript 中的作用是什么？"></a>什么是非空断言运算符（!）？它在 TypeScript 中的作用是什么？</h4><ul>
<li>非空断言运算符 <code>!</code> 可以告诉 TypeScript 编译器一个值不会为 <code>null</code> 或 <code>undefined</code>。</li>
<li>当开发人员明确知道某个值不会是 <code>null</code> 或 <code>undefined</code> 时，可以使用非空断言运算符来告诉编译器。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">element</span>: <span class="title class_">HTMLElement</span> | <span class="literal">null</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);  </span><br><span class="line"><span class="comment">// 这里 TypeScript 会认为 element 可能为 null，会有警告  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用非空断言运算符来告诉编译器 element 不会为 null  </span></span><br><span class="line">element!.<span class="property">textContent</span> = <span class="string">&#x27;Hello, TypeScript!&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里，我们明确知道 element 不会为 null，所以可以安全地访问它的属性或方法</span></span><br></pre></td></tr></table></figure>



<h4 id="ts类"><a href="#ts类" class="headerlink" title="ts类"></a>ts类</h4><p>在 TypeScript 中，可以使用类（class）来创建对象和定义对象的属性和方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;  </span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;  </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I am <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);  </span><br><span class="line">person.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure>



<h4 id="ts类的继承"><a href="#ts类的继承" class="headerlink" title="ts类的继承"></a>ts类的继承</h4><p>类之间可以通过继承创建父类和子类的关系。子类可以继承父类的属性和方法，并且可以添加自己的属性和方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;  </span><br><span class="line">    <span class="attr">grade</span>: <span class="built_in">number</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, grade: <span class="built_in">number</span></span>) &#123;  </span><br><span class="line">        <span class="variable language_">super</span>(name, age);  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">grade</span> = grade;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="title function_">study</span>(<span class="params"></span>) &#123;  </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> is studying in grade <span class="subst">$&#123;<span class="variable language_">this</span>.grade&#125;</span>.`</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> student = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">12</span>, <span class="number">6</span>);  </span><br><span class="line">student.<span class="title function_">greet</span>();  </span><br><span class="line">student.<span class="title function_">study</span>();</span><br></pre></td></tr></table></figure>



<h4 id="ts修饰符"><a href="#ts修饰符" class="headerlink" title="ts修饰符"></a>ts修饰符</h4><p>修饰符可以限制类成员的访问权限，包括 <code>public</code>（默认）、<code>private</code> 和 <code>protected</code>。</p>
<ul>
<li><code>public</code>：所有地方都可以访问。</li>
<li><code>private</code>：仅在类内部可以访问。</li>
<li><code>protected</code>：类内部和子类可以访问。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_name</span>: <span class="built_in">string</span>;  </span><br><span class="line">    <span class="keyword">protected</span> <span class="attr">_sound</span>: <span class="built_in">string</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, sound: <span class="built_in">string</span></span>) &#123;  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = name;  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_sound</span> = sound;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="title function_">makeSound</span>(<span class="params"></span>) &#123;  </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">_sound</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;  </span><br><span class="line">    <span class="title function_">bark</span>(<span class="params"></span>) &#123;  </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The dog named <span class="subst">$&#123;<span class="variable language_">this</span>._name&#125;</span> is barking.`</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>, <span class="string">&quot;Woof&quot;</span>);  </span><br><span class="line">dog.<span class="title function_">makeSound</span>(); <span class="comment">// Accessible  </span></span><br><span class="line">dog.<span class="title function_">bark</span>(); <span class="comment">// Accessible  </span></span><br><span class="line"><span class="comment">// dog._name; // Private member &#x27;_name&#x27; cannot be accessed outside class &#x27;Animal&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="ts抽象类-使用技巧"><a href="#ts抽象类-使用技巧" class="headerlink" title="ts抽象类&amp;使用技巧"></a>ts抽象类&amp;使用技巧</h4><p>抽象类是不能直接实例化的类，主要用于作为其他类的基类。抽象类可以包含抽象方法和具体方法的实现，子类继承抽象类时必须实现抽象方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;  </span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">calculateArea</span>(): <span class="built_in">number</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="title function_">printArea</span>(<span class="params"></span>) &#123;  </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Area: <span class="subst">$&#123;<span class="variable language_">this</span>.calculateArea()&#125;</span>`</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;  </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> radius: <span class="built_in">number</span></span>) &#123;  </span><br><span class="line">        <span class="variable language_">super</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="title function_">calculateArea</span>(<span class="params"></span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span> ** <span class="number">2</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>);  </span><br><span class="line">circle.<span class="title function_">printArea</span>(); <span class="comment">// Output: Area: 78.53981633974483</span></span><br></pre></td></tr></table></figure>



<h4 id="ts枚举类型"><a href="#ts枚举类型" class="headerlink" title="ts枚举类型"></a>ts枚举类型</h4><p>枚举（enum）是一种包含命名常量的数据结构，用于定义一组常量值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;  </span><br><span class="line">    <span class="title class_">Up</span> = <span class="string">&quot;Up&quot;</span>,  </span><br><span class="line">    <span class="title class_">Down</span> = <span class="string">&quot;Down&quot;</span>,  </span><br><span class="line">    <span class="title class_">Left</span> = <span class="string">&quot;Left&quot;</span>,  </span><br><span class="line">    <span class="title class_">Right</span> = <span class="string">&quot;Right&quot;</span>,  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">direction</span>: <span class="title class_">Direction</span> = <span class="title class_">Direction</span>.<span class="property">Right</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(direction); <span class="comment">// Output: Right</span></span><br></pre></td></tr></table></figure>



<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><h4 id="常用-Git-命令"><a href="#常用-Git-命令" class="headerlink" title="常用 Git 命令"></a>常用 Git 命令</h4><ol>
<li><strong>基本操作</strong><ul>
<li><code>git init</code>：初始化一个新的 Git 本地仓库。</li>
<li><code>git clone &lt;repo_url&gt;</code>：克隆一个远程仓库。</li>
<li><code>git status</code>：查看当前工作区和暂存区的状态。</li>
<li><code>git add &lt;file&gt;</code>：将文件添加到暂存区。</li>
<li><code>git commit -m &quot;commit message&quot;</code>：提交暂存区的更改。</li>
<li><code>git push</code>：将本地更改推送到远程仓库。</li>
<li><code>git pull</code>：从远程仓库拉取最新的更改并合并到本地。</li>
</ul>
</li>
<li><strong>查看历史</strong><ul>
<li><code>git log</code>：查看提交历史。</li>
<li><code>git diff</code>：查看未暂存的更改。</li>
<li><code>git show &lt;commit_hash&gt;</code>：查看某次提交的详细信息。</li>
</ul>
</li>
<li><strong>分支操作</strong><ul>
<li><code>git branch</code>：列出所有分支。</li>
<li><code>git branch &lt;branch_name&gt;</code>：创建新分支。</li>
<li><code>git checkout &lt;branch_name&gt;</code>：切换到指定分支。</li>
<li><code>git merge &lt;branch_name&gt;</code> &#x2F; git rebase：合并指定分支到当前分支。</li>
</ul>
</li>
<li><strong>提交撤销操作</strong><ul>
<li>未暂存的撤销可以使用checkout</li>
<li>已暂存的撤销可以使用reset</li>
<li>回滚代码，可以使用reset配合参数( 硬重置，软重置)</li>
<li>撤销提交可以使用revert</li>
</ul>
</li>
</ol>
<h4 id="如何撤销更改？"><a href="#如何撤销更改？" class="headerlink" title="如何撤销更改？"></a>如何撤销更改？</h4><ul>
<li><p>撤销未暂存的更改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销已暂存的更改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>回滚到某个提交并丢弃后续更改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit_hash&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="如何回滚代码"><a href="#如何回滚代码" class="headerlink" title="如何回滚代码"></a>如何回滚代码</h4><ol>
<li><p><strong>使用 <code>git reset</code> 回滚至某个提交</strong></p>
<ul>
<li><p>回到某个提交并保留未提交的更改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit_hash&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>回到某个提交并丢弃未提交的更改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit_hash&gt;  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用 <code>git revert</code> 创建一个新提交</strong></p>
<ul>
<li><p>如果希望撤销某次提交，并且保持项目历史完整，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit_hash&gt;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>这会生成一个新的提交，反转指定的提交。</p>
</li>
</ul>
</li>
<li><p>软重置（Soft Reset）：这会撤销最新的提交，并将更改保留在暂存区中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure>
</li>
<li><p>硬重置（Hard Reset）：这会撤销最新的提交，并将更改完全删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="如何合并分支"><a href="#如何合并分支" class="headerlink" title="如何合并分支"></a>如何合并分支</h4><ol>
<li><p><strong>确保当前在目标分支</strong></p>
<ul>
<li><p>切换到想要合并到的分支，例如 main或master</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>合并指定分支</strong></p>
<ul>
<li><p>合并其他分支（例如 feature-branch）到当前分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge feature-branch  </span><br></pre></td></tr></table></figure>
</li>
<li><p>如果合并时没有冲突，Git 会自动完成合并。</p>
</li>
<li><p>如果出现冲突，将会提示你手动解决冲突。</p>
</li>
</ul>
</li>
</ol>
<h4 id="什么是“rebase”，它与“merge”有什么不同？"><a href="#什么是“rebase”，它与“merge”有什么不同？" class="headerlink" title="什么是“rebase”，它与“merge”有什么不同？"></a>什么是“rebase”，它与“merge”有什么不同？</h4><ul>
<li>**<code>merge</code>**：保留所有分支的历史，创建一个新的合并提交。</li>
<li>**<code>rebase</code>**：将一个分支的更改“移动”到另一个分支的基础上，形成一条线性历史，不会留下合并提交。<code>rebase</code> 通常会使历史记录更加简洁。</li>
</ul>
<h4 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h4><ol>
<li><p>编译冲突的文件。</p>
</li>
<li><p>手动编辑冲突的行。</p>
</li>
<li><p>保存文件后，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;resolved_file&gt;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>完成合并：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Merge branch &#x27;feature-branch&#x27;&quot;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="将工作区保存临时区域"><a href="#将工作区保存临时区域" class="headerlink" title="将工作区保存临时区域"></a>将工作区保存临时区域</h4><p>要回到某个提交并保留未提交的更改，然后再回到原来的工作区，您可以按照以下步骤进行操作：</p>
<ol>
<li><p>使用 <code>git stash</code> 命令将当前未提交的更改保存到一个临时区域（stash）中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash  </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>git log</code> 命令查找您要回到的提交的哈希值（commit hash）。</p>
</li>
<li><p>使用 <code>git checkout</code> 命令切换到您要回到的提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;commit-hash&gt;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>在回到的提交中进行必要的操作。</p>
</li>
<li><p>如果您完成了在回到的提交中的操作，并且想要回到原来的工作区，可以使用 <code>git stash apply</code> 命令将之前保存的更改应用到当前工作区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply  </span><br></pre></td></tr></table></figure>

<p>如果您有多个 stash，可以使用 <code>git stash list</code> 命令查看 stash 列表，并使用 <code>git stash apply stash@&#123;&lt;stash-index&gt;&#125;</code> 应用特定的 stash。</p>
</li>
</ol>
<h3 id="网络协议-兼容"><a href="#网络协议-兼容" class="headerlink" title="网络协议 &amp; 兼容"></a>网络协议 &amp; 兼容</h3><h4 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h4><p><strong>五个类别：</strong></p>
<p>1xx - 信息性状态码：表示请求已被接收，继续处理。</p>
<p>2xx - 成功状态码：表示请求已成功被服务器接收、理解和处理。</p>
<p>3xx - 重定向状态码：表示需要进一步操作以完成请求。</p>
<p>4xx - 客户端错误状态码：表示服务器无法处理请求，客户端可能需要修改请求。</p>
<p>5xx - 服务器错误状态码：表示服务器在处理请求时发生了错误。</p>
<ul>
<li><strong>200 OK</strong>：请求成功，服务器成功返回请求的数据。</li>
<li><strong>201 Created</strong>：请求成功，服务器成功创建了新的资源。</li>
<li><strong>204 No Content</strong>：请求成功，服务器成功处理了请求，但没有返回任何内容。</li>
<li><strong>301 Moved Permanently</strong>：请求的资源已永久移动到新的 URL。</li>
<li><strong>400 Bad Request</strong>：请求无效，服务器无法理解请求的语法。</li>
<li><strong>401 Unauthorized</strong>：请求要求身份验证，客户端未提供有效的身份验证凭据。</li>
<li><strong>500 Internal Server Error</strong>：服务器在执行请求时发生了未知的内部错误。</li>
<li><strong>501 Not Implemented</strong>：服务器不支持实现请求所需要的功能，或者无法完成请求。</li>
<li><strong>502 Bad Gateway</strong>：作为网关或代理工作的服务器尝试执行请求时，从上游服务器接收到无效响应。</li>
<li><strong>503 Service Unavailable</strong>：服务器暂时无法处理请求（可能是由于过载或维护）。</li>
<li><strong>504 Gateway Timeout</strong>：作为网关或代理工作的服务器尝试执行请求时，但并未及时从上游服务器接收到响应。</li>
<li><strong>505 HTTP Version Not Supported</strong>：服务端不支持客户端指定的 HTTP 版本。</li>
</ul>
<h4 id="介绍-HTTP-的基本原理和工作过程。"><a href="#介绍-HTTP-的基本原理和工作过程。" class="headerlink" title="介绍 HTTP 的基本原理和工作过程。"></a>介绍 HTTP 的基本原理和工作过程。</h4><p>HTTP TCP下的用于传输超文本的协议，是 Web 数据传输的基础。通过请求-响应的交互方式实现数据传输。</p>
<p>工作过程：</p>
<ol>
<li><p>客户端发起请求：HTTP 是基于客户端-服务器模式工作的，客户端（一般是浏览器）向服务器发起 HTTP 请求。请求由请求行、请求头和请求体组成，请求行包括请求方法（如 GET、POST）、请求的 URL（统一资源定位符）、协议版本等。</p>
</li>
<li><p>服务器处理请求：服务器接收到客户端的请求后，根据请求的 URL 定位资源，并执行相应的处理逻辑，如读取文件、执行程序等。服务器处理完请求后会生成一个 HTTP 响应发送给客户端。</p>
</li>
<li><p>服务器返回响应：HTTP 响应由响应行、响应头和响应体组成。响应行包括协议版本、状态码（用于表示请求的处理结果）和状态消息。响应头包括各种元数据，如日期、内容类型等。响应体则包含实际的响应内容。</p>
</li>
<li><p>客户端接收响应：客户端接收到服务器返回的 HTTP 响应后，根据响应的内容进行处理，展示给用户或者执行相关操作。如果需要加载额外资源（如图片、样式表、脚本等），客户端会再次向服务器发起新的请求。</p>
</li>
<li><p>TCP 连接：HTTP 是基于 TCP&#x2F;IP 协议的，通信双方需要建立 TCP 连接才能进行数据传输。连接建立后，客户端和服务器之间可以通过该连接进行数据传输，传输完成后可以关闭连接。</p>
</li>
<li><p>状态保持：HTTP 协议本身是无状态的，即服务器不会保留关于客户端的状态。为了实现状态保持，通常使用一些技术手段，比如 Cookie、Session 或者 Token 来实现用户状态的管理和保持。</p>
</li>
</ol>
<h4 id="http长连接和短连接"><a href="#http长连接和短连接" class="headerlink" title="http长连接和短连接"></a>http长连接和短连接</h4><h4 id="HTTP-请求方法有哪些？它们各自的作用是什么？"><a href="#HTTP-请求方法有哪些？它们各自的作用是什么？" class="headerlink" title="HTTP 请求方法有哪些？它们各自的作用是什么？"></a>HTTP 请求方法有哪些？它们各自的作用是什么？</h4><h4 id="什么是状态码？举例说明几个常见的状态码及其含义。"><a href="#什么是状态码？举例说明几个常见的状态码及其含义。" class="headerlink" title="什么是状态码？举例说明几个常见的状态码及其含义。"></a>什么是状态码？举例说明几个常见的状态码及其含义。</h4><h4 id="介绍HTTP-1-HTTP-2-和-HTTP-3-的特性和区别。"><a href="#介绍HTTP-1-HTTP-2-和-HTTP-3-的特性和区别。" class="headerlink" title="介绍HTTP&#x2F;1 , HTTP&#x2F;2 和 HTTP&#x2F;3 的特性和区别。"></a>介绍HTTP&#x2F;1 , HTTP&#x2F;2 和 HTTP&#x2F;3 的特性和区别。</h4><h4 id="RESTful-架构风格包括哪些设计原则？"><a href="#RESTful-架构风格包括哪些设计原则？" class="headerlink" title="RESTful 架构风格包括哪些设计原则？"></a>RESTful 架构风格包括哪些设计原则？</h4><h4 id="http和https区别"><a href="#http和https区别" class="headerlink" title="http和https区别"></a>http和https区别</h4><ol>
<li>安全性:<ul>
<li>HTTP 是超文本传输协议 (Hypertext Transfer Protocol) 的缩写，它使用明文传输数据。这意味着通过 HTTP 传输的数据在网络上可以被轻松地截取和窥视，存在较高的安全风险。</li>
<li>HTTPS 是安全超文本传输协议 (Hypertext Transfer Protocol Secure) 的缩写，它使用了 SSL&#x2F;TLS 协议对数据进行加密。HTTPS 能够确保客户端和服务器之间发送的数据经过加密，并且提供身份验证机制，因此通信更加安全可靠。</li>
</ul>
</li>
<li>加密:<ul>
<li>HTTP 不对发送或接收的数据进行加密处理，因此可能会被恶意攻击者截取并窥视其中包含的敏感信息。</li>
<li>HTTPS 使用 SSL&#x2F;TLS 协议对通信过程中所发送、接收或存储到服务器上面所有信息（如个人信息、银行账号等）进行加密。</li>
</ul>
</li>
<li>默认端口:<ul>
<li>HTTP 默认端口为 80。</li>
<li>HTTPS 默认端口为 443。</li>
</ul>
</li>
</ol>
<h4 id="HTTPS-相对于-HTTP-的优点和工作原理。"><a href="#HTTPS-相对于-HTTP-的优点和工作原理。" class="headerlink" title="HTTPS 相对于 HTTP 的优点和工作原理。"></a>HTTPS 相对于 HTTP 的优点和工作原理。</h4><ol>
<li>安全性</li>
<li>数据完整性</li>
<li>身份验证</li>
<li>改善搜索排名</li>
</ol>
<h4 id="https加密过程-SSL-TLS"><a href="#https加密过程-SSL-TLS" class="headerlink" title="https加密过程(SSL&#x2F; TLS)"></a>https加密过程(SSL&#x2F; TLS)</h4><ol>
<li>客户端请求建立安全连接</li>
<li>服务器响应并验证身份</li>
<li>客户端生成密钥</li>
<li>服务器解密密钥</li>
<li>双方生成会话密钥</li>
<li>数据传输加密</li>
</ol>
<h4 id="https证书如何防止篡改，防调包"><a href="#https证书如何防止篡改，防调包" class="headerlink" title="https证书如何防止篡改，防调包"></a>https证书如何防止篡改，防调包</h4><h4 id="SSL-TLS-握手过程包括哪些步骤？"><a href="#SSL-TLS-握手过程包括哪些步骤？" class="headerlink" title="SSL&#x2F;TLS 握手过程包括哪些步骤？"></a>SSL&#x2F;TLS 握手过程包括哪些步骤？</h4><h4 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h4><ol>
<li>数据传输方式：<ul>
<li>GET：通过 URL 参数传递数据，数据附在 URL 后面，以 <code>?</code> 开始，参数之间以 <code>&amp;</code> 分隔。例如：<code>http://example.com/path?name=value&amp;age=30</code></li>
<li>POST：通过请求体传递数据，在 HTTP 请求的消息体中发送，并不会显示在 URL 中。</li>
</ul>
</li>
<li>安全性：<ul>
<li>GET：因为参数附在 URL 上，所以可能会被保存在浏览器历史记录、代理服务器日志等地方，不适合发送敏感信息。</li>
<li>POST：由于数据不会暴露在 URL 上，在一定程度上比 GET 更安全，并且可以使用 HTTPS 进行加密传输。</li>
</ul>
</li>
<li>数据长度限制：<ul>
<li>GET 请求对URL长度有限制（约 2KB），而 POST 没有明确的长度限制（取决于服务器和客户端设置）。</li>
</ul>
</li>
<li>幂等性：<ul>
<li>GET 请求通常是幂等的。即多次相同的请求会产生相同结果并且没有副作用。</li>
<li>POST 请求通常是非幂等的。即多次相同的请求可能每次产生不同结果或者有副作用（如创建一个新资源）。</li>
</ul>
</li>
<li>缓存处理：<ul>
<li>对于相同URL和参数GET会被缓存到浏览器缓存或者CDN,POST则将忽略来自服务器指令</li>
</ul>
</li>
</ol>
<h4 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h4><ol>
<li>从网络获取HTML：浏览器通过网络加载HTML文件。这可能包括从服务器请求主HTML文档以及从文档中加载的外部资源（如CSS、JavaScript、图像等）。</li>
<li>创建DOM树：浏览器将HTML解析为DOM（文档对象模型）树，即一个包含HTML标签的层次结构表示。这是页面的逻辑结构，反映了HTML中元素的父子关系。</li>
<li>构建CSSOM树：同时，浏览器会加载并解析外部CSS文件，并将其转换为CSSOM（CSS对象模型）树。这是一个表示CSS规则和其应用到文档中元素的树结构。</li>
<li>合并DOM和CSSOM树：浏览器将DOM树和CSSOM树合并为一个渲染树（render tree）。渲染树只包括需要显示的节点和这些节点的样式信息，不包括不可见的元素（例如<code>&lt;head&gt;</code>中的元素）。</li>
<li>布局（Layout）：浏览器对渲染树进行布局，计算每个节点在屏幕上的位置和大小。这个过程被称为重排（reflow）。</li>
<li>绘制（Painting）：最后，浏览器将布局后的元素绘制在屏幕上，这个过程叫做绘制（painting）。</li>
</ol>
<h4 id="浏览器缓存-http缓存"><a href="#浏览器缓存-http缓存" class="headerlink" title="浏览器缓存 - http缓存"></a>浏览器缓存 - http缓存</h4><p>指浏览器在访问网页时将一些静态资源存储在本地的过程。这样做可以减少对服务器的请求次数，加快页面加载速度，并节省带宽消耗。<br>浏览器缓存通常分为两种类型：<strong>强缓存</strong>和<strong>协商缓存</strong>。</p>
<ul>
<li><strong>强制缓存</strong>：通过设置响应头控制客户端是否直接使用缓存而不发送请求到服务器。常见的控制头有 <code>Cache-Control</code> 和 <code>Expires</code>。<ul>
<li><code>Cache-Control</code>：指令包括 <code>max-age</code>（缓存有效时间）、<code>no-cache</code>（需要进行协商缓存验证）等。</li>
<li><code>Expires</code>：设置资源过期时间，是一个绝对时间。</li>
</ul>
</li>
<li><strong>协商缓存</strong>：当强制缓存失效时，客户端会发送请求到服务器验证资源是否更新。主要通过 <code>If-Modified-Since</code> 和 <code>If-None-Match</code> 这两个请求头来实现。<ul>
<li><code>If-Modified-Since</code>：表示资源的最后修改时间，服务器会比较该时间与资源的修改时间来判断资源是否需要更新。</li>
<li><code>If-None-Match</code>：表示资源的唯一标识符（通常是 ETag），服务器会比较该标识符与当前资源的标识符来判断资源是否</li>
</ul>
</li>
</ul>
<h4 id="浏览器缓存-本地缓存。cookie，localStorage，sessionstorage，会把数据存在哪，受不受同源策略制约"><a href="#浏览器缓存-本地缓存。cookie，localStorage，sessionstorage，会把数据存在哪，受不受同源策略制约" class="headerlink" title="浏览器缓存 - 本地缓存。cookie，localStorage，sessionstorage，会把数据存在哪，受不受同源策略制约"></a>浏览器缓存 - 本地缓存。cookie，localStorage，sessionstorage，会把数据存在哪，受不受同源策略制约</h4><ul>
<li><strong>Cookie</strong>：cookie是一种在客户端存储数据的机制。可以通过在HTTP响应头中设置Set-Cookie头部来创建和修改Cookie，下次请求信息的时候会自动在请求头中包含Cookie。Cookie有一些限制，例如每个响应的Cookie数量和总大小都有限制，同时Cookie会在每次请求时都被发送到服务器，会增加网络流量。Cookie 受同源策略的限制，只能被设置和访问与其所属网站相同的域名、协议和端口。</li>
<li><strong>localStorage</strong>：是HTML5新增的一种在客户端存储数据的机制，数据以键值对的形式存储在客户端的浏览器中。数据会永久保存在浏览器的本地存储空间中，除非被显式清除或网站使用代码进行删除。每个域名有独立的 localStorage 存储空间，受同源策略的限制。</li>
<li><strong>sessionStorage</strong>：sessionStorage 也是以键值对的形式将数据存储在客户端的浏览器中。与 localStorage 不同的是，sessionStorage 中的数据在数据只在当前会话（当前的浏览器窗口或者选项卡）有效。结束后会被清除，即当用户关闭浏览器标签页或窗口时会话结束。每个域名有独立的 sessionStorage 存储空间，受同源策略的限制。</li>
</ul>
<h4 id="localStorage存储超过限制怎么处理"><a href="#localStorage存储超过限制怎么处理" class="headerlink" title="localStorage存储超过限制怎么处理"></a>localStorage存储超过限制怎么处理</h4><ol>
<li>对超过限制的数据进行分割</li>
<li>压缩数据</li>
<li>使用服务器端存储</li>
<li>IndexedDB或WebSQL本地存储方案</li>
</ol>
<h4 id="跨域请求如何产生？如何解决跨域问题？"><a href="#跨域请求如何产生？如何解决跨域问题？" class="headerlink" title="跨域请求如何产生？如何解决跨域问题？"></a>跨域请求如何产生？如何解决跨域问题？</h4><p>跨域请求是指浏览器端发起的请求在安全策略下跨越了当前页面所在的域名、端口或协议，去请求其他域名下的资源。跨域请求是指浏览器端发起的请求在安全策略下跨越了当前页面所在的域名、端口或协议，去请求其他域名下的资源。</p>
<ol>
<li>JSONP（JSON with padding）：通过动态插入<code>&lt;script&gt;</code>标签，使用回调函数的方式获取跨域的数据。JSONP只支持GET请求，且需要接口提供支持和配合。</li>
<li>CORS（跨域资源共享）：在服务端设置响应头<code>Access-Control-Allow-Origin</code>允许特定的域名访问，或者使用通配符<code>*</code>表示允许所有域名访问。这样浏览器在发起跨域请求时，会在请求头里携带<code>Origin</code>字段，服务端根据这个字段来决定是否允许跨域请求。</li>
<li>代理服务器：在你的服务器上设置一个代理，用于转发请求。客户端向自身的服务端发出请求，然后服务端将请求发送给目标服务器，并将目标服务器的响应返回给客户端。由于请求是在同一个域名下完成的，跨域问题得到解决。</li>
</ol>
<h4 id="保持用户会话状态的认证机制-cookie-，session，token"><a href="#保持用户会话状态的认证机制-cookie-，session，token" class="headerlink" title="保持用户会话状态的认证机制 - cookie ，session，token"></a>保持用户会话状态的认证机制 - cookie ，session，token</h4><blockquote>
<p>cookie,session,token是保持用户会话状态的一个认证机制，因为HTTP 协议是一种无状态的协议，每个请求都是独立的。cookie会受同源策略的限制。session，token不受同源策略的限制。</p>
</blockquote>
<ul>
<li><strong>Cookie</strong>：Cookie 是一种在客户端存储数据的技术，通常是由服务器发送到客户端的小型文本文件，以键值对的形式存在。通过HTTP响应头中的Set-Cookie字段传递给客户端，存储在客户端的浏览器中。Cookie 可以包含各种信息，如用户身份标识、会话状态，当前页面的状态，域名，过期时间等，在后续的请求中，浏览器会自动携带相应的Cookie信息发送到服务器。</li>
<li><strong>Session</strong>：Session 是一种在服务器端存储用户会话数据的机制。当用户访问网站时，服务器会为用户创建一个唯一的会话标识符（Session ID），并将该标识符存储在服务器上，由服务器进行管理。客户端通常通过 Cookie 中的 Session ID 来与服务器建立关联，以便在后续的请求中识别用户会话。Session 数据不受同源策略的限制。</li>
<li><strong>Token</strong>：Token 是一种用于验证用户身份和授权访问的令牌。它通常是由服务器生成的一串字符，可以包含用户身份信息和权限等数据。作为客户端和服务器之间进行身份验证和授权的凭据。Token 不依赖于服务器端的存储，而是通过在客户端和服务器之间传递进行验证。可以作为请求头的一部分发送到服务器。Token 可以用于实现无状态的身份验证和授权机制，不受同源策略的限制。</li>
</ul>
<h4 id="cookie-常用属性"><a href="#cookie-常用属性" class="headerlink" title="cookie 常用属性"></a>cookie 常用属性</h4><ul>
<li><strong>Name</strong>：Cookie 的名称，用于标识特定的 Cookie。</li>
<li><strong>Value</strong>：Cookie 的值，存储在客户端的浏览器中，并在每次 HTTP 请求中被发送到服务器。</li>
<li><strong>Domain</strong>：指定 Cookie 可以发送到哪些域名。默认情况下，Cookie 只能发送到设置它的页面所在的域名。可以通过设置 Domain 属性来扩展 Cookie 的作用域。</li>
<li><strong>Path</strong>：指定 Cookie 可以发送到哪些路径。默认情况下，Cookie 只能发送到设置它的页面所在的路径。可以通过设置 Path 属性来限制 Cookie 的作用范围。</li>
<li><strong>Expires&#x2F;Max-Age</strong>：指定 Cookie 的过期时间。可以通过设置 Expires 属性为一个具体的日期时间或 Max-Age 属性为一个相对时间（秒数）来控制 Cookie 的有效期。</li>
</ul>
<h4 id="JWT-JSON-Web-Token"><a href="#JWT-JSON-Web-Token" class="headerlink" title="JWT(JSON Web Token)"></a>JWT(JSON Web Token)</h4><p><strong>JWT原理</strong></p>
<p>服务器认证完成以后，会生成一个JSON对象，发挥给用户。之后用户与服务器通信时，都会发回JSON对象。服务器完全只靠这个对象认证用户身份。为了防止数据篡改，服务器会在生成JSON对象时，加上签名。</p>
<p><strong>JWT结构</strong></p>
<p>token是一个很长的字符串，中间用点 (.) 分隔成三部分分别为 ( 头部-Header.负载-Payload.签名-Signature)。内部是没有换行的</p>
<p><strong>认证流程</strong></p>
<ol>
<li>浏览器发起请求登录，用户携带用户名和密码等信息</li>
<li>服务器验证身份，根据算法，将用户标识符打包生成token</li>
<li>服务器返回JWT信息给浏览器</li>
<li>浏览器发起请求获取用户资料，会带上刚刚拿到的token</li>
<li>服务器数据发现有携带token，会进行身份验证</li>
<li>身份验证通过会返回该用户资料</li>
</ol>
<p><strong>特点</strong></p>
<ul>
<li>JWT默认是不加密的</li>
<li>JWT也可以用于信息交换，降低服务器查询数据库的次数</li>
<li>最大缺点是，服务器不保存session状态，导致使用过程中，JWT一旦签发，在有效期内都能够使用，所以一旦泄露，任何人都可以获得该令牌的所有权限。除非加了其他逻辑判断。或者将有效期设置短一些</li>
</ul>
<h4 id="token-无感刷新"><a href="#token-无感刷新" class="headerlink" title="token 无感刷新"></a>token 无感刷新</h4><p>token无感刷新，是在用户已经登录后，获取token时，在该token快过期时，自动调用后端，后端身份验证成功后，返回新token<br>通过这种方式，可以在不打扰用户的情况下，自动刷新 Token，并确保用户的登录状态保持有效。</p>
<p>如果是app应用，可以 <strong>使用推送通知</strong> 或 **使用后台服务(Android 应用)**或 <strong>定时任务</strong>的方式进行无感刷新</p>
<h4 id="Websocket-相对于传统-HTTP-请求有哪些优势？"><a href="#Websocket-相对于传统-HTTP-请求有哪些优势？" class="headerlink" title="Websocket 相对于传统 HTTP 请求有哪些优势？"></a>Websocket 相对于传统 HTTP 请求有哪些优势？</h4><ol>
<li>实时性：Websocket 提供了双向通信通道，使服务器可以主动向客户端推送数据，而不需要等待客户端发起请求。这样就可以实现实时数据传输，适用于需要实时更新的应用场景，比如聊天应用、实时数据监控等。</li>
<li>较低的通信开销：传统的 HTTP 请求每次通信都需要建立连接、传输请求头，而 Websocket 在初始连接建立后，可以保持长连接，减少了每次通信的开销，只需轻量级的数据帧来传输数据。</li>
<li>更少的网络延迟：由于 Websocket 建立了长连接，避免了重复建立和关闭连接造成的网络延迟，使得通信更加高效。这对于实时交互和快速响应的应用更为重要。</li>
<li>跨域通信：Websocket 建立在 TCP 协议上，不受同源策略的限制，可以轻松实现跨域通信，而传统的 HTTP 请求就受同源策略的限制。</li>
<li>更灵活的数据格式：Websocket 可以传输任意格式的数据，包括二进制数据，而传统的 HTTP 请求主要是基于文本的格式。</li>
</ol>
<h4 id="Websocket-建立连接的握手过程。"><a href="#Websocket-建立连接的握手过程。" class="headerlink" title="Websocket 建立连接的握手过程。"></a>Websocket 建立连接的握手过程。</h4><ol>
<li><strong>客户端发送一个 HTTP GET 请求给服务器</strong><br>包含特殊的 Upgrade 和 Connection 头部，以请求升级到 WebSocket 协议。请求示例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1  </span><br><span class="line">Host: example.com  </span><br><span class="line">Upgrade: websocket  </span><br><span class="line">Connection: Upgrade  </span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==  </span><br><span class="line">Sec-WebSocket-Version: 13  </span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>Upgrade 头部指定协议升级到 WebSocket。</li>
<li>Connection 头部表示希望使用长连接。</li>
<li>Sec-WebSocket-Key 是一个随机生成的密钥，用于安全验证。</li>
</ul>
<ol start="2">
<li><strong>服务器收到请求后进行处理</strong></li>
</ol>
<ul>
<li>验证客户端的请求合法性。例如，验证 Upgrade 头部是否为 websocket，Sec-WebSocket-Version 是否支持服务器的版本等。</li>
<li>生成一个握手响应。响应示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols  </span><br><span class="line">Upgrade: websocket  </span><br><span class="line">Connection: Upgrade  </span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=  </span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>Status Code 为 101 表示切换协议成功。</li>
<li>Sec-WebSocket-Accept 是服务器使用客户端传递的 Sec-WebSocket-Key 计算得到的响应密钥。</li>
</ul>
<ol start="3">
<li><strong>客户端收到服务器的响应后进行处理</strong></li>
</ol>
<ul>
<li>验证服务器响应的合法性。比对 Sec-WebSocket-Accept 是否与客户端请求中的 Sec-WebSocket-Key 计算得到的结果匹配等。</li>
<li>若验证通过，握手成功，协议升级为 WebSocket，并开始进行双向数据传输。</li>
</ul>
<h4 id="DNS-解析流程是怎样的？"><a href="#DNS-解析流程是怎样的？" class="headerlink" title="DNS 解析流程是怎样的？"></a>DNS 解析流程是怎样的？</h4><ol>
<li>用户在浏览器中输入要访问的域名（例如，<a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com）。</a>.&#x2F;)</li>
<li>浏览器首先查询本地 DNS 缓存，如果缓存中存在对应的 IP 地址，则直接返回该地址，结束解析流程。</li>
<li>如果本地 DNS 缓存中不存在对应的 IP 地址，则浏览器向本地 DNS 服务器发送 DNS 查询请求。</li>
<li>本地 DNS 服务器（通常由 Internet 服务提供商提供）查询自己的缓存，如果有对应的 IP 地址，则直接返回给浏览器。</li>
<li>如果本地 DNS 服务器的缓存中没有对应的 IP 地址，则本地 DNS 服务器需要进行迭代查询：<ul>
<li>首先，本地 DNS 服务器向根域名服务器发送查询请求，询问顶级域名服务器（例如，.com 域名服务器）的 IP 地址。</li>
<li>根域名服务器返回顶级域名服务器的 IP 地址给本地 DNS 服务器。</li>
<li>本地 DNS 服务器再次向顶级域名服务器发送查询请求，询问次级域名服务器（例如，example.com 域名服务器）的 IP 地址。</li>
<li>次级域名服务器返回具体域名服务器（例如，<a target="_blank" rel="noopener" href="http://www.example.㯘/">www.example.com）的</a>-el7j&#x2F;) IP 地址给本地 DNS 服务器。</li>
</ul>
</li>
<li>本地 DNS 服务器将获取的 IP 地址返回给浏览器，并将 IP 地址保存在缓存中，以备将来的查询使用。</li>
<li>浏览器通过获得的 IP 地址与目标服务器建立 TCP 连接，发送 HTTP 请求，并获取相应的数据。</li>
</ol>
<h4 id="DNS-负载均衡、故障恢复等相关概念。"><a href="#DNS-负载均衡、故障恢复等相关概念。" class="headerlink" title="DNS 负载均衡、故障恢复等相关概念。"></a>DNS 负载均衡、故障恢复等相关概念。</h4><p>DNS 负载均衡和故障恢复是通过 DNS 服务器进行管理和调度的一种技术</p>
<ol>
<li><p>DNS 负载均衡（DNS Load Balancing）：<br>DNS 负载均衡是通过域名解析系统将请求分配到多个不同的服务器上，以实现负载均衡和分流流量的目的。当一个域名被解析为多个 IP 地址时，不同的请求可能会被分配到不同的服务器上，从而分散服务器负载，提高系统性能和稳定性。DNS 负载均衡可以基于权重、轮询、IP 地址范围等算法来实现。</p>
</li>
<li><p>DNS 故障恢复（DNS Failover）：<br>DNS 故障恢复是指当某个服务器或服务发生故障时，DNS 服务器可以迅速将流量重定向到备用服务器或服务上，以实现系统的高可用性和灾难恢复。通常情况下，DNS 服务器会通过监控机制来检测服务器的可用性，一旦发现故障，会自动将解析请求引导到备用服务器上，避免服务中断或延迟。</p>
</li>
<li><p>DNS 热备份和冷备份：</p>
<ul>
<li><p>DNS 热备份：热备份是备用服务器处于待命状态，可以即时接管流量，实时同步数据并保证服务的运行。在 DNS 故障恢复中，热备份通常用于快速响应和保证系统持续稳定运行。</p>
</li>
<li><p>DNS 冷备份：冷备份是备用服务器处于休眠状态，只有在主服务器故障时才会启动并接管流量，通常需要手动介入。在 DNS 故障恢复中，冷备份用于较低需求下的备份方案。</p>
</li>
</ul>
</li>
</ol>
<h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><ol>
<li><strong>物理层（Physical Layer）</strong>：<br>这是网络通信的最低层，负责定义物理介质以及数据的传输方式。它处理的是比特流的传输，包括电压、电流和物理接口等。</li>
<li><strong>数据链路层（Data Link Layer）</strong>：<br>数据链路层负责将原始比特流转换为数据帧，并在物理介质上进行传输。它还提供了错误检测和纠正机制，并管理不同设备之间的数据流动。</li>
<li><strong>网络层（Network Layer）</strong>：<br>网络层处理数据的分组和路由，为数据包选择最佳路径。它负责不同网络之间的连接和通信，并支持 IP 协议。</li>
<li><strong>传输层（Transport Layer）</strong>：<br>传输层提供可靠的端到端数据传输，处理数据分段和重组，以及错误检测和恢复。它还负责协议选择（如TCP或UDP）和端口管理。</li>
<li><strong>会话层（Session Layer）</strong>：<br>会话层负责建立、管理和终止应用程序之间的通信会话。它提供了会话控制和同步功能，以确保通信的顺序和可靠性。</li>
<li><strong>表示层（Presentation Layer）</strong>：<br>表示层负责数据的格式化和转换，以确保不同应用程序之间的数据兼容性。它处理数据的加密、压缩、编码等。</li>
<li><strong>应用层（Application Layer）</strong>：<br>应用层是最高层，提供用户与网络服务之间的接口。它包括各种应用协议，如HTTP、FTP、SMTP等，并处理特定应用程序的通信需求。</li>
</ol>
<h4 id="TCP-和-UDP-的区别及应用场景。"><a href="#TCP-和-UDP-的区别及应用场景。" class="headerlink" title="TCP 和 UDP 的区别及应用场景。"></a>TCP 和 UDP 的区别及应用场景。</h4><ol>
<li><strong>可靠性</strong>：<ul>
<li>TCP 是一种可靠的协议，它提供了数据包的确认和重传机制，以确保数据的可靠传输。它使用序列号、确认和超时重传等机制来保证数据的准确性和完整性。</li>
<li>UDP 是一种不可靠的协议，它不提供数据包的确认和重传机制。数据的传输没有确认机制，可能会丢失、重复或者无序。</li>
</ul>
</li>
<li><strong>连接性</strong>：<ul>
<li>TCP 是面向连接的协议，通过三次握手建立连接，并保持双方的连接状态。在数据传输完成后，通过四次挥手断开连接。</li>
<li>UDP 是无连接的协议，它不需要建立和维护连接。每个数据包都是独立的，可以独立地发送或接收。</li>
</ul>
</li>
<li><strong>传输效率</strong>：<ul>
<li>TCP 在传输可靠性方面提供了很好的保证，但由于引入了确认和重传机制，以及连接的建立和断开过程，会增加一些开销，导致传输效率相对较低。</li>
<li>UDP 没有确认和重传机制，以及连接建立过程，传输效率相对更高。数据包的发送和接收速度更快。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>TCP 适用于对数据传输可靠性要求较高的应用场景，如文件传输、电子邮件、网页浏览等。它可以确保数据的完整性和顺序，但传输效率相对较低。</li>
<li>UDP 适用于对实时性要求较高、数据传输可靠性要求相对较低的应用场景，如音视频流媒体、在线游戏、网络电话等。它传输效率高，但对数据的可靠性要求不高。</li>
</ul>
</li>
</ol>
<h4 id="TCP-三次握手四次挥手"><a href="#TCP-三次握手四次挥手" class="headerlink" title="TCP 三次握手四次挥手"></a>TCP 三次握手四次挥手</h4><h4 id="TCP-三次握手（Three-way-Handshake）："><a href="#TCP-三次握手（Three-way-Handshake）：" class="headerlink" title="TCP 三次握手（Three-way Handshake）："></a>TCP 三次握手（Three-way Handshake）：</h4><ol>
<li><strong>第一步：客户端发送 SYN</strong><ul>
<li>客户端向服务器发送一个 SYN（同步）报文段，表示希望与服务器建立连接。</li>
</ul>
</li>
<li><strong>第二步：服务器发送 SYN-ACK</strong><ul>
<li>服务器收到 SYN 报文后，会回复一个 SYN-ACK（同步-确认）报文段，表示同意与客户端建立连接，并确认客户端的 SYN。</li>
</ul>
</li>
<li><strong>第三步：客户端发送 ACK</strong><ul>
<li>客户端收到 SYN-ACK 后，会向服务器发送一个 ACK（确认）报文段，表示收到了服务器的确认，连接建立完成。</li>
</ul>
</li>
</ol>
<h4 id="TCP-四次挥手（Four-way-Handshake）："><a href="#TCP-四次挥手（Four-way-Handshake）：" class="headerlink" title="TCP 四次挥手（Four-way Handshake）："></a>TCP 四次挥手（Four-way Handshake）：</h4><ol>
<li><strong>第一步：客户端发送 FIN</strong><ul>
<li>当客户端需要关闭连接时，会向服务器发送一个 FIN（结束）报文段，表示不再发送数据，但仍允许接收数据。</li>
</ul>
</li>
<li><strong>第二步：服务器发送 ACK</strong><ul>
<li>服务器收到客户端的 FIN 后，会向客户端发送一个 ACK，确认收到 FIN。</li>
</ul>
</li>
<li><strong>第三步：服务器发送 FIN</strong><ul>
<li>当服务器也准备关闭连接时，会向客户端发送一个 FIN，表示不再发送数据，但仍允许接收数据。</li>
</ul>
</li>
<li><strong>第四步：客户端发送 ACK</strong><ul>
<li>客户端收到服务器的 FIN 后，会向服务器发送一个 ACK，确认收到 FIN。此时，连接完全关闭。</li>
</ul>
</li>
</ol>
<h4 id="什么是UTF-8编码"><a href="#什么是UTF-8编码" class="headerlink" title="什么是UTF-8编码"></a>什么是UTF-8编码</h4><p>UTF-8编码使用1个字节来表示ASCII字符，使用2到4个字节来表示其他Unicode字符。这种灵活性使得UTF-8成为目前最常用的Unicode编码方式之一。</p>
<p>字符编码的诞生过程可以追溯到计算机科学的早期。下面是字符编码的主要里程碑和发展过程：</p>
<ol>
<li>ASCII编码（1960年代）：ASCII（American Standard Code for Information Interchange）是最早的字符编码标准之一。它使用7位二进制数（后来扩展为8位），编码了一些基本的英文字母、数字和符号，用于在计算机系统中传输和存储英文字符。</li>
<li>扩展ASCII编码（1970年代）：随着计算机的发展和国际化需求的增加，ASCII编码的范围不再能满足其他语言的需求。因此，针对不同语言的扩展ASCII编码出现了，如ISO8859编码系列。</li>
<li>Unicode标准（1990年代）：为了解决多语言字符编码的问题，Unicode（统一码）标准被提出。Unicode致力于为全球范围内的所有字符和符号提供唯一的编码值。它采用了16位的编码空间，共能够表示65,536个字符。</li>
<li>UCS-2编码（1990年代）：Unicode最早采用的是UCS-2编码，即用两个字节表示一个字符。但由于这个编码方式无法表示超过65,536个字符的Unicode字符，后来被更先进的UTF-16编码取而代之。</li>
<li>UTF编码（1990年代）：为了兼容ASCII字符和较低范围的Unicode字符，UTF（Unicode Transformation Format）编码被引入。UTF-8、UTF-16和UTF-32是UTF编码的主要变种，分别使用不同的存储方式来表示Unicode字符，其中UTF-8是最常用的一种。</li>
<li>UTF-8编码的推广（2000年代）：随着互联网的发展和全球化的趋势，UTF-8成为了互联网上的主流字符编码方式。它具有兼容ASCII、变长编码和节省存储空间的特点，被广泛应用于文本处理、网页和网络通信等领域。</li>
</ol>
<h4 id="什么是浏览器兼容性问题？"><a href="#什么是浏览器兼容性问题？" class="headerlink" title="什么是浏览器兼容性问题？"></a>什么是浏览器兼容性问题？</h4><p>浏览器兼容性问题指的是页面代码在不同浏览器在解析和渲染网页时存在的差异，导致网页在不同浏览器上显示不一致或出现错误。</p>
<h4 id="如何检测和处理特定浏览器的兼容性问题？"><a href="#如何检测和处理特定浏览器的兼容性问题？" class="headerlink" title="如何检测和处理特定浏览器的兼容性问题？"></a>如何检测和处理特定浏览器的兼容性问题？</h4><p>可以使用现有的工具和服务对页面进行检测，BrowserStack和CrossBrowserTesting等工具。来检测不同浏览器的功能支持情况。</p>
<p>处理特定浏览器的兼容性问题通常需要使用特定的解决方案或技术，例如使用CSS前缀以适应某些浏览器的私有属性，或使用相应的JavaScript库和Polyfill来提供缺失的功能支持。</p>
<h4 id="CSS一般会出现什么样的兼容性问题，怎么解决"><a href="#CSS一般会出现什么样的兼容性问题，怎么解决" class="headerlink" title="CSS一般会出现什么样的兼容性问题，怎么解决"></a>CSS一般会出现什么样的兼容性问题，怎么解决</h4><p>常见的CSS兼容性问题包括盒模型差异、浮动布局问题、选择器支持不一致等。</p>
<ul>
<li>使用CSS Reset或Normalize.css来重置或规范化浏览器默认样式。</li>
<li>使用box-sizing属性来统一盒模型的解析方式。</li>
<li>避免过度使用浮动，可以使用Flexbox或Grid布局来代替。</li>
<li>针对选择器支持不一致，可以使用Polyfill或JavaScript库来提供相应的功能支持。</li>
</ul>
<h4 id="JavaScript一般会出现什么样的兼容性问题，怎么解决"><a href="#JavaScript一般会出现什么样的兼容性问题，怎么解决" class="headerlink" title="JavaScript一般会出现什么样的兼容性问题，怎么解决"></a>JavaScript一般会出现什么样的兼容性问题，怎么解决</h4><p>常见的JavaScript兼容性问题主要是一些浏览器对ES语法新特性支持度不同、浏览器API差异和JavaScript引擎的不同表现等。</p>
<ul>
<li>使用Babel等工具将ES6+的代码转换为ES5语法，以提供更好的兼容性。</li>
<li>检测并处理不同浏览器的API差异，可以使用Modernizr等库或自定义的特性检测方法。</li>
<li>针对不同JavaScript引擎的不同表现，可以使用Polyfill或特定库来提供功能支持，例如使用axios来规避XMLHttpRequest的差异性。</li>
</ul>
<h4 id="在项目开发中，如何保证跨浏览器的兼容性？"><a href="#在项目开发中，如何保证跨浏览器的兼容性？" class="headerlink" title="在项目开发中，如何保证跨浏览器的兼容性？"></a>在项目开发中，如何保证跨浏览器的兼容性？</h4><ul>
<li>使用项目构建工具进行代码转换达到兼容性处理</li>
<li>在开发过程中进行跨浏览器的测试，确保网页在主流浏览器上均有良好的展示效果。</li>
<li>遵循Web标准，使用符合规范的HTML、CSS和JavaScript代码。或者使用浏览器特定的兼容性代码</li>
<li>使用重置样式表或Normalize.css来规范化不同浏览器的默认样式。</li>
<li>使用兼容性库、Polyfill或特定框架，以提供一致的功能支持。</li>
<li>定期更新项目的依赖项和技术栈，以保持对最新浏览器版本的支持。</li>
</ul>
<h3 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h3><ol>
<li>数据库和表的创建：</li>
</ol>
<ul>
<li>创建数据库：<code>CREATE DATABASE database_name;</code></li>
<li>使用数据库：<code>USE database_name;</code></li>
<li>创建表：<code>CREATE TABLE table_name (column1 datatype, column2 datatype, ...);</code></li>
</ul>
<ol start="2">
<li>基本的数据类型：</li>
</ol>
<ul>
<li>整数类型：<code>INT, BIGINT, SMALLINT, TINYINT</code></li>
<li>浮点数类型：<code>FLOAT, DOUBLE, DECIMAL</code></li>
<li>字符串类型：<code>CHAR, VARCHAR, TEXT</code></li>
<li>日期和时间类型：<code>DATE, TIME, DATETIME</code></li>
</ul>
<ol start="3">
<li>数据的插入、查询、更新和删除：</li>
</ol>
<ul>
<li>插入数据：<code>INSERT INTO table_name (column1, column2) VALUES (value1, value2);</code></li>
<li>查询数据：<code>SELECT column1, column2 FROM table_name WHERE condition;</code></li>
<li>更新数据：<code>UPDATE table_name SET column1 = value1 WHERE condition;</code></li>
<li>删除数据：<code>DELETE FROM table_name WHERE condition;</code></li>
</ul>
<ol>
<li>过滤和排序：</li>
</ol>
<ul>
<li>过滤查询结果：<code>SELECT * FROM table_name WHERE condition;</code></li>
<li>排序查询结果：<code>SELECT * FROM table_name ORDER BY column ASC/DESC;</code></li>
</ul>
<ol>
<li>聚合函数和分组：</li>
</ol>
<ul>
<li>聚合函数：<code>SUM(), AVG(), COUNT(), MAX(), MIN()</code></li>
<li>分组查询：<code>SELECT column1, SUM(column2) FROM table_name GROUP BY column1;</code></li>
</ul>
<ol>
<li>索引和查询优化：</li>
</ol>
<ul>
<li>创建索引：<code>CREATE INDEX index_name ON table_name (column);</code></li>
<li>查询优化：使用合适的索引、避免使用<code>SELECT *</code>、使用<code>EXPLAIN</code>分析查询等方式。</li>
</ul>
<ol>
<li>外键约束：</li>
</ol>
<ul>
<li>创建外键约束：<code>ALTER TABLE table_name ADD CONSTRAINT fk_column FOREIGN KEY (column) REFERENCES other_table(column);</code></li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/07/01/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/" title="测试开发面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">测试开发面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/07/01/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/" title="测试开发面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-01</div><div class="title">测试开发面试题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/fafafa.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">fafafa</div><div class="author-info__description">记录笔记日志</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/fafafabaobei@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%ADuni-app%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">有关小程序中uni-app框架常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#uniapp-%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">uniapp 理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8UniApp%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%BC%98%E5%8A%BF%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">使用UniApp开发小程序有以下优势和特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniapp%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.</span> <span class="toc-text">uniapp适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%91%E6%88%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">挑战和解决方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B9%B3%E5%8F%B0%E5%B7%AE%E5%BC%82%E7%9A%84%E6%96%B9%E6%B3%95%E5%8C%85%E6%8B%AC%EF%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">解决小程序平台差异的方法包括：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniapp%E8%BF%9B%E8%A1%8C%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">uniapp进行条件编译的两种方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniapp-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6API"><span class="toc-number">1.7.</span> <span class="toc-text">uniapp 上传文件API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8"><span class="toc-number">1.8.</span> <span class="toc-text">监听页面滚动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E5%9B%BE%E7%89%87%E5%AE%BD%E5%BA%A6%E4%B8%8D%E5%8F%98%EF%BC%8C%E9%AB%98%E5%BA%A6%E8%87%AA%E5%8A%A8%E5%8F%98%E5%8C%96%EF%BC%8C%E4%BF%9D%E6%8C%81%E5%8E%9F%E5%9B%BE%E5%AE%BD%E9%AB%98%E4%B8%8D%E5%8F%98"><span class="toc-number">1.9.</span> <span class="toc-text">如何让图片宽度不变，高度自动变化，保持原图宽高不变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jquery%EF%BC%8Cvue%EF%BC%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%8Cuniapp%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">1.10.</span> <span class="toc-text">jquery，vue，小程序，uniapp本地数据存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">uniApp中如何进行页面跳转？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">uniApp中小程序如何进行数据缓存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%92%8C%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A%EF%BC%9F-%E4%BD%BF%E7%94%A8uniapp-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">1.13.</span> <span class="toc-text">uniApp中如何实现下拉刷新和上拉加载更多？ - 使用uniapp 生命周期函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">uniApp中如何获取用户地理位置信息？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">uniApp中如何获取设备信息？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95%E7%9A%84%E6%8F%90%E4%BA%A4%E5%92%8C%E9%AA%8C%E8%AF%81%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">uniApp中如何实现表单的提交和验证？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%99%BB%E5%BD%95%E6%8E%88%E6%9D%83%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">uniApp中如何实现页面的登录授权？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%88%86%E4%BA%AB%E5%88%B0%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">uniApp中如何实现页面的分享到朋友圈功能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">1.19.</span> <span class="toc-text">uniApp中如何实现图片预览功能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniApp%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="toc-number">1.20.</span> <span class="toc-text">uniApp中如何实现页面间的数据传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8uniApp%E4%B8%AD%EF%BC%8C%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8C%85%E6%8B%AC%E5%BA%94%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%82"><span class="toc-number">1.21.</span> <span class="toc-text">在uniApp中，页面的生命周期包括应用生命周期和页面生命周期。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95-uni-getUserProfile-uni-login"><span class="toc-number">1.22.</span> <span class="toc-text">实现微信登录 - uni.getUserProfile() &#x2F; uni.login()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#button-open-type-%E5%B1%9E%E6%80%A7"><span class="toc-number">1.23.</span> <span class="toc-text">button open-type 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E5%92%8Ch5%E6%94%AF%E4%BB%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.24.</span> <span class="toc-text">小程序支付和h5支付有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniapp-request-%E5%B0%81%E8%A3%85"><span class="toc-number">1.25.</span> <span class="toc-text">uniapp request 封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniapp-%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3"><span class="toc-number">1.26.</span> <span class="toc-text">uniapp 跨域解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UniApp%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EVue-js%E5%BC%80%E5%8F%91%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%B8%80%E5%A5%97%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%9C%A8%E5%A4%9A%E4%B8%AA%E5%B9%B3%E5%8F%B0%E4%B8%8A%E8%BF%90%E8%A1%8C%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%81H5%E3%80%81App%E7%AD%89%E3%80%82UniApp%E5%85%B7%E6%9C%89%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E4%BC%98%E5%8A%BF%E5%8C%85%E6%8B%AC%EF%BC%9A"><span class="toc-number">1.27.</span> <span class="toc-text">UniApp是一个基于Vue.js开发跨平台应用的框架，它可以通过一套代码实现在多个平台上运行，包括小程序、H5、App等。UniApp具有的特点和优势包括：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UniApp%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.28.</span> <span class="toc-text">UniApp的跨平台原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%91%E5%B8%83UniApp%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.29.</span> <span class="toc-text">打包和发布UniApp项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%8F%91%E5%B8%83%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.30.</span> <span class="toc-text">申请发布小程序的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#manifest-json"><span class="toc-number">1.31.</span> <span class="toc-text">manifest.json</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue"><span class="toc-number">2.</span> <span class="toc-text">vue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vue2%E5%92%8Cvue3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">vue2和vue3的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object-defineproperty%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%95%B0%E7%BB%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text">object.defineproperty如何监听基本数据类型，对象属性，数组，为什么无法获取数组变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue-%E4%B8%AD%E4%BD%BF%E7%94%A8-data-%E5%8C%85%E8%A3%B9%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.3.</span> <span class="toc-text">Vue 中使用 data 包裹属性的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%ADdata%E6%98%AF%E5%87%BD%E6%95%B0%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">2.4.</span> <span class="toc-text">组件中data是函数不是对象为什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%BB%84%E4%BB%B6%E9%97%B4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.5.</span> <span class="toc-text">vue生命周期和组件间生命周期顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.6.</span> <span class="toc-text">computed和watch的区别和应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1"><span class="toc-number">2.7.</span> <span class="toc-text">vue如何定义路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E5%92%8Chistory-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="toc-number">2.8.</span> <span class="toc-text">hash和history 路由模式区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-show%E5%92%8Cv-if%E5%8C%BA%E5%88%AB"><span class="toc-number">2.9.</span> <span class="toc-text">v-show和v-if区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.10.</span> <span class="toc-text">v-if和v-for的优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-for%E7%9A%84key%E4%BD%9C%E7%94%A8%EF%BC%8Cv-for%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E4%B8%AD%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8index%E4%BD%9C%E4%B8%BAkey"><span class="toc-number">2.11.</span> <span class="toc-text">v-for的key作用，v-for遍历数组中能否使用index作为key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.12.</span> <span class="toc-text">vue组件通信方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vuex-pinia"><span class="toc-number">2.13.</span> <span class="toc-text">vuex&#x2F; pinia</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-router"><span class="toc-number">3.</span> <span class="toc-text">vue - router</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-router-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">vue-router 底层原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue-Router%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">Vue Router是什么？它解决了什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue-Router%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">Vue Router中的路由模式有哪些？它们有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue-Router%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">Vue Router的路由导航守卫有哪些？它们的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">如何实现动态路由？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Vue%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%BF%9B%E8%A1%8C%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">如何在Vue组件中进行路由跳转？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue-Router%E4%B8%AD%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%88%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%EF%BC%89%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">Vue Router中怎样实现路由懒加载（按需加载）？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex"><span class="toc-number">4.</span> <span class="toc-text">vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vuex%E7%8A%B6%E6%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.1.</span> <span class="toc-text">vuex状态持久化解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vuex%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">vuex的设计与实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pinia"><span class="toc-number">5.</span> <span class="toc-text">pinia</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">双向数据绑定原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-model-vue2%E4%B8%8Evue3%E5%88%86%E5%88%AB%E4%BD%9C%E7%94%A8%E5%9C%A8%E6%99%AE%E9%80%9A%E5%85%83%E7%B4%A0%E5%92%8C%E7%BB%84%E4%BB%B6%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.</span> <span class="toc-text">v-model - vue2与vue3分别作用在普通元素和组件元素的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextTick%E4%BD%9C%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">nextTick作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDom"><span class="toc-number">5.4.</span> <span class="toc-text">虚拟Dom</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDom%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90"><span class="toc-number">5.5.</span> <span class="toc-text">虚拟Dom怎么生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA"><span class="toc-number">5.6.</span> <span class="toc-text">前端大量数据展示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-%E9%A1%B9%E7%9B%AESPA%E5%8D%95%E9%A1%B5%E9%9D%A2-SEO%E4%BC%98%E5%8C%96"><span class="toc-number">5.7.</span> <span class="toc-text">vue  项目SPA单页面 SEO优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React"><span class="toc-number">6.</span> <span class="toc-text">React</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#react%E7%90%86%E8%A7%A3-%E5%92%8C-%E7%89%B9%E5%BE%81"><span class="toc-number">6.1.</span> <span class="toc-text">react理解 和 特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVC%E5%92%8CMVVM"><span class="toc-number">6.2.</span> <span class="toc-text">MVC和MVVM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flux%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.3.</span> <span class="toc-text">Flux是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFjsx"><span class="toc-number">6.4.</span> <span class="toc-text">什么是jsx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react%E5%BC%95%E5%85%A5css%E6%96%B9%E5%BC%8F"><span class="toc-number">6.5.</span> <span class="toc-text">react引入css方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0react%E7%BB%84%E4%BB%B6%E9%97%B4%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB"><span class="toc-number">6.6.</span> <span class="toc-text">怎么实现react组件间过渡动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.7.</span> <span class="toc-text">React 工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">6.8.</span> <span class="toc-text">react 事件机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react-%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">6.9.</span> <span class="toc-text">react 绑定事件的方式有哪些，有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9"><span class="toc-number">6.10.</span> <span class="toc-text">React有什么优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react%E4%B8%AD%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">6.11.</span> <span class="toc-text">react中类组件和函数组件的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.12.</span> <span class="toc-text">组件生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B7%9F%E8%B8%AA%E5%8A%9F%E8%83%BD%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="toc-number">6.13.</span> <span class="toc-text">如何跟踪功能组件的卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">6.14.</span> <span class="toc-text">react响应式原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#render%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-number">6.15.</span> <span class="toc-text">render函数的理解和渲染过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useMemo%E5%92%8CuseCallback-%E5%8C%BA%E5%88%AB"><span class="toc-number">6.16.</span> <span class="toc-text">hooks - useMemo和useCallback 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useState%E5%92%8CuseRef-%E5%8C%BA%E5%88%AB"><span class="toc-number">6.17.</span> <span class="toc-text">hooks - useState和useRef 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useEffect%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%8F%AA%E4%BC%A0%E4%B8%80%E4%B8%AA%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%88%96%E7%A9%BA%E6%95%B0%E7%BB%84%E6%88%96%E4%B8%8D%E4%BC%A0%E4%BE%9D%E8%B5%96%E9%A1%B9%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.18.</span> <span class="toc-text">useEffect依赖项只传一个依赖项或空数组或不传依赖项的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useEffect%E7%9A%84return-%E5%87%BD%E6%95%B0%E5%9C%A8%E4%BE%9D%E8%B5%96%E9%A1%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="toc-number">6.19.</span> <span class="toc-text">useEffect的return 函数在依赖项不同的情况下，有何区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-Hooks%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0"><span class="toc-number">6.20.</span> <span class="toc-text">React Hooks底层原理，如何实现状态更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">6.21.</span> <span class="toc-text">怎么实现全局数据存储?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%A6%82%E4%BD%95%E8%AE%A9%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%8D%E6%B8%B2%E6%9F%93%EF%BC%8C%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8Chooks%E6%96%B9%E6%B3%95"><span class="toc-number">6.22.</span> <span class="toc-text">父组件渲染如何让子组件不渲染，类组件和hooks方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#state-%E7%8A%B6%E6%80%81-%E5%92%8Cprops-%E5%B1%9E%E6%80%A7-%E5%8C%BA%E5%88%AB"><span class="toc-number">6.23.</span> <span class="toc-text">state( 状态)和props( 属性)区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super-%E5%92%8C-super-props"><span class="toc-number">6.24.</span> <span class="toc-text">super() 和 super(props)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFprops%E9%80%8F%E4%BC%A0"><span class="toc-number">6.25.</span> <span class="toc-text">什么是props透传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReact-%E4%B8%8A%E4%B8%8B%E6%96%87-contest"><span class="toc-number">6.26.</span> <span class="toc-text">什么是React 上下文 - contest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">6.27.</span> <span class="toc-text">渲染数组元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8map-%E6%97%B6%E9%9C%80%E8%A6%81key"><span class="toc-number">6.28.</span> <span class="toc-text">为什么使用map() 时需要key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">6.29.</span> <span class="toc-text">受控组件和非受控组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%A7%BB%E9%99%A4%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">6.30.</span> <span class="toc-text">如何实现移除定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">6.31.</span> <span class="toc-text">react 组件通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useState%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">6.32.</span> <span class="toc-text">hooks - useState有什么特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useEffect%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">6.33.</span> <span class="toc-text">hooks - useEffect有什么特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useMemo%E7%94%A8%E9%80%94%EF%BC%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">6.34.</span> <span class="toc-text">hooks - useMemo用途？如何工作？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useCallback%E7%94%A8%E9%80%94%EF%BC%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">6.35.</span> <span class="toc-text">hooks - useCallback用途？如何工作？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useMemo%E5%92%8CuseCallback%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">6.36.</span> <span class="toc-text">hooks - useMemo和useCallback有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useContext%E7%94%A8%E9%80%94-%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-number">6.37.</span> <span class="toc-text">hooks - useContext用途? 如何工作?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-useRef-%E7%94%A8%E9%80%94%EF%BC%9F%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">6.38.</span> <span class="toc-text">hooks - useRef 用途？作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReact-memo"><span class="toc-number">6.39.</span> <span class="toc-text">什么是React.memo()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReact-Fragment"><span class="toc-number">6.40.</span> <span class="toc-text">什么是React Fragment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B7%9F%E8%B8%AA%E5%BC%95%E7%94%A8%E5%8A%9F%E8%83%BD%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">6.41.</span> <span class="toc-text">如何跟踪引用功能组件中对象字段的变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AEDOM%E5%85%83%E7%B4%A0"><span class="toc-number">6.42.</span> <span class="toc-text">如何访问DOM元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%87%BA%E5%8F%91%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E8%80%83%E8%99%91%E4%BB%80%E4%B9%88"><span class="toc-number">6.43.</span> <span class="toc-text">react合成事件，为什么不使用浏览器原生事件，出发点是什么，考虑什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react18%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">6.44.</span> <span class="toc-text">react18新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-diff-%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.45.</span> <span class="toc-text">React diff 算法介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-Fiber"><span class="toc-number">6.46.</span> <span class="toc-text">React Fiber</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-router"><span class="toc-number">7.</span> <span class="toc-text">React-router</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#React-Router-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">React Router 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-Router-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">React Router 的主要特点是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-Router-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%98%AF%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">7.3.</span> <span class="toc-text">React Router 的核心组件是哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BrowserRouter-%E5%92%8C-HashRouter-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.4.</span> <span class="toc-text">BrowserRouter 和 HashRouter 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%EF%BC%9F"><span class="toc-number">7.5.</span> <span class="toc-text">如何在代码中定义路由？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-React-Router-%E4%B8%AD%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">7.6.</span> <span class="toc-text">如何在 React Router 中传递参数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%BC%E8%88%AA%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1%EF%BC%9F"><span class="toc-number">7.7.</span> <span class="toc-text">如何导航到另一个路由？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-React-Router-%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%9F"><span class="toc-number">7.8.</span> <span class="toc-text">如何在 React Router 中使用重定向？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-React-Router-%E4%B8%AD%E5%A4%84%E7%90%86%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%EF%BC%9F"><span class="toc-number">7.9.</span> <span class="toc-text">如何在 React Router 中处理嵌套路由？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-Router-%E6%8F%90%E4%BE%9B%E5%93%AA%E4%BA%9B%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">7.10.</span> <span class="toc-text">React Router 提供哪些导航守卫功能？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redux"><span class="toc-number">8.</span> <span class="toc-text">Redux</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedux"><span class="toc-number">8.1.</span> <span class="toc-text">什么是Redux</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redux%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9"><span class="toc-number">8.2.</span> <span class="toc-text">Redux有什么优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redux-%E9%81%B5%E5%BE%AA%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.3.</span> <span class="toc-text">Redux 遵循的三个原则是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9-%E2%80%9C%E5%8D%95%E4%B8%80%E4%BA%8B%E5%AE%9E%E6%9D%A5%E6%BA%90%E2%80%9D-%E6%9C%89%E4%BB%80%E4%B9%88%E7%90%86%E8%A7%A3"><span class="toc-number">8.4.</span> <span class="toc-text">对 “单一事实来源” 有什么理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA-Redux-%E7%BB%84%E4%BB%B6"><span class="toc-number">8.5.</span> <span class="toc-text">列出 Redux 组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-Redux-%E6%B5%81%E5%8A%A8"><span class="toc-number">8.6.</span> <span class="toc-text">数据如何通过 Redux 流动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Redux%E4%B8%AD%E5%AE%9A%E4%B9%89Action"><span class="toc-number">8.7.</span> <span class="toc-text">如何在Redux中定义Action</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8AReducer%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.8.</span> <span class="toc-text">解释Reducer的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Store%E5%9C%A8Redux%E4%B8%AD%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.9.</span> <span class="toc-text">Store在Redux中的意义是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redux%E4%B8%8EFlux%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-number">8.10.</span> <span class="toc-text">Redux与Flux有什么不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redux-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%8C%85%E6%8B%AC-Store%E3%80%81Action%E3%80%81Reducer-%E5%92%8C-Middleware%E3%80%82"><span class="toc-number">8.11.</span> <span class="toc-text">Redux 的核心概念包括 Store、Action、Reducer 和 Middleware。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">8.12.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redux%E6%95%B0%E6%8D%AE%E4%B8%8D%E6%8C%81%E4%B9%85%E5%8C%96%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">8.13.</span> <span class="toc-text">redux数据不持久化怎么解决</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack"><span class="toc-number">9.</span> <span class="toc-text">Webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Webpack%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">什么是 Webpack？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Webpack-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">Webpack 的核心概念有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack-%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B"><span class="toc-number">9.3.</span> <span class="toc-text">webpack 打包过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-Webpack-%E7%9A%84%E8%BE%93%E5%87%BA%E9%80%89%E9%A1%B9%EF%BC%9F"><span class="toc-number">9.4.</span> <span class="toc-text">如何配置 Webpack 的输出选项？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Loader%EF%BC%8C%E4%B8%BE%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9F"><span class="toc-number">9.5.</span> <span class="toc-text">什么是 Loader，举几个常见的例子？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%92%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%9F"><span class="toc-number">9.6.</span> <span class="toc-text">什么是插件，如何使用它？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Webpack-%E4%B8%AD%E7%9A%84%E7%83%AD%E6%A8%A1%E5%9D%97%E6%9B%BF%E6%8D%A2%EF%BC%88Hot-Module-Replacement-HMR%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">9.7.</span> <span class="toc-text">Webpack 中的热模块替换（Hot Module Replacement, HMR）是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%EF%BC%9F"><span class="toc-number">9.8.</span> <span class="toc-text">如何实现代码分割？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-Webpack-%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E3%80%82"><span class="toc-number">9.9.</span> <span class="toc-text">解释一下 Webpack 的四个生命周期钩子。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%85%8D%E7%BD%AE-Webpack%EF%BC%9F"><span class="toc-number">9.10.</span> <span class="toc-text">如何在生产环境和开发环境中配置 Webpack？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96-Commonjs%EF%BC%8CAMD%EF%BC%8CCMD%EF%BC%8CUMD%EF%BC%8CES6-Module%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">9.11.</span> <span class="toc-text">模块化 Commonjs，AMD，CMD，UMD，ES6 Module分别有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack%E8%83%BD%E5%A4%84%E7%90%86%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%8D%E8%83%BD%E5%A4%84%E7%90%86%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6"><span class="toc-number">9.12.</span> <span class="toc-text">webpack能处理什么文件，不能处理什么文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack-%E5%A4%84%E7%90%86%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">9.13.</span> <span class="toc-text">webpack 处理性能优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPA%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88-%E5%87%8F%E5%B0%91%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4"><span class="toc-number">9.14.</span> <span class="toc-text">SPA首屏优化方案 - 减少白屏时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack%E5%92%8Cvite%E5%8C%BA%E5%88%AB"><span class="toc-number">9.15.</span> <span class="toc-text">webpack和vite区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#html-css"><span class="toc-number">10.</span> <span class="toc-text">html+css</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3html%EF%BC%8Ccss%EF%BC%8Cjs"><span class="toc-number">10.1.</span> <span class="toc-text">如何理解html，css，js</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#html%E4%BB%A3%E7%A0%81%E7%AC%AC%E4%B8%80%E8%A1%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">10.2.</span> <span class="toc-text">html代码第一行有什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#html%E7%9A%84meta%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">10.3.</span> <span class="toc-text">html的meta属性有哪些，都是什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">10.4.</span> <span class="toc-text">隐藏一个元素有哪些方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8Ch5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">10.5.</span> <span class="toc-text">小程序和h5有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3%E4%BB%8B%E7%BB%8D"><span class="toc-number">10.6.</span> <span class="toc-text">盒子模型理解介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css%E7%9A%84%E5%87%A0%E7%A7%8D%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">10.7.</span> <span class="toc-text">css的几种引入方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css-%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">10.8.</span> <span class="toc-text">css 布局方式有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80"><span class="toc-number">10.9.</span> <span class="toc-text">讲一下弹性盒子布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%A4%B4%E7%9A%84css%E5%B1%9E%E6%80%A7"><span class="toc-number">10.10.</span> <span class="toc-text">@开头的css属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS%E9%95%BF%E5%BA%A6%E5%8D%95%E4%BD%8D"><span class="toc-number">10.11.</span> <span class="toc-text">CSS长度单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-%E4%B8%AD%EF%BC%8Cdisplay-%E5%B1%9E%E6%80%A7"><span class="toc-number">10.12.</span> <span class="toc-text">CSS 中，display 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E7%9A%844%E4%B8%AD%E5%86%99%E6%B3%95"><span class="toc-number">10.13.</span> <span class="toc-text">css元素居中的4中写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">10.14.</span> <span class="toc-text">css绘制三角形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8css%E8%AE%BE%E7%BD%AE0-5px%E7%9A%84%E7%BA%BF%E6%9D%A1"><span class="toc-number">10.15.</span> <span class="toc-text">使用css设置0.5px的线条</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS3%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">10.16.</span> <span class="toc-text">CSS3实现动画效果的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8"><span class="toc-number">10.17.</span> <span class="toc-text">css清除浮动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#margin-%E5%9D%8D%E5%A1%8C"><span class="toc-number">10.18.</span> <span class="toc-text">margin 坍塌</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFC%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">10.19.</span> <span class="toc-text">BFC实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9IFC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">10.20.</span> <span class="toc-text">对IFC的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2"><span class="toc-number">10.21.</span> <span class="toc-text">媒体查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css%E5%9B%9E%E6%B5%81%EF%BC%8C%E9%87%8D%E7%BB%98%EF%BC%8C%E5%90%88%E5%B9%B6%E5%9B%BE%E5%B1%82%EF%BC%8CGPU-%E5%8A%A0%E9%80%9F"><span class="toc-number">10.22.</span> <span class="toc-text">css回流，重绘，合并图层，GPU 加速</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">10.23.</span> <span class="toc-text">关于适配问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%A8%E6%9E%B6%E5%B1%8F%E5%8E%9F%E7%90%86"><span class="toc-number">10.24.</span> <span class="toc-text">骨架屏原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E7%A9%BF%E9%80%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">10.25.</span> <span class="toc-text">鼠标穿透属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css%E5%8A%A8%E7%94%BB"><span class="toc-number">10.26.</span> <span class="toc-text">css动画</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SCSS"><span class="toc-number">11.</span> <span class="toc-text">SCSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js"><span class="toc-number">12.</span> <span class="toc-text">js</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%82%A8%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="toc-number">12.1.</span> <span class="toc-text">说说js中的数据类型,基本数据类型和引用数据类型区别，以及存储上的差别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">12.2.</span> <span class="toc-text">隐式转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89%E5%92%8C-%EF%BC%88%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89"><span class="toc-number">12.3.</span> <span class="toc-text">&#x3D;&#x3D;（相等运算符）和 &#x3D;&#x3D;&#x3D;（严格相等运算符）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">12.4.</span> <span class="toc-text">数组方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%E5%92%8C%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">12.5.</span> <span class="toc-text">数组扁平化和数组去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forEach-%E5%92%8C-map-%E5%8C%BA%E5%88%AB"><span class="toc-number">12.6.</span> <span class="toc-text">forEach 和 map 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">12.7.</span> <span class="toc-text">字符串常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">12.8.</span> <span class="toc-text">JavaScript 中常用的对象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof%E5%92%8Cinstanceof-%E5%8C%BA%E5%88%AB"><span class="toc-number">12.9.</span> <span class="toc-text">typeof和instanceof 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof-null-%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF-%E2%80%9Cobject%E2%80%9D%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">12.10.</span> <span class="toc-text">typeof null 返回的是 “object”，为什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#js%E5%8E%9F%E5%9E%8B%EF%BC%9F%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">12.11.</span> <span class="toc-text">js原型？原型链？有什么特点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">12.12.</span> <span class="toc-text">作用域和作用域链的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.13.</span> <span class="toc-text">普通函数和箭头函数的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9this%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">12.14.</span> <span class="toc-text">谈谈对this的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call%E3%80%81apply-%E5%92%8C-bind-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.15.</span> <span class="toc-text">call、apply 和 bind 方法的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BF%AE%E6%94%B9this%E6%8C%87%E5%90%91%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">12.16.</span> <span class="toc-text">其他修改this指向的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ajax%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">12.17.</span> <span class="toc-text">ajax的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#axios%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">12.18.</span> <span class="toc-text">axios的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%9C%A8%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E5%86%85"><span class="toc-number">12.19.</span> <span class="toc-text">如何判断一个元素在可视区域内</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">12.20.</span> <span class="toc-text">函数柯里化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E2%80%A6in%E2%80%A6-%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7-%E5%92%8C-for%E2%80%A6of%E2%80%A6-%E5%8C%BA%E5%88%AB-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">12.21.</span> <span class="toc-text">for…in… (可枚举属性)和 for…of… 区别(迭代器)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#js-DOM%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">12.22.</span> <span class="toc-text">js DOM事件模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">12.23.</span> <span class="toc-text">创建对象有哪些方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C"><span class="toc-number">12.24.</span> <span class="toc-text">new 操作符具体操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8prototype%E4%B8%AD"><span class="toc-number">12.25.</span> <span class="toc-text">什么数据存在对象中，什么数据存在prototype中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADa%E6%98%AF%E4%B8%8D%E6%98%AFb%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">12.26.</span> <span class="toc-text">如何判断a是不是b的实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB"><span class="toc-number">12.27.</span> <span class="toc-text">深拷贝和浅拷贝区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#json-stringify-%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%88%B0"><span class="toc-number">12.28.</span> <span class="toc-text">json.stringify() 是干什么的，什么时候会使用到</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%8C%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">12.29.</span> <span class="toc-text">防抖和节流，及应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E9%87%8F%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%BB%9A%E5%8A%A8"><span class="toc-number">12.30.</span> <span class="toc-text">大量加载数据怎么优化，怎么避免滚动条滚动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%97%E8%A1%A8%E8%99%9A%E6%8B%9F%E6%BB%9A%E5%8A%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.31.</span> <span class="toc-text">图片懒加载和列表虚拟滚动怎么实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">12.32.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%94%9Fjs%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">12.33.</span> <span class="toc-text">原生js创建自定义事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%8E%E4%B9%88%E5%81%9A%E9%A2%84%E8%A7%88"><span class="toc-number">12.34.</span> <span class="toc-text">文件上传怎么做预览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%A7%92%E4%BC%A0%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.35.</span> <span class="toc-text">文件秒传怎么实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E4%B8%8A%E4%BC%A0"><span class="toc-number">12.36.</span> <span class="toc-text">切片上传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA10g%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%88%86%E7%89%87%EF%BC%8C%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E5%90%88%E9%80%82%E7%9A%84%E5%88%86%E7%89%87%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%88%86%E7%89%87hash%E8%BF%87%E7%A8%8B%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-number">12.37.</span> <span class="toc-text">一个10g文件怎么进行分片，怎么确定合适的分片大小，分片hash过程怎么优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-number">12.38.</span> <span class="toc-text">断点续传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%8C%E4%B8%8B%E6%8B%89%E5%8A%A0%E8%BD%BD"><span class="toc-number">12.39.</span> <span class="toc-text">上拉刷新，下拉加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#web%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2"><span class="toc-number">12.40.</span> <span class="toc-text">web常见攻击方式，如何预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88"><span class="toc-number">12.41.</span> <span class="toc-text">js执行上下文和执行栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98"><span class="toc-number">12.42.</span> <span class="toc-text">函数缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">12.43.</span> <span class="toc-text">js数据结构的了解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DOM-BOM%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="toc-number">12.44.</span> <span class="toc-text">DOM&#x2F;BOM常见操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-http%E7%BC%93%E5%AD%98"><span class="toc-number">12.45.</span> <span class="toc-text">浏览器缓存机制 - http缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98-cookie-sessionStorage-localStorage-%E5%8C%BA%E5%88%AB"><span class="toc-number">12.46.</span> <span class="toc-text">浏览器缓存机制 - 浏览器缓存 cookie, sessionStorage,localStorage 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6"><span class="toc-number">12.47.</span> <span class="toc-text">事件循环机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">12.48.</span> <span class="toc-text">宏任务之间的优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E4%B8%8B%E8%BD%BD%E3%80%81%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98%E4%B8%AD%E4%B8%8B%E8%BD%BD%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">12.49.</span> <span class="toc-text">&lt;a&gt;标签下载、通过接口获取文件缓存中下载有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%81%E5%BC%8F%E4%B8%8B%E8%BD%BD"><span class="toc-number">12.50.</span> <span class="toc-text">什么是流式下载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">12.51.</span> <span class="toc-text">js垃圾回收机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84"><span class="toc-number">12.52.</span> <span class="toc-text">内存泄漏是怎么产生的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sql%E8%B0%83%E4%BC%98"><span class="toc-number">12.53.</span> <span class="toc-text">sql调优</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webworker%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E9%98%BB%E5%A1%9E%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8A%8Ajs%E5%86%85%E5%AE%B9%E6%94%BE%E5%88%B0webworker%E8%BF%90%E8%A1%8C"><span class="toc-number">12.54.</span> <span class="toc-text">webworker多线程可以避免阻塞，为什么不把js内容放到webworker运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSR%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">12.55.</span> <span class="toc-text">SSR服务端渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSR%E4%BC%9A%E5%AD%98%E5%9C%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%90%97"><span class="toc-number">12.56.</span> <span class="toc-text">SSR会存在跨域问题吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%90%8E%E7%AB%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">12.57.</span> <span class="toc-text">前端与后端之间的实时通信的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2websocket%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.58.</span> <span class="toc-text">讲讲websocket怎么使用，怎么实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B"><span class="toc-number">12.59.</span> <span class="toc-text">JWT认证过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86"><span class="toc-number">12.60.</span> <span class="toc-text">数据加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8Bpromise"><span class="toc-number">12.61.</span> <span class="toc-text">讲解一下promise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#promise%E5%90%8E%E9%9D%A2%E5%A6%82%E6%9E%9C%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%80%BC%EF%BC%8C-then-%E6%80%8E%E4%B9%88%E4%BC%A0%E5%80%BC"><span class="toc-number">12.62.</span> <span class="toc-text">promise后面如果有多个值，.then() 怎么传值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async-await%E7%90%86%E8%A7%A3"><span class="toc-number">12.63.</span> <span class="toc-text">async await理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async-await%E6%AF%94promise%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF"><span class="toc-number">12.64.</span> <span class="toc-text">async await比promise有什么优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async-await%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">12.65.</span> <span class="toc-text">async await的底层原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#generator%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">12.66.</span> <span class="toc-text">generator的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pnpm%E8%BD%AF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%8C%BA%E5%88%AB"><span class="toc-number">12.67.</span> <span class="toc-text">pnpm软连接和硬链接区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pnpm-hoist%E6%9C%BA%E5%88%B6"><span class="toc-number">12.68.</span> <span class="toc-text">pnpm hoist机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pnpm%E5%8C%85%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%8C%E4%B8%89%E5%B1%82%E5%AF%BB%E5%9D%80"><span class="toc-number">12.69.</span> <span class="toc-text">pnpm包的结构，三层寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E4%BA%8B%E5%B9%BD%E7%81%B5%E4%BE%9D%E8%B5%96%EF%BC%8C%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">12.70.</span> <span class="toc-text">什么事幽灵依赖，会引发什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#package-A-%E5%92%8Cpackage-B-%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8C%85%EF%BC%8C%E5%8D%B4%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%9F%E4%B8%80%E7%89%88%E6%9C%AC"><span class="toc-number">12.71.</span> <span class="toc-text">package A 和package B 依赖同一个包，却不同版本，如何统一版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%EF%BC%8C%E9%87%8D%E6%8E%92"><span class="toc-number">12.72.</span> <span class="toc-text">关于浏览器渲染原理，重排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%BA%93%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.73.</span> <span class="toc-text">组件库怎么做，怎么实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%A1%86%E6%9E%B6%EF%BC%8C%E7%9B%B8%E6%AF%94%E5%8E%9F%E7%94%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">12.74.</span> <span class="toc-text">如何看待框架，相比原生解决了什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VDOM%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E7%9B%B8%E6%AF%94%E5%8E%9F%E7%94%9F%E5%AF%B9%E6%AF%94%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8VDOM"><span class="toc-number">12.75.</span> <span class="toc-text">VDOM是什么，相比原生对比为什么要使用VDOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AST%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">12.76.</span> <span class="toc-text">AST是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BST%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">12.77.</span> <span class="toc-text">BST是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8BST%E5%AE%9E%E7%8E%B0-%E5%8C%85%E6%8B%ACinsert%EF%BC%8Csearch%EF%BC%8Cdelete"><span class="toc-number">12.78.</span> <span class="toc-text">使用BST实现 包括insert，search，delete</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6-HTML5-CSS3-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">13.</span> <span class="toc-text">ES6+,HTML5,CSS3 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ES6"><span class="toc-number">13.1.</span> <span class="toc-text">ES6+</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML5"><span class="toc-number">13.2.</span> <span class="toc-text">HTML5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS3"><span class="toc-number">13.3.</span> <span class="toc-text">CSS3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Electron"><span class="toc-number">14.</span> <span class="toc-text">Electron</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Electron%E8%BD%AF%E4%BB%B6%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C"><span class="toc-number">14.1.</span> <span class="toc-text">Electron软件自动更新操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9Electron%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%E3%80%82"><span class="toc-number">14.2.</span> <span class="toc-text">请介绍一下你对Electron的理解以及你的工作经验。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Electron-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">14.3.</span> <span class="toc-text">Electron 优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFElectron%EF%BC%88%E5%8E%9F%E5%AD%90%EF%BC%89%E6%A1%86%E6%9E%B6%EF%BC%9F%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">14.4.</span> <span class="toc-text">什么是Electron（原子）框架？它是如何工作的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Electron%E4%B8%8E%E4%BC%A0%E7%BB%9FWeb%E5%BC%80%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">14.5.</span> <span class="toc-text">Electron与传统Web开发的区别是什么？它的优势和适用场景有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8BElectron%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%EF%BC%88%E4%B8%BB%E8%BF%9B%E7%A8%8B%E3%80%81%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%EF%BC%89%E3%80%81%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="toc-number">14.6.</span> <span class="toc-text">请说明一下Electron的主要组成部分（主进程、渲染进程）、通信方式以及如何进行进程间的通信？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Electron%E6%9E%84%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%88Desktop-Application%EF%BC%89%EF%BC%9F%E8%AF%B7%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E6%95%B4%E4%B8%AA%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E3%80%82"><span class="toc-number">14.7.</span> <span class="toc-text">如何使用Electron构建桌面应用程序（Desktop Application）？请描述一下整个开发流程和注意事项。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Electron%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%EF%BC%88%E5%A6%82electron-builder%E3%80%81electron-packager%EF%BC%89%E7%9A%84%E4%BA%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">14.8.</span> <span class="toc-text">请谈谈你对Electron打包工具（如electron-builder、electron-packager）的了解和使用经验，有哪些注意事项和优化方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BElectron%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A8%A1%E5%9D%97%E6%88%96%E5%BA%93%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%82"><span class="toc-number">14.9.</span> <span class="toc-text">介绍一下Electron开发中常用的一些模块或库，以及它们的作用和使用场景。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA%E4%B8%80%E4%B8%8BElectron%E5%AE%89%E5%85%A8%E6%80%A7%E6%96%B9%E9%9D%A2%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%94%BB%E5%87%BB%E5%92%8C%E6%8F%90%E9%AB%98%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9F"><span class="toc-number">14.10.</span> <span class="toc-text">讨论一下Electron安全性方面需要注意的事项，如何防止攻击和提高应用程序的安全性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%9C%A8%E4%BD%BF%E7%94%A8Electron%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E6%8C%91%E6%88%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%A0%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E5%92%8C%E6%95%99%E8%AE%AD%E3%80%82"><span class="toc-number">14.11.</span> <span class="toc-text">请描述一下你在使用Electron开发过程中遇到的挑战和解决方案，以及你的经验总结和教训。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%A0%E9%9C%80%E8%A6%81%E5%AF%B9%E4%B8%80%E4%B8%AA%E7%8E%B0%E6%9C%89%E7%9A%84Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-Vue-React%E9%A1%B9%E7%9B%AE-%E8%BF%9B%E8%A1%8C%E7%A7%BB%E6%A4%8D%E5%88%B0%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%8C%E4%BD%A0%E5%B0%86%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%92%8C%E4%BD%BF%E7%94%A8Electron%E6%9D%A5%E5%AE%8C%E6%88%90%E8%BF%99%E4%B8%AA%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-number">14.12.</span> <span class="toc-text">如果你需要对一个现有的Web应用程序(Vue, React项目)进行移植到桌面应用程序，你将如何选择和使用Electron来完成这个任务？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ts"><span class="toc-number">15.</span> <span class="toc-text">ts</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9typescript%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">15.1.</span> <span class="toc-text">说说对typescript的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4typescript%E4%B8%8Ejavascript%E5%8C%BA%E5%88%AB"><span class="toc-number">15.2.</span> <span class="toc-text">说说typescript与javascript区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typescript-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">15.3.</span> <span class="toc-text">typescript 类型注释和类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4typescript%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B"><span class="toc-number">15.4.</span> <span class="toc-text">说说typescript有哪些类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4typescript%E4%B8%AD%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">15.5.</span> <span class="toc-text">说说typescript中高级类型的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9C%A8-TypeScript-%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB"><span class="toc-number">15.6.</span> <span class="toc-text">什么是类？如何在 TypeScript 中创建类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9C%A8-TypeScript-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">15.7.</span> <span class="toc-text">什么是接口？如何在 TypeScript 中使用接口？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%88Generics%EF%BC%89%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9C%A8-TypeScript-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-number">15.8.</span> <span class="toc-text">什么是泛型（Generics）？如何在 TypeScript 中使用泛型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A3%B0%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%EF%BC%88Enum%EF%BC%89%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">15.9.</span> <span class="toc-text">如何声明和使用枚举（Enum）类型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-TypeScript-%E6%96%AD%E8%A8%80%EF%BC%9F"><span class="toc-number">15.10.</span> <span class="toc-text">什么是 TypeScript 断言？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%9A%84%E8%AF%AD%E6%B3%95%E5%92%8C%E7%94%A8%E6%B3%95%E3%80%82"><span class="toc-number">15.11.</span> <span class="toc-text">TypeScript 中的两种类型断言的语法和用法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%EF%BC%9F"><span class="toc-number">15.12.</span> <span class="toc-text">什么时候应该使用类型断言？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%EF%BC%89%EF%BC%9F%E5%AE%83%E5%9C%A8-TypeScript-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">15.13.</span> <span class="toc-text">什么是非空断言运算符（!）？它在 TypeScript 中的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ts%E7%B1%BB"><span class="toc-number">15.14.</span> <span class="toc-text">ts类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ts%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">15.15.</span> <span class="toc-text">ts类的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ts%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">15.16.</span> <span class="toc-text">ts修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ts%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-number">15.17.</span> <span class="toc-text">ts抽象类&amp;使用技巧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ts%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">15.18.</span> <span class="toc-text">ts枚举类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git"><span class="toc-number">16.</span> <span class="toc-text">git</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-Git-%E5%91%BD%E4%BB%A4"><span class="toc-number">16.1.</span> <span class="toc-text">常用 Git 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%92%A4%E9%94%80%E6%9B%B4%E6%94%B9%EF%BC%9F"><span class="toc-number">16.2.</span> <span class="toc-text">如何撤销更改？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9B%9E%E6%BB%9A%E4%BB%A3%E7%A0%81"><span class="toc-number">16.3.</span> <span class="toc-text">如何回滚代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF"><span class="toc-number">16.4.</span> <span class="toc-text">如何合并分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9Crebase%E2%80%9D%EF%BC%8C%E5%AE%83%E4%B8%8E%E2%80%9Cmerge%E2%80%9D%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">16.5.</span> <span class="toc-text">什么是“rebase”，它与“merge”有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81"><span class="toc-number">16.6.</span> <span class="toc-text">解决合并冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%BF%9D%E5%AD%98%E4%B8%B4%E6%97%B6%E5%8C%BA%E5%9F%9F"><span class="toc-number">16.7.</span> <span class="toc-text">将工作区保存临时区域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-%E5%85%BC%E5%AE%B9"><span class="toc-number">17.</span> <span class="toc-text">网络协议 &amp; 兼容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">17.1.</span> <span class="toc-text">http 状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-HTTP-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-number">17.2.</span> <span class="toc-text">介绍 HTTP 的基本原理和工作过程。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">17.3.</span> <span class="toc-text">http长连接和短连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%83%E4%BB%AC%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">17.4.</span> <span class="toc-text">HTTP 请求方法有哪些？它们各自的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89%E3%80%82"><span class="toc-number">17.5.</span> <span class="toc-text">什么是状态码？举例说明几个常见的状态码及其含义。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8DHTTP-1-HTTP-2-%E5%92%8C-HTTP-3-%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">17.6.</span> <span class="toc-text">介绍HTTP&#x2F;1 , HTTP&#x2F;2 和 HTTP&#x2F;3 的特性和区别。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RESTful-%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">17.7.</span> <span class="toc-text">RESTful 架构风格包括哪些设计原则？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E5%92%8Chttps%E5%8C%BA%E5%88%AB"><span class="toc-number">17.8.</span> <span class="toc-text">http和https区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS-%E7%9B%B8%E5%AF%B9%E4%BA%8E-HTTP-%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%82"><span class="toc-number">17.9.</span> <span class="toc-text">HTTPS 相对于 HTTP 的优点和工作原理。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#https%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B-SSL-TLS"><span class="toc-number">17.10.</span> <span class="toc-text">https加密过程(SSL&#x2F; TLS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#https%E8%AF%81%E4%B9%A6%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%AF%A1%E6%94%B9%EF%BC%8C%E9%98%B2%E8%B0%83%E5%8C%85"><span class="toc-number">17.11.</span> <span class="toc-text">https证书如何防止篡改，防调包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSL-TLS-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-number">17.12.</span> <span class="toc-text">SSL&#x2F;TLS 握手过程包括哪些步骤？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get%E5%92%8Cpost%E5%8C%BA%E5%88%AB"><span class="toc-number">17.13.</span> <span class="toc-text">get和post区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86"><span class="toc-number">17.14.</span> <span class="toc-text">浏览器渲染原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98-http%E7%BC%93%E5%AD%98"><span class="toc-number">17.15.</span> <span class="toc-text">浏览器缓存 - http缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98-%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E3%80%82cookie%EF%BC%8ClocalStorage%EF%BC%8Csessionstorage%EF%BC%8C%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E5%93%AA%EF%BC%8C%E5%8F%97%E4%B8%8D%E5%8F%97%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%88%B6%E7%BA%A6"><span class="toc-number">17.16.</span> <span class="toc-text">浏览器缓存 - 本地缓存。cookie，localStorage，sessionstorage，会把数据存在哪，受不受同源策略制约</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#localStorage%E5%AD%98%E5%82%A8%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">17.17.</span> <span class="toc-text">localStorage存储超过限制怎么处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">17.18.</span> <span class="toc-text">跨域请求如何产生？如何解决跨域问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8C%81%E7%94%A8%E6%88%B7%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%9A%84%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6-cookie-%EF%BC%8Csession%EF%BC%8Ctoken"><span class="toc-number">17.19.</span> <span class="toc-text">保持用户会话状态的认证机制 - cookie ，session，token</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie-%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">17.20.</span> <span class="toc-text">cookie 常用属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT-JSON-Web-Token"><span class="toc-number">17.21.</span> <span class="toc-text">JWT(JSON Web Token)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#token-%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0"><span class="toc-number">17.22.</span> <span class="toc-text">token 无感刷新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Websocket-%E7%9B%B8%E5%AF%B9%E4%BA%8E%E4%BC%A0%E7%BB%9F-HTTP-%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="toc-number">17.23.</span> <span class="toc-text">Websocket 相对于传统 HTTP 请求有哪些优势？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Websocket-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-number">17.24.</span> <span class="toc-text">Websocket 建立连接的握手过程。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS-%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">17.25.</span> <span class="toc-text">DNS 解析流程是怎样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%E7%AD%89%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E3%80%82"><span class="toc-number">17.26.</span> <span class="toc-text">DNS 负载均衡、故障恢复等相关概念。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">17.27.</span> <span class="toc-text">OSI七层模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%82"><span class="toc-number">17.28.</span> <span class="toc-text">TCP 和 UDP 的区别及应用场景。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">17.29.</span> <span class="toc-text">TCP 三次握手四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88Three-way-Handshake%EF%BC%89%EF%BC%9A"><span class="toc-number">17.30.</span> <span class="toc-text">TCP 三次握手（Three-way Handshake）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88Four-way-Handshake%EF%BC%89%EF%BC%9A"><span class="toc-number">17.31.</span> <span class="toc-text">TCP 四次挥手（Four-way Handshake）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFUTF-8%E7%BC%96%E7%A0%81"><span class="toc-number">17.32.</span> <span class="toc-text">什么是UTF-8编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">17.33.</span> <span class="toc-text">什么是浏览器兼容性问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%92%8C%E5%A4%84%E7%90%86%E7%89%B9%E5%AE%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">17.34.</span> <span class="toc-text">如何检测和处理特定浏览器的兼容性问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS%E4%B8%80%E8%88%AC%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">17.35.</span> <span class="toc-text">CSS一般会出现什么样的兼容性问题，怎么解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript%E4%B8%80%E8%88%AC%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">17.36.</span> <span class="toc-text">JavaScript一般会出现什么样的兼容性问题，怎么解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">17.37.</span> <span class="toc-text">在项目开发中，如何保证跨浏览器的兼容性？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySql"><span class="toc-number">18.</span> <span class="toc-text">MySql</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/29/xpath%E8%AF%AD%E6%B3%95/" title="Xpath语法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Xpath语法"/></a><div class="content"><a class="title" href="/2024/09/29/xpath%E8%AF%AD%E6%B3%95/" title="Xpath语法">Xpath语法</a><time datetime="2024-09-29T15:57:28.000Z" title="发表于 2024-09-29 23:57:28">2024-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/21/pywinauto-WIN-PC%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96/" title="pywinauto_PC端自动化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pywinauto_PC端自动化"/></a><div class="content"><a class="title" href="/2024/09/21/pywinauto-WIN-PC%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96/" title="pywinauto_PC端自动化">pywinauto_PC端自动化</a><time datetime="2024-09-21T02:35:00.000Z" title="发表于 2024-09-21 10:35:00">2024-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/12/pytest-hooks/" title="Pytest-Hooks"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Pytest-Hooks"/></a><div class="content"><a class="title" href="/2024/09/12/pytest-hooks/" title="Pytest-Hooks">Pytest-Hooks</a><time datetime="2024-09-12T07:38:15.000Z" title="发表于 2024-09-12 15:38:15">2024-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/29/Jmeter-ant%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/" title="Jmeter+ant接口测试"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Jmeter+ant接口测试"/></a><div class="content"><a class="title" href="/2024/08/29/Jmeter-ant%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/" title="Jmeter+ant接口测试">Jmeter+ant接口测试</a><time datetime="2024-08-29T01:05:40.000Z" title="发表于 2024-08-29 09:05:40">2024-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/28/appium-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/" title="Appnium-移动端自动化测试框架"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Appnium-移动端自动化测试框架"/></a><div class="content"><a class="title" href="/2024/08/28/appium-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/" title="Appnium-移动端自动化测试框架">Appnium-移动端自动化测试框架</a><time datetime="2024-08-27T16:30:00.000Z" title="发表于 2024-08-28 00:30:00">2024-08-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://bkimg.cdn.bcebos.com/pic/79f0f736afc379310a5545200188a04543a98226bb2f?x-bce-process=image/format,f_auto/watermark,image_d2F0ZXIvYmFpa2UyNzI,g_7,xp_5,yp_5,P_20/resize,m_lfit,limit_1,h_1080')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By fafafa</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.0.5/dist/lazyload.iife.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.innerHTML = `<pre class="mermaid-src" hidden>${ele.textContent}</pre>`
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.14.0-b3"></script></div></div></body></html>